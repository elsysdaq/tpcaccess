/* soapC.cpp
   Generated by gSOAP 2.7.12 from ..\gSoapInput\TpcServerSoap.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.12 2024-01-29 10:46:26 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns__TpcConstants:
		return soap_in_ns__TpcConstants(soap, NULL, NULL, "ns:TpcConstants");
	case SOAP_TYPE_ns__DiskSpace:
		return soap_in_ns__DiskSpace(soap, NULL, NULL, "ns:DiskSpace");
	case SOAP_TYPE_ns__AutoSequence:
		return soap_in_ns__AutoSequence(soap, NULL, NULL, "ns:AutoSequence");
	case SOAP_TYPE_ns__Data:
		return soap_in_ns__Data(soap, NULL, NULL, "ns:Data");
	case SOAP_TYPE_ns__DataSpecificationArray:
		return soap_in_ns__DataSpecificationArray(soap, NULL, NULL, "ns:DataSpecificationArray");
	case SOAP_TYPE_ns__EnvelopeDataSpecification:
		return soap_in_ns__EnvelopeDataSpecification(soap, NULL, NULL, "ns:EnvelopeDataSpecification");
	case SOAP_TYPE_ns__IndexList:
		return soap_in_ns__IndexList(soap, NULL, NULL, "ns:IndexList");
	case SOAP_TYPE_ns__RangeDataSpecification:
		return soap_in_ns__RangeDataSpecification(soap, NULL, NULL, "ns:RangeDataSpecification");
	case SOAP_TYPE_ns__DataSpecification:
		return soap_in_ns__DataSpecification(soap, NULL, NULL, "ns:DataSpecification");
	case SOAP_TYPE_ns__YMetadataList:
		return soap_in_ns__YMetadataList(soap, NULL, NULL, "ns:YMetadataList");
	case SOAP_TYPE_ns__MetadataList:
		return soap_in_ns__MetadataList(soap, NULL, NULL, "ns:MetadataList");
	case SOAP_TYPE_ns__DeviceData:
		return soap_in_ns__DeviceData(soap, NULL, NULL, "ns:DeviceData");
	case SOAP_TYPE_ns__AttributeList:
		return soap_in_ns__AttributeList(soap, NULL, NULL, "ns:AttributeList");
	case SOAP_TYPE_ns__SetParameterResultList:
		return soap_in_ns__SetParameterResultList(soap, NULL, NULL, "ns:SetParameterResultList");
	case SOAP_TYPE_ns__ParameterList:
		return soap_in_ns__ParameterList(soap, NULL, NULL, "ns:ParameterList");
	case SOAP_TYPE_ns__InputInfoArray:
		return soap_in_ns__InputInfoArray(soap, NULL, NULL, "ns:InputInfoArray");
	case SOAP_TYPE_ns__BoardInfoArray:
		return soap_in_ns__BoardInfoArray(soap, NULL, NULL, "ns:BoardInfoArray");
	case SOAP_TYPE_ns__DeviceInfo:
		return soap_in_ns__DeviceInfo(soap, NULL, NULL, "ns:DeviceInfo");
	case SOAP_TYPE_ns__GetMACAddress:
		return soap_in_ns__GetMACAddress(soap, NULL, NULL, "ns:GetMACAddress");
	case SOAP_TYPE_ns__GetMACAddressResponse:
		return soap_in_ns__GetMACAddressResponse(soap, NULL, NULL, "ns:GetMACAddressResponse");
	case SOAP_TYPE_ns__GetFreeDiskSpace:
		return soap_in_ns__GetFreeDiskSpace(soap, NULL, NULL, "ns:GetFreeDiskSpace");
	case SOAP_TYPE_ns__SetDeviceSettings:
		return soap_in_ns__SetDeviceSettings(soap, NULL, NULL, "ns:SetDeviceSettings");
	case SOAP_TYPE_ns__GetAutoSequence:
		return soap_in_ns__GetAutoSequence(soap, NULL, NULL, "ns:GetAutoSequence");
	case SOAP_TYPE_ns__GetAutoSequenceResponse:
		return soap_in_ns__GetAutoSequenceResponse(soap, NULL, NULL, "ns:GetAutoSequenceResponse");
	case SOAP_TYPE_ns__StopAutoSequence:
		return soap_in_ns__StopAutoSequence(soap, NULL, NULL, "ns:StopAutoSequence");
	case SOAP_TYPE_ns__StopAutoSequenceResponse:
		return soap_in_ns__StopAutoSequenceResponse(soap, NULL, NULL, "ns:StopAutoSequenceResponse");
	case SOAP_TYPE_ns__StartAutoSequence:
		return soap_in_ns__StartAutoSequence(soap, NULL, NULL, "ns:StartAutoSequence");
	case SOAP_TYPE_ns__StartAutoSequenceResponse:
		return soap_in_ns__StartAutoSequenceResponse(soap, NULL, NULL, "ns:StartAutoSequenceResponse");
	case SOAP_TYPE_ns__LoadAutosequence:
		return soap_in_ns__LoadAutosequence(soap, NULL, NULL, "ns:LoadAutosequence");
	case SOAP_TYPE_ns__LoadAutosequenceResponse:
		return soap_in_ns__LoadAutosequenceResponse(soap, NULL, NULL, "ns:LoadAutosequenceResponse");
	case SOAP_TYPE_ns__SendServerCustomCommand:
		return soap_in_ns__SendServerCustomCommand(soap, NULL, NULL, "ns:SendServerCustomCommand");
	case SOAP_TYPE_ns__SendServerCustomCommandResponse:
		return soap_in_ns__SendServerCustomCommandResponse(soap, NULL, NULL, "ns:SendServerCustomCommandResponse");
	case SOAP_TYPE_ns__DataBlockHeader:
		return soap_in_ns__DataBlockHeader(soap, NULL, NULL, "ns:DataBlockHeader");
	case SOAP_TYPE_ns__GetData:
		return soap_in_ns__GetData(soap, NULL, NULL, "ns:GetData");
	case SOAP_TYPE_ns__GetDataResponse:
		return soap_in_ns__GetDataResponse(soap, NULL, NULL, "ns:GetDataResponse");
	case SOAP_TYPE_ns__GetAllYMetadata:
		return soap_in_ns__GetAllYMetadata(soap, NULL, NULL, "ns:GetAllYMetadata");
	case SOAP_TYPE_ns__GetAllYMetadataResponse:
		return soap_in_ns__GetAllYMetadataResponse(soap, NULL, NULL, "ns:GetAllYMetadataResponse");
	case SOAP_TYPE_ns__YMetadata:
		return soap_in_ns__YMetadata(soap, NULL, NULL, "ns:YMetadata");
	case SOAP_TYPE_ns__GetMetadata:
		return soap_in_ns__GetMetadata(soap, NULL, NULL, "ns:GetMetadata");
	case SOAP_TYPE_ns__GetMetadataResponse:
		return soap_in_ns__GetMetadataResponse(soap, NULL, NULL, "ns:GetMetadataResponse");
	case SOAP_TYPE_ns__Metadata:
		return soap_in_ns__Metadata(soap, NULL, NULL, "ns:Metadata");
	case SOAP_TYPE_ns__LeaveWaitStatus:
		return soap_in_ns__LeaveWaitStatus(soap, NULL, NULL, "ns:LeaveWaitStatus");
	case SOAP_TYPE_ns__WaitForStatusChange:
		return soap_in_ns__WaitForStatusChange(soap, NULL, NULL, "ns:WaitForStatusChange");
	case SOAP_TYPE_ns__GetStatus:
		return soap_in_ns__GetStatus(soap, NULL, NULL, "ns:GetStatus");
	case SOAP_TYPE_ns__Status:
		return soap_in_ns__Status(soap, NULL, NULL, "ns:Status");
	case SOAP_TYPE_ns__DeviceStatus:
		return soap_in_ns__DeviceStatus(soap, NULL, NULL, "ns:DeviceStatus");
	case SOAP_TYPE_ns__TempStatus:
		return soap_in_ns__TempStatus(soap, NULL, NULL, "ns:TempStatus");
	case SOAP_TYPE_ns__GPSStatus:
		return soap_in_ns__GPSStatus(soap, NULL, NULL, "ns:GPSStatus");
	case SOAP_TYPE_ns__BoardStatus:
		return soap_in_ns__BoardStatus(soap, NULL, NULL, "ns:BoardStatus");
	case SOAP_TYPE_ns__InputStatus:
		return soap_in_ns__InputStatus(soap, NULL, NULL, "ns:InputStatus");
	case SOAP_TYPE_ns__StartCalibration:
		return soap_in_ns__StartCalibration(soap, NULL, NULL, "ns:StartCalibration");
	case SOAP_TYPE_ns__ExecuteCommand:
		return soap_in_ns__ExecuteCommand(soap, NULL, NULL, "ns:ExecuteCommand");
	case SOAP_TYPE_ns__SetStartInfo:
		return soap_in_ns__SetStartInfo(soap, NULL, NULL, "ns:SetStartInfo");
	case SOAP_TYPE_ns__PrepareStart:
		return soap_in_ns__PrepareStart(soap, NULL, NULL, "ns:PrepareStart");
	case SOAP_TYPE_ns__PrepareStartResponse:
		return soap_in_ns__PrepareStartResponse(soap, NULL, NULL, "ns:PrepareStartResponse");
	case SOAP_TYPE_ns__ReadWriteTwi:
		return soap_in_ns__ReadWriteTwi(soap, NULL, NULL, "ns:ReadWriteTwi");
	case SOAP_TYPE_ns__ReadWriteTwiResponse:
		return soap_in_ns__ReadWriteTwiResponse(soap, NULL, NULL, "ns:ReadWriteTwiResponse");
	case SOAP_TYPE_ns__ReadDev:
		return soap_in_ns__ReadDev(soap, NULL, NULL, "ns:ReadDev");
	case SOAP_TYPE_ns__ReadDevResponse:
		return soap_in_ns__ReadDevResponse(soap, NULL, NULL, "ns:ReadDevResponse");
	case SOAP_TYPE_ns__WriteDev:
		return soap_in_ns__WriteDev(soap, NULL, NULL, "ns:WriteDev");
	case SOAP_TYPE_ns__GetGPSLogList:
		return soap_in_ns__GetGPSLogList(soap, NULL, NULL, "ns:GetGPSLogList");
	case SOAP_TYPE_ns__GetGPSLogListResponse:
		return soap_in_ns__GetGPSLogListResponse(soap, NULL, NULL, "ns:GetGPSLogListResponse");
	case SOAP_TYPE_ns__GPSLogList:
		return soap_in_ns__GPSLogList(soap, NULL, NULL, "ns:GPSLogList");
	case SOAP_TYPE_ns__GPSLog:
		return soap_in_ns__GPSLog(soap, NULL, NULL, "ns:GPSLog");
	case SOAP_TYPE_ns__SetAssociations:
		return soap_in_ns__SetAssociations(soap, NULL, NULL, "ns:SetAssociations");
	case SOAP_TYPE_ns__GetAllPreviousAssociations:
		return soap_in_ns__GetAllPreviousAssociations(soap, NULL, NULL, "ns:GetAllPreviousAssociations");
	case SOAP_TYPE_ns__GetAllPreviousAssociationsResponse:
		return soap_in_ns__GetAllPreviousAssociationsResponse(soap, NULL, NULL, "ns:GetAllPreviousAssociationsResponse");
	case SOAP_TYPE_ns__GetAllCurrentAssociations:
		return soap_in_ns__GetAllCurrentAssociations(soap, NULL, NULL, "ns:GetAllCurrentAssociations");
	case SOAP_TYPE_ns__GetAllCurrentAssociationsResponse:
		return soap_in_ns__GetAllCurrentAssociationsResponse(soap, NULL, NULL, "ns:GetAllCurrentAssociationsResponse");
	case SOAP_TYPE_ns__AssociationRowList:
		return soap_in_ns__AssociationRowList(soap, NULL, NULL, "ns:AssociationRowList");
	case SOAP_TYPE_ns__AssociationRow:
		return soap_in_ns__AssociationRow(soap, NULL, NULL, "ns:AssociationRow");
	case SOAP_TYPE_ns__AssociationChannelList:
		return soap_in_ns__AssociationChannelList(soap, NULL, NULL, "ns:AssociationChannelList");
	case SOAP_TYPE_ns__AssociationChannel:
		return soap_in_ns__AssociationChannel(soap, NULL, NULL, "ns:AssociationChannel");
	case SOAP_TYPE_ns__GetCANTrigger:
		return soap_in_ns__GetCANTrigger(soap, NULL, NULL, "ns:GetCANTrigger");
	case SOAP_TYPE_ns__SetCANTrigger:
		return soap_in_ns__SetCANTrigger(soap, NULL, NULL, "ns:SetCANTrigger");
	case SOAP_TYPE_ns__GetI2CTrigger:
		return soap_in_ns__GetI2CTrigger(soap, NULL, NULL, "ns:GetI2CTrigger");
	case SOAP_TYPE_ns__SetI2CTrigger:
		return soap_in_ns__SetI2CTrigger(soap, NULL, NULL, "ns:SetI2CTrigger");
	case SOAP_TYPE_ns__ResetSerTrg:
		return soap_in_ns__ResetSerTrg(soap, NULL, NULL, "ns:ResetSerTrg");
	case SOAP_TYPE_ns__GetSerTrgProtocol:
		return soap_in_ns__GetSerTrgProtocol(soap, NULL, NULL, "ns:GetSerTrgProtocol");
	case SOAP_TYPE_ns__GetSerTrgProtocolResponse:
		return soap_in_ns__GetSerTrgProtocolResponse(soap, NULL, NULL, "ns:GetSerTrgProtocolResponse");
	case SOAP_TYPE_ns__CANTriggerSettings:
		return soap_in_ns__CANTriggerSettings(soap, NULL, NULL, "ns:CANTriggerSettings");
	case SOAP_TYPE_ns__I2CTriggerSettings:
		return soap_in_ns__I2CTriggerSettings(soap, NULL, NULL, "ns:I2CTriggerSettings");
	case SOAP_TYPE_ns__GetAllPreviousAttributes:
		return soap_in_ns__GetAllPreviousAttributes(soap, NULL, NULL, "ns:GetAllPreviousAttributes");
	case SOAP_TYPE_ns__GetAllPreviousAttributesResponse:
		return soap_in_ns__GetAllPreviousAttributesResponse(soap, NULL, NULL, "ns:GetAllPreviousAttributesResponse");
	case SOAP_TYPE_ns__GetAllCurrentAttributes:
		return soap_in_ns__GetAllCurrentAttributes(soap, NULL, NULL, "ns:GetAllCurrentAttributes");
	case SOAP_TYPE_ns__GetAllCurrentAttributesResponse:
		return soap_in_ns__GetAllCurrentAttributesResponse(soap, NULL, NULL, "ns:GetAllCurrentAttributesResponse");
	case SOAP_TYPE_ns__SetAttributes:
		return soap_in_ns__SetAttributes(soap, NULL, NULL, "ns:SetAttributes");
	case SOAP_TYPE_ns__Attribute:
		return soap_in_ns__Attribute(soap, NULL, NULL, "ns:Attribute");
	case SOAP_TYPE_ns__GetAllPreviousParameters:
		return soap_in_ns__GetAllPreviousParameters(soap, NULL, NULL, "ns:GetAllPreviousParameters");
	case SOAP_TYPE_ns__GetAllPreviousParametersResponse:
		return soap_in_ns__GetAllPreviousParametersResponse(soap, NULL, NULL, "ns:GetAllPreviousParametersResponse");
	case SOAP_TYPE_ns__GetAllCurrentParameters:
		return soap_in_ns__GetAllCurrentParameters(soap, NULL, NULL, "ns:GetAllCurrentParameters");
	case SOAP_TYPE_ns__GetAllCurrentParametersResponse:
		return soap_in_ns__GetAllCurrentParametersResponse(soap, NULL, NULL, "ns:GetAllCurrentParametersResponse");
	case SOAP_TYPE_ns__SetMultipleParameters:
		return soap_in_ns__SetMultipleParameters(soap, NULL, NULL, "ns:SetMultipleParameters");
	case SOAP_TYPE_ns__SetMultipleParametersResponse:
		return soap_in_ns__SetMultipleParametersResponse(soap, NULL, NULL, "ns:SetMultipleParametersResponse");
	case SOAP_TYPE_ns__SetOneParameter:
		return soap_in_ns__SetOneParameter(soap, NULL, NULL, "ns:SetOneParameter");
	case SOAP_TYPE_ns__SetOneParameterResult:
		return soap_in_ns__SetOneParameterResult(soap, NULL, NULL, "ns:SetOneParameterResult");
	case SOAP_TYPE_ns__Parameter:
		return soap_in_ns__Parameter(soap, NULL, NULL, "ns:Parameter");
	case SOAP_TYPE_ns__GetHardwareInfo:
		return soap_in_ns__GetHardwareInfo(soap, NULL, NULL, "ns:GetHardwareInfo");
	case SOAP_TYPE_ns__HardwareInfo:
		return soap_in_ns__HardwareInfo(soap, NULL, NULL, "ns:HardwareInfo");
	case SOAP_TYPE_ns__TaggedInputInfo:
		return soap_in_ns__TaggedInputInfo(soap, NULL, NULL, "ns:TaggedInputInfo");
	case SOAP_TYPE_ns__TaggedBoardInfo:
		return soap_in_ns__TaggedBoardInfo(soap, NULL, NULL, "ns:TaggedBoardInfo");
	case SOAP_TYPE_ns__InputInfo:
		return soap_in_ns__InputInfo(soap, NULL, NULL, "ns:InputInfo");
	case SOAP_TYPE_ns__BoardInfo:
		return soap_in_ns__BoardInfo(soap, NULL, NULL, "ns:BoardInfo");
	case SOAP_TYPE_ns__SetClusterConfiguration:
		return soap_in_ns__SetClusterConfiguration(soap, NULL, NULL, "ns:SetClusterConfiguration");
	case SOAP_TYPE_ns__GetClusterConfiguration:
		return soap_in_ns__GetClusterConfiguration(soap, NULL, NULL, "ns:GetClusterConfiguration");
	case SOAP_TYPE_ns__ClusterConfiguration:
		return soap_in_ns__ClusterConfiguration(soap, NULL, NULL, "ns:ClusterConfiguration");
	case SOAP_TYPE_ns__ReleaseDeviceLock:
		return soap_in_ns__ReleaseDeviceLock(soap, NULL, NULL, "ns:ReleaseDeviceLock");
	case SOAP_TYPE_ns__AcquireDeviceLock:
		return soap_in_ns__AcquireDeviceLock(soap, NULL, NULL, "ns:AcquireDeviceLock");
	case SOAP_TYPE_ns__ResetConfiguration:
		return soap_in_ns__ResetConfiguration(soap, NULL, NULL, "ns:ResetConfiguration");
	case SOAP_TYPE_ns__GetInterfaceVersion:
		return soap_in_ns__GetInterfaceVersion(soap, NULL, NULL, "ns:GetInterfaceVersion");
	case SOAP_TYPE_ns__GetInterfaceVersionResponse:
		return soap_in_ns__GetInterfaceVersionResponse(soap, NULL, NULL, "ns:GetInterfaceVersionResponse");
	case SOAP_TYPE_ns__DateTime:
		return soap_in_ns__DateTime(soap, NULL, NULL, "ns:DateTime");
	case SOAP_TYPE_ns__DummyResponse:
		return soap_in_ns__DummyResponse(soap, NULL, NULL, "ns:DummyResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons__DataSpecification:
		return soap_in_PointerToPointerTons__DataSpecification(soap, NULL, NULL, "ns:DataSpecification");
	case SOAP_TYPE_PointerTons__DataSpecification:
		return soap_in_PointerTons__DataSpecification(soap, NULL, NULL, "ns:DataSpecification");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTons__YMetadata:
		return soap_in_PointerTons__YMetadata(soap, NULL, NULL, "ns:YMetadata");
	case SOAP_TYPE_PointerTons__Metadata:
		return soap_in_PointerTons__Metadata(soap, NULL, NULL, "ns:Metadata");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTons__GPSLog:
		return soap_in_PointerTons__GPSLog(soap, NULL, NULL, "ns:GPSLog");
	case SOAP_TYPE_PointerTons__AssociationRow:
		return soap_in_PointerTons__AssociationRow(soap, NULL, NULL, "ns:AssociationRow");
	case SOAP_TYPE_PointerTons__AssociationChannel:
		return soap_in_PointerTons__AssociationChannel(soap, NULL, NULL, "ns:AssociationChannel");
	case SOAP_TYPE_PointerTons__Attribute:
		return soap_in_PointerTons__Attribute(soap, NULL, NULL, "ns:Attribute");
	case SOAP_TYPE_PointerTons__SetOneParameterResult:
		return soap_in_PointerTons__SetOneParameterResult(soap, NULL, NULL, "ns:SetOneParameterResult");
	case SOAP_TYPE_PointerTons__Parameter:
		return soap_in_PointerTons__Parameter(soap, NULL, NULL, "ns:Parameter");
	case SOAP_TYPE_PointerTons__TaggedInputInfo:
		return soap_in_PointerTons__TaggedInputInfo(soap, NULL, NULL, "ns:TaggedInputInfo");
	case SOAP_TYPE_PointerTons__TaggedBoardInfo:
		return soap_in_PointerTons__TaggedBoardInfo(soap, NULL, NULL, "ns:TaggedBoardInfo");
	case SOAP_TYPE_PointerTons__DummyResponse:
		return soap_in_PointerTons__DummyResponse(soap, NULL, NULL, "ns:DummyResponse");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_Array16Ofns__BoardStatus:
		return soap_in_Array16Ofns__BoardStatus(soap, NULL, NULL, "ns:BoardStatus");
	case SOAP_TYPE_Array8Ofns__InputStatus:
		return soap_in_Array8Ofns__InputStatus(soap, NULL, NULL, "ns:InputStatus");
	case SOAP_TYPE_Array128Ofbyte:
		return soap_in_Array128Ofbyte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_Array8Ofbyte:
		return soap_in_Array8Ofbyte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_Array16Ofbyte:
		return soap_in_Array16Ofbyte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_Array12Ofint:
		return soap_in_Array12Ofint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_Array11Ofdouble:
		return soap_in_Array11Ofdouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_Array16Ofint:
		return soap_in_Array16Ofint(soap, NULL, NULL, "xsd:int");
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns:DiskSpace"))
		{	*type = SOAP_TYPE_ns__DiskSpace;
			return soap_in_ns__DiskSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AutoSequence"))
		{	*type = SOAP_TYPE_ns__AutoSequence;
			return soap_in_ns__AutoSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Data"))
		{	*type = SOAP_TYPE_ns__Data;
			return soap_in_ns__Data(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DataSpecificationArray"))
		{	*type = SOAP_TYPE_ns__DataSpecificationArray;
			return soap_in_ns__DataSpecificationArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:EnvelopeDataSpecification"))
		{	*type = SOAP_TYPE_ns__EnvelopeDataSpecification;
			return soap_in_ns__EnvelopeDataSpecification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:IndexList"))
		{	*type = SOAP_TYPE_ns__IndexList;
			return soap_in_ns__IndexList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:RangeDataSpecification"))
		{	*type = SOAP_TYPE_ns__RangeDataSpecification;
			return soap_in_ns__RangeDataSpecification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DataSpecification"))
		{	*type = SOAP_TYPE_ns__DataSpecification;
			return soap_in_ns__DataSpecification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:YMetadataList"))
		{	*type = SOAP_TYPE_ns__YMetadataList;
			return soap_in_ns__YMetadataList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:MetadataList"))
		{	*type = SOAP_TYPE_ns__MetadataList;
			return soap_in_ns__MetadataList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceData"))
		{	*type = SOAP_TYPE_ns__DeviceData;
			return soap_in_ns__DeviceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AttributeList"))
		{	*type = SOAP_TYPE_ns__AttributeList;
			return soap_in_ns__AttributeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetParameterResultList"))
		{	*type = SOAP_TYPE_ns__SetParameterResultList;
			return soap_in_ns__SetParameterResultList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ParameterList"))
		{	*type = SOAP_TYPE_ns__ParameterList;
			return soap_in_ns__ParameterList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:InputInfoArray"))
		{	*type = SOAP_TYPE_ns__InputInfoArray;
			return soap_in_ns__InputInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:BoardInfoArray"))
		{	*type = SOAP_TYPE_ns__BoardInfoArray;
			return soap_in_ns__BoardInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceInfo"))
		{	*type = SOAP_TYPE_ns__DeviceInfo;
			return soap_in_ns__DeviceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TpcConstants"))
		{	*type = SOAP_TYPE_ns__TpcConstants;
			return soap_in_ns__TpcConstants(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetMACAddress"))
		{	*type = SOAP_TYPE_ns__GetMACAddress;
			return soap_in_ns__GetMACAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetMACAddressResponse"))
		{	*type = SOAP_TYPE_ns__GetMACAddressResponse;
			return soap_in_ns__GetMACAddressResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetFreeDiskSpace"))
		{	*type = SOAP_TYPE_ns__GetFreeDiskSpace;
			return soap_in_ns__GetFreeDiskSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetDeviceSettings"))
		{	*type = SOAP_TYPE_ns__SetDeviceSettings;
			return soap_in_ns__SetDeviceSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAutoSequence"))
		{	*type = SOAP_TYPE_ns__GetAutoSequence;
			return soap_in_ns__GetAutoSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAutoSequenceResponse"))
		{	*type = SOAP_TYPE_ns__GetAutoSequenceResponse;
			return soap_in_ns__GetAutoSequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:StopAutoSequence"))
		{	*type = SOAP_TYPE_ns__StopAutoSequence;
			return soap_in_ns__StopAutoSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:StopAutoSequenceResponse"))
		{	*type = SOAP_TYPE_ns__StopAutoSequenceResponse;
			return soap_in_ns__StopAutoSequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:StartAutoSequence"))
		{	*type = SOAP_TYPE_ns__StartAutoSequence;
			return soap_in_ns__StartAutoSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:StartAutoSequenceResponse"))
		{	*type = SOAP_TYPE_ns__StartAutoSequenceResponse;
			return soap_in_ns__StartAutoSequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:LoadAutosequence"))
		{	*type = SOAP_TYPE_ns__LoadAutosequence;
			return soap_in_ns__LoadAutosequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:LoadAutosequenceResponse"))
		{	*type = SOAP_TYPE_ns__LoadAutosequenceResponse;
			return soap_in_ns__LoadAutosequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SendServerCustomCommand"))
		{	*type = SOAP_TYPE_ns__SendServerCustomCommand;
			return soap_in_ns__SendServerCustomCommand(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SendServerCustomCommandResponse"))
		{	*type = SOAP_TYPE_ns__SendServerCustomCommandResponse;
			return soap_in_ns__SendServerCustomCommandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DataBlockHeader"))
		{	*type = SOAP_TYPE_ns__DataBlockHeader;
			return soap_in_ns__DataBlockHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetData"))
		{	*type = SOAP_TYPE_ns__GetData;
			return soap_in_ns__GetData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDataResponse"))
		{	*type = SOAP_TYPE_ns__GetDataResponse;
			return soap_in_ns__GetDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllYMetadata"))
		{	*type = SOAP_TYPE_ns__GetAllYMetadata;
			return soap_in_ns__GetAllYMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllYMetadataResponse"))
		{	*type = SOAP_TYPE_ns__GetAllYMetadataResponse;
			return soap_in_ns__GetAllYMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:YMetadata"))
		{	*type = SOAP_TYPE_ns__YMetadata;
			return soap_in_ns__YMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetMetadata"))
		{	*type = SOAP_TYPE_ns__GetMetadata;
			return soap_in_ns__GetMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetMetadataResponse"))
		{	*type = SOAP_TYPE_ns__GetMetadataResponse;
			return soap_in_ns__GetMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Metadata"))
		{	*type = SOAP_TYPE_ns__Metadata;
			return soap_in_ns__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:LeaveWaitStatus"))
		{	*type = SOAP_TYPE_ns__LeaveWaitStatus;
			return soap_in_ns__LeaveWaitStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:WaitForStatusChange"))
		{	*type = SOAP_TYPE_ns__WaitForStatusChange;
			return soap_in_ns__WaitForStatusChange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetStatus"))
		{	*type = SOAP_TYPE_ns__GetStatus;
			return soap_in_ns__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Status"))
		{	*type = SOAP_TYPE_ns__Status;
			return soap_in_ns__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatus"))
		{	*type = SOAP_TYPE_ns__DeviceStatus;
			return soap_in_ns__DeviceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TempStatus"))
		{	*type = SOAP_TYPE_ns__TempStatus;
			return soap_in_ns__TempStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GPSStatus"))
		{	*type = SOAP_TYPE_ns__GPSStatus;
			return soap_in_ns__GPSStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:BoardStatus"))
		{	*type = SOAP_TYPE_ns__BoardStatus;
			return soap_in_ns__BoardStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:InputStatus"))
		{	*type = SOAP_TYPE_ns__InputStatus;
			return soap_in_ns__InputStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:StartCalibration"))
		{	*type = SOAP_TYPE_ns__StartCalibration;
			return soap_in_ns__StartCalibration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ExecuteCommand"))
		{	*type = SOAP_TYPE_ns__ExecuteCommand;
			return soap_in_ns__ExecuteCommand(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetStartInfo"))
		{	*type = SOAP_TYPE_ns__SetStartInfo;
			return soap_in_ns__SetStartInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:PrepareStart"))
		{	*type = SOAP_TYPE_ns__PrepareStart;
			return soap_in_ns__PrepareStart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:PrepareStartResponse"))
		{	*type = SOAP_TYPE_ns__PrepareStartResponse;
			return soap_in_ns__PrepareStartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ReadWriteTwi"))
		{	*type = SOAP_TYPE_ns__ReadWriteTwi;
			return soap_in_ns__ReadWriteTwi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ReadWriteTwiResponse"))
		{	*type = SOAP_TYPE_ns__ReadWriteTwiResponse;
			return soap_in_ns__ReadWriteTwiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ReadDev"))
		{	*type = SOAP_TYPE_ns__ReadDev;
			return soap_in_ns__ReadDev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ReadDevResponse"))
		{	*type = SOAP_TYPE_ns__ReadDevResponse;
			return soap_in_ns__ReadDevResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:WriteDev"))
		{	*type = SOAP_TYPE_ns__WriteDev;
			return soap_in_ns__WriteDev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetGPSLogList"))
		{	*type = SOAP_TYPE_ns__GetGPSLogList;
			return soap_in_ns__GetGPSLogList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetGPSLogListResponse"))
		{	*type = SOAP_TYPE_ns__GetGPSLogListResponse;
			return soap_in_ns__GetGPSLogListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GPSLogList"))
		{	*type = SOAP_TYPE_ns__GPSLogList;
			return soap_in_ns__GPSLogList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GPSLog"))
		{	*type = SOAP_TYPE_ns__GPSLog;
			return soap_in_ns__GPSLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetAssociations"))
		{	*type = SOAP_TYPE_ns__SetAssociations;
			return soap_in_ns__SetAssociations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllPreviousAssociations"))
		{	*type = SOAP_TYPE_ns__GetAllPreviousAssociations;
			return soap_in_ns__GetAllPreviousAssociations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllPreviousAssociationsResponse"))
		{	*type = SOAP_TYPE_ns__GetAllPreviousAssociationsResponse;
			return soap_in_ns__GetAllPreviousAssociationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllCurrentAssociations"))
		{	*type = SOAP_TYPE_ns__GetAllCurrentAssociations;
			return soap_in_ns__GetAllCurrentAssociations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllCurrentAssociationsResponse"))
		{	*type = SOAP_TYPE_ns__GetAllCurrentAssociationsResponse;
			return soap_in_ns__GetAllCurrentAssociationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AssociationRowList"))
		{	*type = SOAP_TYPE_ns__AssociationRowList;
			return soap_in_ns__AssociationRowList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AssociationRow"))
		{	*type = SOAP_TYPE_ns__AssociationRow;
			return soap_in_ns__AssociationRow(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AssociationChannelList"))
		{	*type = SOAP_TYPE_ns__AssociationChannelList;
			return soap_in_ns__AssociationChannelList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AssociationChannel"))
		{	*type = SOAP_TYPE_ns__AssociationChannel;
			return soap_in_ns__AssociationChannel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetCANTrigger"))
		{	*type = SOAP_TYPE_ns__GetCANTrigger;
			return soap_in_ns__GetCANTrigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetCANTrigger"))
		{	*type = SOAP_TYPE_ns__SetCANTrigger;
			return soap_in_ns__SetCANTrigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetI2CTrigger"))
		{	*type = SOAP_TYPE_ns__GetI2CTrigger;
			return soap_in_ns__GetI2CTrigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetI2CTrigger"))
		{	*type = SOAP_TYPE_ns__SetI2CTrigger;
			return soap_in_ns__SetI2CTrigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ResetSerTrg"))
		{	*type = SOAP_TYPE_ns__ResetSerTrg;
			return soap_in_ns__ResetSerTrg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetSerTrgProtocol"))
		{	*type = SOAP_TYPE_ns__GetSerTrgProtocol;
			return soap_in_ns__GetSerTrgProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetSerTrgProtocolResponse"))
		{	*type = SOAP_TYPE_ns__GetSerTrgProtocolResponse;
			return soap_in_ns__GetSerTrgProtocolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:CANTriggerSettings"))
		{	*type = SOAP_TYPE_ns__CANTriggerSettings;
			return soap_in_ns__CANTriggerSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:I2CTriggerSettings"))
		{	*type = SOAP_TYPE_ns__I2CTriggerSettings;
			return soap_in_ns__I2CTriggerSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllPreviousAttributes"))
		{	*type = SOAP_TYPE_ns__GetAllPreviousAttributes;
			return soap_in_ns__GetAllPreviousAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllPreviousAttributesResponse"))
		{	*type = SOAP_TYPE_ns__GetAllPreviousAttributesResponse;
			return soap_in_ns__GetAllPreviousAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllCurrentAttributes"))
		{	*type = SOAP_TYPE_ns__GetAllCurrentAttributes;
			return soap_in_ns__GetAllCurrentAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllCurrentAttributesResponse"))
		{	*type = SOAP_TYPE_ns__GetAllCurrentAttributesResponse;
			return soap_in_ns__GetAllCurrentAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetAttributes"))
		{	*type = SOAP_TYPE_ns__SetAttributes;
			return soap_in_ns__SetAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Attribute"))
		{	*type = SOAP_TYPE_ns__Attribute;
			return soap_in_ns__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllPreviousParameters"))
		{	*type = SOAP_TYPE_ns__GetAllPreviousParameters;
			return soap_in_ns__GetAllPreviousParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllPreviousParametersResponse"))
		{	*type = SOAP_TYPE_ns__GetAllPreviousParametersResponse;
			return soap_in_ns__GetAllPreviousParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllCurrentParameters"))
		{	*type = SOAP_TYPE_ns__GetAllCurrentParameters;
			return soap_in_ns__GetAllCurrentParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllCurrentParametersResponse"))
		{	*type = SOAP_TYPE_ns__GetAllCurrentParametersResponse;
			return soap_in_ns__GetAllCurrentParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetMultipleParameters"))
		{	*type = SOAP_TYPE_ns__SetMultipleParameters;
			return soap_in_ns__SetMultipleParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetMultipleParametersResponse"))
		{	*type = SOAP_TYPE_ns__SetMultipleParametersResponse;
			return soap_in_ns__SetMultipleParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetOneParameter"))
		{	*type = SOAP_TYPE_ns__SetOneParameter;
			return soap_in_ns__SetOneParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetOneParameterResult"))
		{	*type = SOAP_TYPE_ns__SetOneParameterResult;
			return soap_in_ns__SetOneParameterResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Parameter"))
		{	*type = SOAP_TYPE_ns__Parameter;
			return soap_in_ns__Parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetHardwareInfo"))
		{	*type = SOAP_TYPE_ns__GetHardwareInfo;
			return soap_in_ns__GetHardwareInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:HardwareInfo"))
		{	*type = SOAP_TYPE_ns__HardwareInfo;
			return soap_in_ns__HardwareInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TaggedInputInfo"))
		{	*type = SOAP_TYPE_ns__TaggedInputInfo;
			return soap_in_ns__TaggedInputInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TaggedBoardInfo"))
		{	*type = SOAP_TYPE_ns__TaggedBoardInfo;
			return soap_in_ns__TaggedBoardInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:InputInfo"))
		{	*type = SOAP_TYPE_ns__InputInfo;
			return soap_in_ns__InputInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:BoardInfo"))
		{	*type = SOAP_TYPE_ns__BoardInfo;
			return soap_in_ns__BoardInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetClusterConfiguration"))
		{	*type = SOAP_TYPE_ns__SetClusterConfiguration;
			return soap_in_ns__SetClusterConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetClusterConfiguration"))
		{	*type = SOAP_TYPE_ns__GetClusterConfiguration;
			return soap_in_ns__GetClusterConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ClusterConfiguration"))
		{	*type = SOAP_TYPE_ns__ClusterConfiguration;
			return soap_in_ns__ClusterConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ReleaseDeviceLock"))
		{	*type = SOAP_TYPE_ns__ReleaseDeviceLock;
			return soap_in_ns__ReleaseDeviceLock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AcquireDeviceLock"))
		{	*type = SOAP_TYPE_ns__AcquireDeviceLock;
			return soap_in_ns__AcquireDeviceLock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ResetConfiguration"))
		{	*type = SOAP_TYPE_ns__ResetConfiguration;
			return soap_in_ns__ResetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetInterfaceVersion"))
		{	*type = SOAP_TYPE_ns__GetInterfaceVersion;
			return soap_in_ns__GetInterfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetInterfaceVersionResponse"))
		{	*type = SOAP_TYPE_ns__GetInterfaceVersionResponse;
			return soap_in_ns__GetInterfaceVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DateTime"))
		{	*type = SOAP_TYPE_ns__DateTime;
			return soap_in_ns__DateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DummyResponse"))
		{	*type = SOAP_TYPE_ns__DummyResponse;
			return soap_in_ns__DummyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns:BoardStatus"))
		{	*type = SOAP_TYPE_Array16Ofns__BoardStatus;
			return soap_in_Array16Ofns__BoardStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:InputStatus"))
		{	*type = SOAP_TYPE_Array8Ofns__InputStatus;
			return soap_in_Array8Ofns__InputStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Array128Ofbyte;
			return soap_in_Array128Ofbyte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Array8Ofbyte;
			return soap_in_Array8Ofbyte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Array16Ofbyte;
			return soap_in_Array16Ofbyte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_Array12Ofint;
			return soap_in_Array12Ofint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_Array11Ofdouble;
			return soap_in_Array11Ofdouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_Array16Ofint;
			return soap_in_Array16Ofint(soap, NULL, NULL, NULL);
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns__TpcConstants:
		return soap_out_ns__TpcConstants(soap, tag, id, (const enum ns__TpcConstants *)ptr, "ns:TpcConstants");
	case SOAP_TYPE_ns__DiskSpace:
		return ((ns__DiskSpace *)ptr)->soap_out(soap, tag, id, "ns:DiskSpace");
	case SOAP_TYPE_ns__AutoSequence:
		return ((ns__AutoSequence *)ptr)->soap_out(soap, tag, id, "ns:AutoSequence");
	case SOAP_TYPE_ns__Data:
		return ((ns__Data *)ptr)->soap_out(soap, tag, id, "ns:Data");
	case SOAP_TYPE_ns__DataSpecificationArray:
		return ((ns__DataSpecificationArray *)ptr)->soap_out(soap, tag, id, "ns:DataSpecificationArray");
	case SOAP_TYPE_ns__EnvelopeDataSpecification:
		return ((ns__EnvelopeDataSpecification *)ptr)->soap_out(soap, tag, id, "ns:EnvelopeDataSpecification");
	case SOAP_TYPE_ns__IndexList:
		return ((ns__IndexList *)ptr)->soap_out(soap, tag, id, "ns:IndexList");
	case SOAP_TYPE_ns__RangeDataSpecification:
		return ((ns__RangeDataSpecification *)ptr)->soap_out(soap, tag, id, "ns:RangeDataSpecification");
	case SOAP_TYPE_ns__DataSpecification:
		return ((ns__DataSpecification *)ptr)->soap_out(soap, tag, id, "ns:DataSpecification");
	case SOAP_TYPE_ns__YMetadataList:
		return ((ns__YMetadataList *)ptr)->soap_out(soap, tag, id, "ns:YMetadataList");
	case SOAP_TYPE_ns__MetadataList:
		return ((ns__MetadataList *)ptr)->soap_out(soap, tag, id, "ns:MetadataList");
	case SOAP_TYPE_ns__DeviceData:
		return ((ns__DeviceData *)ptr)->soap_out(soap, tag, id, "ns:DeviceData");
	case SOAP_TYPE_ns__AttributeList:
		return ((ns__AttributeList *)ptr)->soap_out(soap, tag, id, "ns:AttributeList");
	case SOAP_TYPE_ns__SetParameterResultList:
		return ((ns__SetParameterResultList *)ptr)->soap_out(soap, tag, id, "ns:SetParameterResultList");
	case SOAP_TYPE_ns__ParameterList:
		return ((ns__ParameterList *)ptr)->soap_out(soap, tag, id, "ns:ParameterList");
	case SOAP_TYPE_ns__InputInfoArray:
		return ((ns__InputInfoArray *)ptr)->soap_out(soap, tag, id, "ns:InputInfoArray");
	case SOAP_TYPE_ns__BoardInfoArray:
		return ((ns__BoardInfoArray *)ptr)->soap_out(soap, tag, id, "ns:BoardInfoArray");
	case SOAP_TYPE_ns__DeviceInfo:
		return ((ns__DeviceInfo *)ptr)->soap_out(soap, tag, id, "ns:DeviceInfo");
	case SOAP_TYPE_ns__GetMACAddress:
		return soap_out_ns__GetMACAddress(soap, tag, id, (const struct ns__GetMACAddress *)ptr, "ns:GetMACAddress");
	case SOAP_TYPE_ns__GetMACAddressResponse:
		return soap_out_ns__GetMACAddressResponse(soap, tag, id, (const struct ns__GetMACAddressResponse *)ptr, "ns:GetMACAddressResponse");
	case SOAP_TYPE_ns__GetFreeDiskSpace:
		return soap_out_ns__GetFreeDiskSpace(soap, tag, id, (const struct ns__GetFreeDiskSpace *)ptr, "ns:GetFreeDiskSpace");
	case SOAP_TYPE_ns__SetDeviceSettings:
		return soap_out_ns__SetDeviceSettings(soap, tag, id, (const struct ns__SetDeviceSettings *)ptr, "ns:SetDeviceSettings");
	case SOAP_TYPE_ns__GetAutoSequence:
		return soap_out_ns__GetAutoSequence(soap, tag, id, (const struct ns__GetAutoSequence *)ptr, "ns:GetAutoSequence");
	case SOAP_TYPE_ns__GetAutoSequenceResponse:
		return soap_out_ns__GetAutoSequenceResponse(soap, tag, id, (const struct ns__GetAutoSequenceResponse *)ptr, "ns:GetAutoSequenceResponse");
	case SOAP_TYPE_ns__StopAutoSequence:
		return soap_out_ns__StopAutoSequence(soap, tag, id, (const struct ns__StopAutoSequence *)ptr, "ns:StopAutoSequence");
	case SOAP_TYPE_ns__StopAutoSequenceResponse:
		return soap_out_ns__StopAutoSequenceResponse(soap, tag, id, (const struct ns__StopAutoSequenceResponse *)ptr, "ns:StopAutoSequenceResponse");
	case SOAP_TYPE_ns__StartAutoSequence:
		return soap_out_ns__StartAutoSequence(soap, tag, id, (const struct ns__StartAutoSequence *)ptr, "ns:StartAutoSequence");
	case SOAP_TYPE_ns__StartAutoSequenceResponse:
		return soap_out_ns__StartAutoSequenceResponse(soap, tag, id, (const struct ns__StartAutoSequenceResponse *)ptr, "ns:StartAutoSequenceResponse");
	case SOAP_TYPE_ns__LoadAutosequence:
		return soap_out_ns__LoadAutosequence(soap, tag, id, (const struct ns__LoadAutosequence *)ptr, "ns:LoadAutosequence");
	case SOAP_TYPE_ns__LoadAutosequenceResponse:
		return soap_out_ns__LoadAutosequenceResponse(soap, tag, id, (const struct ns__LoadAutosequenceResponse *)ptr, "ns:LoadAutosequenceResponse");
	case SOAP_TYPE_ns__SendServerCustomCommand:
		return soap_out_ns__SendServerCustomCommand(soap, tag, id, (const struct ns__SendServerCustomCommand *)ptr, "ns:SendServerCustomCommand");
	case SOAP_TYPE_ns__SendServerCustomCommandResponse:
		return soap_out_ns__SendServerCustomCommandResponse(soap, tag, id, (const struct ns__SendServerCustomCommandResponse *)ptr, "ns:SendServerCustomCommandResponse");
	case SOAP_TYPE_ns__DataBlockHeader:
		return soap_out_ns__DataBlockHeader(soap, tag, id, (const struct ns__DataBlockHeader *)ptr, "ns:DataBlockHeader");
	case SOAP_TYPE_ns__GetData:
		return soap_out_ns__GetData(soap, tag, id, (const struct ns__GetData *)ptr, "ns:GetData");
	case SOAP_TYPE_ns__GetDataResponse:
		return soap_out_ns__GetDataResponse(soap, tag, id, (const struct ns__GetDataResponse *)ptr, "ns:GetDataResponse");
	case SOAP_TYPE_ns__GetAllYMetadata:
		return soap_out_ns__GetAllYMetadata(soap, tag, id, (const struct ns__GetAllYMetadata *)ptr, "ns:GetAllYMetadata");
	case SOAP_TYPE_ns__GetAllYMetadataResponse:
		return soap_out_ns__GetAllYMetadataResponse(soap, tag, id, (const struct ns__GetAllYMetadataResponse *)ptr, "ns:GetAllYMetadataResponse");
	case SOAP_TYPE_ns__YMetadata:
		return soap_out_ns__YMetadata(soap, tag, id, (const struct ns__YMetadata *)ptr, "ns:YMetadata");
	case SOAP_TYPE_ns__GetMetadata:
		return soap_out_ns__GetMetadata(soap, tag, id, (const struct ns__GetMetadata *)ptr, "ns:GetMetadata");
	case SOAP_TYPE_ns__GetMetadataResponse:
		return soap_out_ns__GetMetadataResponse(soap, tag, id, (const struct ns__GetMetadataResponse *)ptr, "ns:GetMetadataResponse");
	case SOAP_TYPE_ns__Metadata:
		return soap_out_ns__Metadata(soap, tag, id, (const struct ns__Metadata *)ptr, "ns:Metadata");
	case SOAP_TYPE_ns__LeaveWaitStatus:
		return soap_out_ns__LeaveWaitStatus(soap, tag, id, (const struct ns__LeaveWaitStatus *)ptr, "ns:LeaveWaitStatus");
	case SOAP_TYPE_ns__WaitForStatusChange:
		return soap_out_ns__WaitForStatusChange(soap, tag, id, (const struct ns__WaitForStatusChange *)ptr, "ns:WaitForStatusChange");
	case SOAP_TYPE_ns__GetStatus:
		return soap_out_ns__GetStatus(soap, tag, id, (const struct ns__GetStatus *)ptr, "ns:GetStatus");
	case SOAP_TYPE_ns__Status:
		return soap_out_ns__Status(soap, tag, id, (const struct ns__Status *)ptr, "ns:Status");
	case SOAP_TYPE_ns__DeviceStatus:
		return soap_out_ns__DeviceStatus(soap, tag, id, (const struct ns__DeviceStatus *)ptr, "ns:DeviceStatus");
	case SOAP_TYPE_ns__TempStatus:
		return soap_out_ns__TempStatus(soap, tag, id, (const struct ns__TempStatus *)ptr, "ns:TempStatus");
	case SOAP_TYPE_ns__GPSStatus:
		return soap_out_ns__GPSStatus(soap, tag, id, (const struct ns__GPSStatus *)ptr, "ns:GPSStatus");
	case SOAP_TYPE_ns__BoardStatus:
		return soap_out_ns__BoardStatus(soap, tag, id, (const struct ns__BoardStatus *)ptr, "ns:BoardStatus");
	case SOAP_TYPE_ns__InputStatus:
		return soap_out_ns__InputStatus(soap, tag, id, (const struct ns__InputStatus *)ptr, "ns:InputStatus");
	case SOAP_TYPE_ns__StartCalibration:
		return soap_out_ns__StartCalibration(soap, tag, id, (const struct ns__StartCalibration *)ptr, "ns:StartCalibration");
	case SOAP_TYPE_ns__ExecuteCommand:
		return soap_out_ns__ExecuteCommand(soap, tag, id, (const struct ns__ExecuteCommand *)ptr, "ns:ExecuteCommand");
	case SOAP_TYPE_ns__SetStartInfo:
		return soap_out_ns__SetStartInfo(soap, tag, id, (const struct ns__SetStartInfo *)ptr, "ns:SetStartInfo");
	case SOAP_TYPE_ns__PrepareStart:
		return soap_out_ns__PrepareStart(soap, tag, id, (const struct ns__PrepareStart *)ptr, "ns:PrepareStart");
	case SOAP_TYPE_ns__PrepareStartResponse:
		return soap_out_ns__PrepareStartResponse(soap, tag, id, (const struct ns__PrepareStartResponse *)ptr, "ns:PrepareStartResponse");
	case SOAP_TYPE_ns__ReadWriteTwi:
		return soap_out_ns__ReadWriteTwi(soap, tag, id, (const struct ns__ReadWriteTwi *)ptr, "ns:ReadWriteTwi");
	case SOAP_TYPE_ns__ReadWriteTwiResponse:
		return soap_out_ns__ReadWriteTwiResponse(soap, tag, id, (const struct ns__ReadWriteTwiResponse *)ptr, "ns:ReadWriteTwiResponse");
	case SOAP_TYPE_ns__ReadDev:
		return soap_out_ns__ReadDev(soap, tag, id, (const struct ns__ReadDev *)ptr, "ns:ReadDev");
	case SOAP_TYPE_ns__ReadDevResponse:
		return soap_out_ns__ReadDevResponse(soap, tag, id, (const struct ns__ReadDevResponse *)ptr, "ns:ReadDevResponse");
	case SOAP_TYPE_ns__WriteDev:
		return soap_out_ns__WriteDev(soap, tag, id, (const struct ns__WriteDev *)ptr, "ns:WriteDev");
	case SOAP_TYPE_ns__GetGPSLogList:
		return soap_out_ns__GetGPSLogList(soap, tag, id, (const struct ns__GetGPSLogList *)ptr, "ns:GetGPSLogList");
	case SOAP_TYPE_ns__GetGPSLogListResponse:
		return soap_out_ns__GetGPSLogListResponse(soap, tag, id, (const struct ns__GetGPSLogListResponse *)ptr, "ns:GetGPSLogListResponse");
	case SOAP_TYPE_ns__GPSLogList:
		return soap_out_ns__GPSLogList(soap, tag, id, (const struct ns__GPSLogList *)ptr, "ns:GPSLogList");
	case SOAP_TYPE_ns__GPSLog:
		return soap_out_ns__GPSLog(soap, tag, id, (const struct ns__GPSLog *)ptr, "ns:GPSLog");
	case SOAP_TYPE_ns__SetAssociations:
		return soap_out_ns__SetAssociations(soap, tag, id, (const struct ns__SetAssociations *)ptr, "ns:SetAssociations");
	case SOAP_TYPE_ns__GetAllPreviousAssociations:
		return soap_out_ns__GetAllPreviousAssociations(soap, tag, id, (const struct ns__GetAllPreviousAssociations *)ptr, "ns:GetAllPreviousAssociations");
	case SOAP_TYPE_ns__GetAllPreviousAssociationsResponse:
		return soap_out_ns__GetAllPreviousAssociationsResponse(soap, tag, id, (const struct ns__GetAllPreviousAssociationsResponse *)ptr, "ns:GetAllPreviousAssociationsResponse");
	case SOAP_TYPE_ns__GetAllCurrentAssociations:
		return soap_out_ns__GetAllCurrentAssociations(soap, tag, id, (const struct ns__GetAllCurrentAssociations *)ptr, "ns:GetAllCurrentAssociations");
	case SOAP_TYPE_ns__GetAllCurrentAssociationsResponse:
		return soap_out_ns__GetAllCurrentAssociationsResponse(soap, tag, id, (const struct ns__GetAllCurrentAssociationsResponse *)ptr, "ns:GetAllCurrentAssociationsResponse");
	case SOAP_TYPE_ns__AssociationRowList:
		return soap_out_ns__AssociationRowList(soap, tag, id, (const struct ns__AssociationRowList *)ptr, "ns:AssociationRowList");
	case SOAP_TYPE_ns__AssociationRow:
		return soap_out_ns__AssociationRow(soap, tag, id, (const struct ns__AssociationRow *)ptr, "ns:AssociationRow");
	case SOAP_TYPE_ns__AssociationChannelList:
		return soap_out_ns__AssociationChannelList(soap, tag, id, (const struct ns__AssociationChannelList *)ptr, "ns:AssociationChannelList");
	case SOAP_TYPE_ns__AssociationChannel:
		return soap_out_ns__AssociationChannel(soap, tag, id, (const struct ns__AssociationChannel *)ptr, "ns:AssociationChannel");
	case SOAP_TYPE_ns__GetCANTrigger:
		return soap_out_ns__GetCANTrigger(soap, tag, id, (const struct ns__GetCANTrigger *)ptr, "ns:GetCANTrigger");
	case SOAP_TYPE_ns__SetCANTrigger:
		return soap_out_ns__SetCANTrigger(soap, tag, id, (const struct ns__SetCANTrigger *)ptr, "ns:SetCANTrigger");
	case SOAP_TYPE_ns__GetI2CTrigger:
		return soap_out_ns__GetI2CTrigger(soap, tag, id, (const struct ns__GetI2CTrigger *)ptr, "ns:GetI2CTrigger");
	case SOAP_TYPE_ns__SetI2CTrigger:
		return soap_out_ns__SetI2CTrigger(soap, tag, id, (const struct ns__SetI2CTrigger *)ptr, "ns:SetI2CTrigger");
	case SOAP_TYPE_ns__ResetSerTrg:
		return soap_out_ns__ResetSerTrg(soap, tag, id, (const struct ns__ResetSerTrg *)ptr, "ns:ResetSerTrg");
	case SOAP_TYPE_ns__GetSerTrgProtocol:
		return soap_out_ns__GetSerTrgProtocol(soap, tag, id, (const struct ns__GetSerTrgProtocol *)ptr, "ns:GetSerTrgProtocol");
	case SOAP_TYPE_ns__GetSerTrgProtocolResponse:
		return soap_out_ns__GetSerTrgProtocolResponse(soap, tag, id, (const struct ns__GetSerTrgProtocolResponse *)ptr, "ns:GetSerTrgProtocolResponse");
	case SOAP_TYPE_ns__CANTriggerSettings:
		return soap_out_ns__CANTriggerSettings(soap, tag, id, (const struct ns__CANTriggerSettings *)ptr, "ns:CANTriggerSettings");
	case SOAP_TYPE_ns__I2CTriggerSettings:
		return soap_out_ns__I2CTriggerSettings(soap, tag, id, (const struct ns__I2CTriggerSettings *)ptr, "ns:I2CTriggerSettings");
	case SOAP_TYPE_ns__GetAllPreviousAttributes:
		return soap_out_ns__GetAllPreviousAttributes(soap, tag, id, (const struct ns__GetAllPreviousAttributes *)ptr, "ns:GetAllPreviousAttributes");
	case SOAP_TYPE_ns__GetAllPreviousAttributesResponse:
		return soap_out_ns__GetAllPreviousAttributesResponse(soap, tag, id, (const struct ns__GetAllPreviousAttributesResponse *)ptr, "ns:GetAllPreviousAttributesResponse");
	case SOAP_TYPE_ns__GetAllCurrentAttributes:
		return soap_out_ns__GetAllCurrentAttributes(soap, tag, id, (const struct ns__GetAllCurrentAttributes *)ptr, "ns:GetAllCurrentAttributes");
	case SOAP_TYPE_ns__GetAllCurrentAttributesResponse:
		return soap_out_ns__GetAllCurrentAttributesResponse(soap, tag, id, (const struct ns__GetAllCurrentAttributesResponse *)ptr, "ns:GetAllCurrentAttributesResponse");
	case SOAP_TYPE_ns__SetAttributes:
		return soap_out_ns__SetAttributes(soap, tag, id, (const struct ns__SetAttributes *)ptr, "ns:SetAttributes");
	case SOAP_TYPE_ns__Attribute:
		return soap_out_ns__Attribute(soap, tag, id, (const struct ns__Attribute *)ptr, "ns:Attribute");
	case SOAP_TYPE_ns__GetAllPreviousParameters:
		return soap_out_ns__GetAllPreviousParameters(soap, tag, id, (const struct ns__GetAllPreviousParameters *)ptr, "ns:GetAllPreviousParameters");
	case SOAP_TYPE_ns__GetAllPreviousParametersResponse:
		return soap_out_ns__GetAllPreviousParametersResponse(soap, tag, id, (const struct ns__GetAllPreviousParametersResponse *)ptr, "ns:GetAllPreviousParametersResponse");
	case SOAP_TYPE_ns__GetAllCurrentParameters:
		return soap_out_ns__GetAllCurrentParameters(soap, tag, id, (const struct ns__GetAllCurrentParameters *)ptr, "ns:GetAllCurrentParameters");
	case SOAP_TYPE_ns__GetAllCurrentParametersResponse:
		return soap_out_ns__GetAllCurrentParametersResponse(soap, tag, id, (const struct ns__GetAllCurrentParametersResponse *)ptr, "ns:GetAllCurrentParametersResponse");
	case SOAP_TYPE_ns__SetMultipleParameters:
		return soap_out_ns__SetMultipleParameters(soap, tag, id, (const struct ns__SetMultipleParameters *)ptr, "ns:SetMultipleParameters");
	case SOAP_TYPE_ns__SetMultipleParametersResponse:
		return soap_out_ns__SetMultipleParametersResponse(soap, tag, id, (const struct ns__SetMultipleParametersResponse *)ptr, "ns:SetMultipleParametersResponse");
	case SOAP_TYPE_ns__SetOneParameter:
		return soap_out_ns__SetOneParameter(soap, tag, id, (const struct ns__SetOneParameter *)ptr, "ns:SetOneParameter");
	case SOAP_TYPE_ns__SetOneParameterResult:
		return soap_out_ns__SetOneParameterResult(soap, tag, id, (const struct ns__SetOneParameterResult *)ptr, "ns:SetOneParameterResult");
	case SOAP_TYPE_ns__Parameter:
		return soap_out_ns__Parameter(soap, tag, id, (const struct ns__Parameter *)ptr, "ns:Parameter");
	case SOAP_TYPE_ns__GetHardwareInfo:
		return soap_out_ns__GetHardwareInfo(soap, tag, id, (const struct ns__GetHardwareInfo *)ptr, "ns:GetHardwareInfo");
	case SOAP_TYPE_ns__HardwareInfo:
		return soap_out_ns__HardwareInfo(soap, tag, id, (const struct ns__HardwareInfo *)ptr, "ns:HardwareInfo");
	case SOAP_TYPE_ns__TaggedInputInfo:
		return soap_out_ns__TaggedInputInfo(soap, tag, id, (const struct ns__TaggedInputInfo *)ptr, "ns:TaggedInputInfo");
	case SOAP_TYPE_ns__TaggedBoardInfo:
		return soap_out_ns__TaggedBoardInfo(soap, tag, id, (const struct ns__TaggedBoardInfo *)ptr, "ns:TaggedBoardInfo");
	case SOAP_TYPE_ns__InputInfo:
		return soap_out_ns__InputInfo(soap, tag, id, (const struct ns__InputInfo *)ptr, "ns:InputInfo");
	case SOAP_TYPE_ns__BoardInfo:
		return soap_out_ns__BoardInfo(soap, tag, id, (const struct ns__BoardInfo *)ptr, "ns:BoardInfo");
	case SOAP_TYPE_ns__SetClusterConfiguration:
		return soap_out_ns__SetClusterConfiguration(soap, tag, id, (const struct ns__SetClusterConfiguration *)ptr, "ns:SetClusterConfiguration");
	case SOAP_TYPE_ns__GetClusterConfiguration:
		return soap_out_ns__GetClusterConfiguration(soap, tag, id, (const struct ns__GetClusterConfiguration *)ptr, "ns:GetClusterConfiguration");
	case SOAP_TYPE_ns__ClusterConfiguration:
		return soap_out_ns__ClusterConfiguration(soap, tag, id, (const struct ns__ClusterConfiguration *)ptr, "ns:ClusterConfiguration");
	case SOAP_TYPE_ns__ReleaseDeviceLock:
		return soap_out_ns__ReleaseDeviceLock(soap, tag, id, (const struct ns__ReleaseDeviceLock *)ptr, "ns:ReleaseDeviceLock");
	case SOAP_TYPE_ns__AcquireDeviceLock:
		return soap_out_ns__AcquireDeviceLock(soap, tag, id, (const struct ns__AcquireDeviceLock *)ptr, "ns:AcquireDeviceLock");
	case SOAP_TYPE_ns__ResetConfiguration:
		return soap_out_ns__ResetConfiguration(soap, tag, id, (const struct ns__ResetConfiguration *)ptr, "ns:ResetConfiguration");
	case SOAP_TYPE_ns__GetInterfaceVersion:
		return soap_out_ns__GetInterfaceVersion(soap, tag, id, (const struct ns__GetInterfaceVersion *)ptr, "ns:GetInterfaceVersion");
	case SOAP_TYPE_ns__GetInterfaceVersionResponse:
		return soap_out_ns__GetInterfaceVersionResponse(soap, tag, id, (const struct ns__GetInterfaceVersionResponse *)ptr, "ns:GetInterfaceVersionResponse");
	case SOAP_TYPE_ns__DateTime:
		return soap_out_ns__DateTime(soap, tag, id, (const struct ns__DateTime *)ptr, "ns:DateTime");
	case SOAP_TYPE_ns__DummyResponse:
		return soap_out_ns__DummyResponse(soap, tag, id, (const struct ns__DummyResponse *)ptr, "ns:DummyResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons__DataSpecification:
		return soap_out_PointerToPointerTons__DataSpecification(soap, tag, id, (ns__DataSpecification **const*)ptr, "ns:DataSpecification");
	case SOAP_TYPE_PointerTons__DataSpecification:
		return soap_out_PointerTons__DataSpecification(soap, tag, id, (ns__DataSpecification *const*)ptr, "ns:DataSpecification");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTons__YMetadata:
		return soap_out_PointerTons__YMetadata(soap, tag, id, (struct ns__YMetadata *const*)ptr, "ns:YMetadata");
	case SOAP_TYPE_PointerTons__Metadata:
		return soap_out_PointerTons__Metadata(soap, tag, id, (struct ns__Metadata *const*)ptr, "ns:Metadata");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTons__GPSLog:
		return soap_out_PointerTons__GPSLog(soap, tag, id, (struct ns__GPSLog *const*)ptr, "ns:GPSLog");
	case SOAP_TYPE_PointerTons__AssociationRow:
		return soap_out_PointerTons__AssociationRow(soap, tag, id, (struct ns__AssociationRow *const*)ptr, "ns:AssociationRow");
	case SOAP_TYPE_PointerTons__AssociationChannel:
		return soap_out_PointerTons__AssociationChannel(soap, tag, id, (struct ns__AssociationChannel *const*)ptr, "ns:AssociationChannel");
	case SOAP_TYPE_PointerTons__Attribute:
		return soap_out_PointerTons__Attribute(soap, tag, id, (struct ns__Attribute *const*)ptr, "ns:Attribute");
	case SOAP_TYPE_PointerTons__SetOneParameterResult:
		return soap_out_PointerTons__SetOneParameterResult(soap, tag, id, (struct ns__SetOneParameterResult *const*)ptr, "ns:SetOneParameterResult");
	case SOAP_TYPE_PointerTons__Parameter:
		return soap_out_PointerTons__Parameter(soap, tag, id, (struct ns__Parameter *const*)ptr, "ns:Parameter");
	case SOAP_TYPE_PointerTons__TaggedInputInfo:
		return soap_out_PointerTons__TaggedInputInfo(soap, tag, id, (struct ns__TaggedInputInfo *const*)ptr, "ns:TaggedInputInfo");
	case SOAP_TYPE_PointerTons__TaggedBoardInfo:
		return soap_out_PointerTons__TaggedBoardInfo(soap, tag, id, (struct ns__TaggedBoardInfo *const*)ptr, "ns:TaggedBoardInfo");
	case SOAP_TYPE_PointerTons__DummyResponse:
		return soap_out_PointerTons__DummyResponse(soap, tag, id, (struct ns__DummyResponse *const*)ptr, "ns:DummyResponse");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	case SOAP_TYPE_Array16Ofns__BoardStatus:
		return soap_out_Array16Ofns__BoardStatus(soap, tag, id, (struct ns__BoardStatus (*))ptr, "ns:BoardStatus");
	case SOAP_TYPE_Array8Ofns__InputStatus:
		return soap_out_Array8Ofns__InputStatus(soap, tag, id, (struct ns__InputStatus (*))ptr, "ns:InputStatus");
	case SOAP_TYPE_Array128Ofbyte:
		return soap_out_Array128Ofbyte(soap, tag, id, (char (*))ptr, "xsd:byte");
	case SOAP_TYPE_Array8Ofbyte:
		return soap_out_Array8Ofbyte(soap, tag, id, (char (*))ptr, "xsd:byte");
	case SOAP_TYPE_Array16Ofbyte:
		return soap_out_Array16Ofbyte(soap, tag, id, (char (*))ptr, "xsd:byte");
	case SOAP_TYPE_Array12Ofint:
		return soap_out_Array12Ofint(soap, tag, id, (int (*))ptr, "xsd:int");
	case SOAP_TYPE_Array11Ofdouble:
		return soap_out_Array11Ofdouble(soap, tag, id, (double (*))ptr, "xsd:double");
	case SOAP_TYPE_Array16Ofint:
		return soap_out_Array16Ofint(soap, tag, id, (int (*))ptr, "xsd:int");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__DiskSpace:
		((ns__DiskSpace *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__AutoSequence:
		((ns__AutoSequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Data:
		((ns__Data *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DataSpecificationArray:
		((ns__DataSpecificationArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__EnvelopeDataSpecification:
		((ns__EnvelopeDataSpecification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__IndexList:
		((ns__IndexList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__RangeDataSpecification:
		((ns__RangeDataSpecification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DataSpecification:
		((ns__DataSpecification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__YMetadataList:
		((ns__YMetadataList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__MetadataList:
		((ns__MetadataList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceData:
		((ns__DeviceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__AttributeList:
		((ns__AttributeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__SetParameterResultList:
		((ns__SetParameterResultList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ParameterList:
		((ns__ParameterList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__InputInfoArray:
		((ns__InputInfoArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__BoardInfoArray:
		((ns__BoardInfoArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceInfo:
		((ns__DeviceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__GetMACAddress:
		soap_serialize_ns__GetMACAddress(soap, (const struct ns__GetMACAddress *)ptr);
		break;
	case SOAP_TYPE_ns__GetMACAddressResponse:
		soap_serialize_ns__GetMACAddressResponse(soap, (const struct ns__GetMACAddressResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GetFreeDiskSpace:
		soap_serialize_ns__GetFreeDiskSpace(soap, (const struct ns__GetFreeDiskSpace *)ptr);
		break;
	case SOAP_TYPE_ns__SetDeviceSettings:
		soap_serialize_ns__SetDeviceSettings(soap, (const struct ns__SetDeviceSettings *)ptr);
		break;
	case SOAP_TYPE_ns__GetAutoSequence:
		soap_serialize_ns__GetAutoSequence(soap, (const struct ns__GetAutoSequence *)ptr);
		break;
	case SOAP_TYPE_ns__GetAutoSequenceResponse:
		soap_serialize_ns__GetAutoSequenceResponse(soap, (const struct ns__GetAutoSequenceResponse *)ptr);
		break;
	case SOAP_TYPE_ns__StopAutoSequence:
		soap_serialize_ns__StopAutoSequence(soap, (const struct ns__StopAutoSequence *)ptr);
		break;
	case SOAP_TYPE_ns__StopAutoSequenceResponse:
		soap_serialize_ns__StopAutoSequenceResponse(soap, (const struct ns__StopAutoSequenceResponse *)ptr);
		break;
	case SOAP_TYPE_ns__StartAutoSequence:
		soap_serialize_ns__StartAutoSequence(soap, (const struct ns__StartAutoSequence *)ptr);
		break;
	case SOAP_TYPE_ns__StartAutoSequenceResponse:
		soap_serialize_ns__StartAutoSequenceResponse(soap, (const struct ns__StartAutoSequenceResponse *)ptr);
		break;
	case SOAP_TYPE_ns__LoadAutosequence:
		soap_serialize_ns__LoadAutosequence(soap, (const struct ns__LoadAutosequence *)ptr);
		break;
	case SOAP_TYPE_ns__LoadAutosequenceResponse:
		soap_serialize_ns__LoadAutosequenceResponse(soap, (const struct ns__LoadAutosequenceResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SendServerCustomCommand:
		soap_serialize_ns__SendServerCustomCommand(soap, (const struct ns__SendServerCustomCommand *)ptr);
		break;
	case SOAP_TYPE_ns__SendServerCustomCommandResponse:
		soap_serialize_ns__SendServerCustomCommandResponse(soap, (const struct ns__SendServerCustomCommandResponse *)ptr);
		break;
	case SOAP_TYPE_ns__DataBlockHeader:
		soap_serialize_ns__DataBlockHeader(soap, (const struct ns__DataBlockHeader *)ptr);
		break;
	case SOAP_TYPE_ns__GetData:
		soap_serialize_ns__GetData(soap, (const struct ns__GetData *)ptr);
		break;
	case SOAP_TYPE_ns__GetDataResponse:
		soap_serialize_ns__GetDataResponse(soap, (const struct ns__GetDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllYMetadata:
		soap_serialize_ns__GetAllYMetadata(soap, (const struct ns__GetAllYMetadata *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllYMetadataResponse:
		soap_serialize_ns__GetAllYMetadataResponse(soap, (const struct ns__GetAllYMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__YMetadata:
		soap_serialize_ns__YMetadata(soap, (const struct ns__YMetadata *)ptr);
		break;
	case SOAP_TYPE_ns__GetMetadata:
		soap_serialize_ns__GetMetadata(soap, (const struct ns__GetMetadata *)ptr);
		break;
	case SOAP_TYPE_ns__GetMetadataResponse:
		soap_serialize_ns__GetMetadataResponse(soap, (const struct ns__GetMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__Metadata:
		soap_serialize_ns__Metadata(soap, (const struct ns__Metadata *)ptr);
		break;
	case SOAP_TYPE_ns__LeaveWaitStatus:
		soap_serialize_ns__LeaveWaitStatus(soap, (const struct ns__LeaveWaitStatus *)ptr);
		break;
	case SOAP_TYPE_ns__WaitForStatusChange:
		soap_serialize_ns__WaitForStatusChange(soap, (const struct ns__WaitForStatusChange *)ptr);
		break;
	case SOAP_TYPE_ns__GetStatus:
		soap_serialize_ns__GetStatus(soap, (const struct ns__GetStatus *)ptr);
		break;
	case SOAP_TYPE_ns__Status:
		soap_serialize_ns__Status(soap, (const struct ns__Status *)ptr);
		break;
	case SOAP_TYPE_ns__DeviceStatus:
		soap_serialize_ns__DeviceStatus(soap, (const struct ns__DeviceStatus *)ptr);
		break;
	case SOAP_TYPE_ns__TempStatus:
		soap_serialize_ns__TempStatus(soap, (const struct ns__TempStatus *)ptr);
		break;
	case SOAP_TYPE_ns__GPSStatus:
		soap_serialize_ns__GPSStatus(soap, (const struct ns__GPSStatus *)ptr);
		break;
	case SOAP_TYPE_ns__BoardStatus:
		soap_serialize_ns__BoardStatus(soap, (const struct ns__BoardStatus *)ptr);
		break;
	case SOAP_TYPE_ns__InputStatus:
		soap_serialize_ns__InputStatus(soap, (const struct ns__InputStatus *)ptr);
		break;
	case SOAP_TYPE_ns__StartCalibration:
		soap_serialize_ns__StartCalibration(soap, (const struct ns__StartCalibration *)ptr);
		break;
	case SOAP_TYPE_ns__ExecuteCommand:
		soap_serialize_ns__ExecuteCommand(soap, (const struct ns__ExecuteCommand *)ptr);
		break;
	case SOAP_TYPE_ns__SetStartInfo:
		soap_serialize_ns__SetStartInfo(soap, (const struct ns__SetStartInfo *)ptr);
		break;
	case SOAP_TYPE_ns__PrepareStart:
		soap_serialize_ns__PrepareStart(soap, (const struct ns__PrepareStart *)ptr);
		break;
	case SOAP_TYPE_ns__PrepareStartResponse:
		soap_serialize_ns__PrepareStartResponse(soap, (const struct ns__PrepareStartResponse *)ptr);
		break;
	case SOAP_TYPE_ns__ReadWriteTwi:
		soap_serialize_ns__ReadWriteTwi(soap, (const struct ns__ReadWriteTwi *)ptr);
		break;
	case SOAP_TYPE_ns__ReadWriteTwiResponse:
		soap_serialize_ns__ReadWriteTwiResponse(soap, (const struct ns__ReadWriteTwiResponse *)ptr);
		break;
	case SOAP_TYPE_ns__ReadDev:
		soap_serialize_ns__ReadDev(soap, (const struct ns__ReadDev *)ptr);
		break;
	case SOAP_TYPE_ns__ReadDevResponse:
		soap_serialize_ns__ReadDevResponse(soap, (const struct ns__ReadDevResponse *)ptr);
		break;
	case SOAP_TYPE_ns__WriteDev:
		soap_serialize_ns__WriteDev(soap, (const struct ns__WriteDev *)ptr);
		break;
	case SOAP_TYPE_ns__GetGPSLogList:
		soap_serialize_ns__GetGPSLogList(soap, (const struct ns__GetGPSLogList *)ptr);
		break;
	case SOAP_TYPE_ns__GetGPSLogListResponse:
		soap_serialize_ns__GetGPSLogListResponse(soap, (const struct ns__GetGPSLogListResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GPSLogList:
		soap_serialize_ns__GPSLogList(soap, (const struct ns__GPSLogList *)ptr);
		break;
	case SOAP_TYPE_ns__GPSLog:
		soap_serialize_ns__GPSLog(soap, (const struct ns__GPSLog *)ptr);
		break;
	case SOAP_TYPE_ns__SetAssociations:
		soap_serialize_ns__SetAssociations(soap, (const struct ns__SetAssociations *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllPreviousAssociations:
		soap_serialize_ns__GetAllPreviousAssociations(soap, (const struct ns__GetAllPreviousAssociations *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllPreviousAssociationsResponse:
		soap_serialize_ns__GetAllPreviousAssociationsResponse(soap, (const struct ns__GetAllPreviousAssociationsResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllCurrentAssociations:
		soap_serialize_ns__GetAllCurrentAssociations(soap, (const struct ns__GetAllCurrentAssociations *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllCurrentAssociationsResponse:
		soap_serialize_ns__GetAllCurrentAssociationsResponse(soap, (const struct ns__GetAllCurrentAssociationsResponse *)ptr);
		break;
	case SOAP_TYPE_ns__AssociationRowList:
		soap_serialize_ns__AssociationRowList(soap, (const struct ns__AssociationRowList *)ptr);
		break;
	case SOAP_TYPE_ns__AssociationRow:
		soap_serialize_ns__AssociationRow(soap, (const struct ns__AssociationRow *)ptr);
		break;
	case SOAP_TYPE_ns__AssociationChannelList:
		soap_serialize_ns__AssociationChannelList(soap, (const struct ns__AssociationChannelList *)ptr);
		break;
	case SOAP_TYPE_ns__AssociationChannel:
		soap_serialize_ns__AssociationChannel(soap, (const struct ns__AssociationChannel *)ptr);
		break;
	case SOAP_TYPE_ns__GetCANTrigger:
		soap_serialize_ns__GetCANTrigger(soap, (const struct ns__GetCANTrigger *)ptr);
		break;
	case SOAP_TYPE_ns__SetCANTrigger:
		soap_serialize_ns__SetCANTrigger(soap, (const struct ns__SetCANTrigger *)ptr);
		break;
	case SOAP_TYPE_ns__GetI2CTrigger:
		soap_serialize_ns__GetI2CTrigger(soap, (const struct ns__GetI2CTrigger *)ptr);
		break;
	case SOAP_TYPE_ns__SetI2CTrigger:
		soap_serialize_ns__SetI2CTrigger(soap, (const struct ns__SetI2CTrigger *)ptr);
		break;
	case SOAP_TYPE_ns__ResetSerTrg:
		soap_serialize_ns__ResetSerTrg(soap, (const struct ns__ResetSerTrg *)ptr);
		break;
	case SOAP_TYPE_ns__GetSerTrgProtocol:
		soap_serialize_ns__GetSerTrgProtocol(soap, (const struct ns__GetSerTrgProtocol *)ptr);
		break;
	case SOAP_TYPE_ns__GetSerTrgProtocolResponse:
		soap_serialize_ns__GetSerTrgProtocolResponse(soap, (const struct ns__GetSerTrgProtocolResponse *)ptr);
		break;
	case SOAP_TYPE_ns__CANTriggerSettings:
		soap_serialize_ns__CANTriggerSettings(soap, (const struct ns__CANTriggerSettings *)ptr);
		break;
	case SOAP_TYPE_ns__I2CTriggerSettings:
		soap_serialize_ns__I2CTriggerSettings(soap, (const struct ns__I2CTriggerSettings *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllPreviousAttributes:
		soap_serialize_ns__GetAllPreviousAttributes(soap, (const struct ns__GetAllPreviousAttributes *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllPreviousAttributesResponse:
		soap_serialize_ns__GetAllPreviousAttributesResponse(soap, (const struct ns__GetAllPreviousAttributesResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllCurrentAttributes:
		soap_serialize_ns__GetAllCurrentAttributes(soap, (const struct ns__GetAllCurrentAttributes *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllCurrentAttributesResponse:
		soap_serialize_ns__GetAllCurrentAttributesResponse(soap, (const struct ns__GetAllCurrentAttributesResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SetAttributes:
		soap_serialize_ns__SetAttributes(soap, (const struct ns__SetAttributes *)ptr);
		break;
	case SOAP_TYPE_ns__Attribute:
		soap_serialize_ns__Attribute(soap, (const struct ns__Attribute *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllPreviousParameters:
		soap_serialize_ns__GetAllPreviousParameters(soap, (const struct ns__GetAllPreviousParameters *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllPreviousParametersResponse:
		soap_serialize_ns__GetAllPreviousParametersResponse(soap, (const struct ns__GetAllPreviousParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllCurrentParameters:
		soap_serialize_ns__GetAllCurrentParameters(soap, (const struct ns__GetAllCurrentParameters *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllCurrentParametersResponse:
		soap_serialize_ns__GetAllCurrentParametersResponse(soap, (const struct ns__GetAllCurrentParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SetMultipleParameters:
		soap_serialize_ns__SetMultipleParameters(soap, (const struct ns__SetMultipleParameters *)ptr);
		break;
	case SOAP_TYPE_ns__SetMultipleParametersResponse:
		soap_serialize_ns__SetMultipleParametersResponse(soap, (const struct ns__SetMultipleParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SetOneParameter:
		soap_serialize_ns__SetOneParameter(soap, (const struct ns__SetOneParameter *)ptr);
		break;
	case SOAP_TYPE_ns__SetOneParameterResult:
		soap_serialize_ns__SetOneParameterResult(soap, (const struct ns__SetOneParameterResult *)ptr);
		break;
	case SOAP_TYPE_ns__Parameter:
		soap_serialize_ns__Parameter(soap, (const struct ns__Parameter *)ptr);
		break;
	case SOAP_TYPE_ns__GetHardwareInfo:
		soap_serialize_ns__GetHardwareInfo(soap, (const struct ns__GetHardwareInfo *)ptr);
		break;
	case SOAP_TYPE_ns__HardwareInfo:
		soap_serialize_ns__HardwareInfo(soap, (const struct ns__HardwareInfo *)ptr);
		break;
	case SOAP_TYPE_ns__TaggedInputInfo:
		soap_serialize_ns__TaggedInputInfo(soap, (const struct ns__TaggedInputInfo *)ptr);
		break;
	case SOAP_TYPE_ns__TaggedBoardInfo:
		soap_serialize_ns__TaggedBoardInfo(soap, (const struct ns__TaggedBoardInfo *)ptr);
		break;
	case SOAP_TYPE_ns__InputInfo:
		soap_serialize_ns__InputInfo(soap, (const struct ns__InputInfo *)ptr);
		break;
	case SOAP_TYPE_ns__BoardInfo:
		soap_serialize_ns__BoardInfo(soap, (const struct ns__BoardInfo *)ptr);
		break;
	case SOAP_TYPE_ns__SetClusterConfiguration:
		soap_serialize_ns__SetClusterConfiguration(soap, (const struct ns__SetClusterConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns__GetClusterConfiguration:
		soap_serialize_ns__GetClusterConfiguration(soap, (const struct ns__GetClusterConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns__ClusterConfiguration:
		soap_serialize_ns__ClusterConfiguration(soap, (const struct ns__ClusterConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns__ReleaseDeviceLock:
		soap_serialize_ns__ReleaseDeviceLock(soap, (const struct ns__ReleaseDeviceLock *)ptr);
		break;
	case SOAP_TYPE_ns__AcquireDeviceLock:
		soap_serialize_ns__AcquireDeviceLock(soap, (const struct ns__AcquireDeviceLock *)ptr);
		break;
	case SOAP_TYPE_ns__ResetConfiguration:
		soap_serialize_ns__ResetConfiguration(soap, (const struct ns__ResetConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns__GetInterfaceVersion:
		soap_serialize_ns__GetInterfaceVersion(soap, (const struct ns__GetInterfaceVersion *)ptr);
		break;
	case SOAP_TYPE_ns__GetInterfaceVersionResponse:
		soap_serialize_ns__GetInterfaceVersionResponse(soap, (const struct ns__GetInterfaceVersionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__DateTime:
		soap_serialize_ns__DateTime(soap, (const struct ns__DateTime *)ptr);
		break;
	case SOAP_TYPE_ns__DummyResponse:
		soap_serialize_ns__DummyResponse(soap, (const struct ns__DummyResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons__DataSpecification:
		soap_serialize_PointerToPointerTons__DataSpecification(soap, (ns__DataSpecification **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__DataSpecification:
		soap_serialize_PointerTons__DataSpecification(soap, (ns__DataSpecification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__YMetadata:
		soap_serialize_PointerTons__YMetadata(soap, (struct ns__YMetadata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Metadata:
		soap_serialize_PointerTons__Metadata(soap, (struct ns__Metadata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__GPSLog:
		soap_serialize_PointerTons__GPSLog(soap, (struct ns__GPSLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__AssociationRow:
		soap_serialize_PointerTons__AssociationRow(soap, (struct ns__AssociationRow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__AssociationChannel:
		soap_serialize_PointerTons__AssociationChannel(soap, (struct ns__AssociationChannel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Attribute:
		soap_serialize_PointerTons__Attribute(soap, (struct ns__Attribute *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__SetOneParameterResult:
		soap_serialize_PointerTons__SetOneParameterResult(soap, (struct ns__SetOneParameterResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Parameter:
		soap_serialize_PointerTons__Parameter(soap, (struct ns__Parameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__TaggedInputInfo:
		soap_serialize_PointerTons__TaggedInputInfo(soap, (struct ns__TaggedInputInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__TaggedBoardInfo:
		soap_serialize_PointerTons__TaggedBoardInfo(soap, (struct ns__TaggedBoardInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__DummyResponse:
		soap_serialize_PointerTons__DummyResponse(soap, (struct ns__DummyResponse *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_Array16Ofns__BoardStatus:
		soap_serialize_Array16Ofns__BoardStatus(soap, (struct ns__BoardStatus (*))ptr);
		break;
	case SOAP_TYPE_Array8Ofns__InputStatus:
		soap_serialize_Array8Ofns__InputStatus(soap, (struct ns__InputStatus (*))ptr);
		break;
	case SOAP_TYPE_Array128Ofbyte:
		soap_serialize_Array128Ofbyte(soap, (char (*))ptr);
		break;
	case SOAP_TYPE_Array8Ofbyte:
		soap_serialize_Array8Ofbyte(soap, (char (*))ptr);
		break;
	case SOAP_TYPE_Array16Ofbyte:
		soap_serialize_Array16Ofbyte(soap, (char (*))ptr);
		break;
	case SOAP_TYPE_Array12Ofint:
		soap_serialize_Array12Ofint(soap, (int (*))ptr);
		break;
	case SOAP_TYPE_Array11Ofdouble:
		soap_serialize_Array11Ofdouble(soap, (double (*))ptr);
		break;
	case SOAP_TYPE_Array16Ofint:
		soap_serialize_Array16Ofint(soap, (int (*))ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns__DummyResponse:
		return (void*)soap_instantiate_ns__DummyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DateTime:
		return (void*)soap_instantiate_ns__DateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetInterfaceVersionResponse:
		return (void*)soap_instantiate_ns__GetInterfaceVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetInterfaceVersion:
		return (void*)soap_instantiate_ns__GetInterfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ResetConfiguration:
		return (void*)soap_instantiate_ns__ResetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AcquireDeviceLock:
		return (void*)soap_instantiate_ns__AcquireDeviceLock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ReleaseDeviceLock:
		return (void*)soap_instantiate_ns__ReleaseDeviceLock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ClusterConfiguration:
		return (void*)soap_instantiate_ns__ClusterConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetClusterConfiguration:
		return (void*)soap_instantiate_ns__GetClusterConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetClusterConfiguration:
		return (void*)soap_instantiate_ns__SetClusterConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceInfo:
		return (void*)soap_instantiate_ns__DeviceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__BoardInfo:
		return (void*)soap_instantiate_ns__BoardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__InputInfo:
		return (void*)soap_instantiate_ns__InputInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__TaggedBoardInfo:
		return (void*)soap_instantiate_ns__TaggedBoardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__TaggedInputInfo:
		return (void*)soap_instantiate_ns__TaggedInputInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__BoardInfoArray:
		return (void*)soap_instantiate_ns__BoardInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__InputInfoArray:
		return (void*)soap_instantiate_ns__InputInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__HardwareInfo:
		return (void*)soap_instantiate_ns__HardwareInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetHardwareInfo:
		return (void*)soap_instantiate_ns__GetHardwareInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Parameter:
		return (void*)soap_instantiate_ns__Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ParameterList:
		return (void*)soap_instantiate_ns__ParameterList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetOneParameterResult:
		return (void*)soap_instantiate_ns__SetOneParameterResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetParameterResultList:
		return (void*)soap_instantiate_ns__SetParameterResultList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetOneParameter:
		return (void*)soap_instantiate_ns__SetOneParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetMultipleParametersResponse:
		return (void*)soap_instantiate_ns__SetMultipleParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetMultipleParameters:
		return (void*)soap_instantiate_ns__SetMultipleParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllCurrentParametersResponse:
		return (void*)soap_instantiate_ns__GetAllCurrentParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllCurrentParameters:
		return (void*)soap_instantiate_ns__GetAllCurrentParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllPreviousParametersResponse:
		return (void*)soap_instantiate_ns__GetAllPreviousParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllPreviousParameters:
		return (void*)soap_instantiate_ns__GetAllPreviousParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Attribute:
		return (void*)soap_instantiate_ns__Attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AttributeList:
		return (void*)soap_instantiate_ns__AttributeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetAttributes:
		return (void*)soap_instantiate_ns__SetAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllCurrentAttributesResponse:
		return (void*)soap_instantiate_ns__GetAllCurrentAttributesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllCurrentAttributes:
		return (void*)soap_instantiate_ns__GetAllCurrentAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllPreviousAttributesResponse:
		return (void*)soap_instantiate_ns__GetAllPreviousAttributesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllPreviousAttributes:
		return (void*)soap_instantiate_ns__GetAllPreviousAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__I2CTriggerSettings:
		return (void*)soap_instantiate_ns__I2CTriggerSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__CANTriggerSettings:
		return (void*)soap_instantiate_ns__CANTriggerSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetSerTrgProtocolResponse:
		return (void*)soap_instantiate_ns__GetSerTrgProtocolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetSerTrgProtocol:
		return (void*)soap_instantiate_ns__GetSerTrgProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ResetSerTrg:
		return (void*)soap_instantiate_ns__ResetSerTrg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetI2CTrigger:
		return (void*)soap_instantiate_ns__SetI2CTrigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetI2CTrigger:
		return (void*)soap_instantiate_ns__GetI2CTrigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetCANTrigger:
		return (void*)soap_instantiate_ns__SetCANTrigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetCANTrigger:
		return (void*)soap_instantiate_ns__GetCANTrigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AssociationChannel:
		return (void*)soap_instantiate_ns__AssociationChannel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AssociationChannelList:
		return (void*)soap_instantiate_ns__AssociationChannelList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AssociationRow:
		return (void*)soap_instantiate_ns__AssociationRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AssociationRowList:
		return (void*)soap_instantiate_ns__AssociationRowList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllCurrentAssociationsResponse:
		return (void*)soap_instantiate_ns__GetAllCurrentAssociationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllCurrentAssociations:
		return (void*)soap_instantiate_ns__GetAllCurrentAssociations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllPreviousAssociationsResponse:
		return (void*)soap_instantiate_ns__GetAllPreviousAssociationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllPreviousAssociations:
		return (void*)soap_instantiate_ns__GetAllPreviousAssociations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetAssociations:
		return (void*)soap_instantiate_ns__SetAssociations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GPSLog:
		return (void*)soap_instantiate_ns__GPSLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GPSLogList:
		return (void*)soap_instantiate_ns__GPSLogList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetGPSLogListResponse:
		return (void*)soap_instantiate_ns__GetGPSLogListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetGPSLogList:
		return (void*)soap_instantiate_ns__GetGPSLogList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceData:
		return (void*)soap_instantiate_ns__DeviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__WriteDev:
		return (void*)soap_instantiate_ns__WriteDev(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ReadDevResponse:
		return (void*)soap_instantiate_ns__ReadDevResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ReadDev:
		return (void*)soap_instantiate_ns__ReadDev(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ReadWriteTwiResponse:
		return (void*)soap_instantiate_ns__ReadWriteTwiResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ReadWriteTwi:
		return (void*)soap_instantiate_ns__ReadWriteTwi(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__PrepareStartResponse:
		return (void*)soap_instantiate_ns__PrepareStartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__PrepareStart:
		return (void*)soap_instantiate_ns__PrepareStart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetStartInfo:
		return (void*)soap_instantiate_ns__SetStartInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ExecuteCommand:
		return (void*)soap_instantiate_ns__ExecuteCommand(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__StartCalibration:
		return (void*)soap_instantiate_ns__StartCalibration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__InputStatus:
		return (void*)soap_instantiate_ns__InputStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__BoardStatus:
		return (void*)soap_instantiate_ns__BoardStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GPSStatus:
		return (void*)soap_instantiate_ns__GPSStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__TempStatus:
		return (void*)soap_instantiate_ns__TempStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatus:
		return (void*)soap_instantiate_ns__DeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Status:
		return (void*)soap_instantiate_ns__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetStatus:
		return (void*)soap_instantiate_ns__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__WaitForStatusChange:
		return (void*)soap_instantiate_ns__WaitForStatusChange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__LeaveWaitStatus:
		return (void*)soap_instantiate_ns__LeaveWaitStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Metadata:
		return (void*)soap_instantiate_ns__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__MetadataList:
		return (void*)soap_instantiate_ns__MetadataList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetMetadataResponse:
		return (void*)soap_instantiate_ns__GetMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetMetadata:
		return (void*)soap_instantiate_ns__GetMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__YMetadata:
		return (void*)soap_instantiate_ns__YMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__YMetadataList:
		return (void*)soap_instantiate_ns__YMetadataList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllYMetadataResponse:
		return (void*)soap_instantiate_ns__GetAllYMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllYMetadata:
		return (void*)soap_instantiate_ns__GetAllYMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DataSpecification:
		return (void*)soap_instantiate_ns__DataSpecification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__RangeDataSpecification:
		return (void*)soap_instantiate_ns__RangeDataSpecification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__IndexList:
		return (void*)soap_instantiate_ns__IndexList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__EnvelopeDataSpecification:
		return (void*)soap_instantiate_ns__EnvelopeDataSpecification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DataSpecificationArray:
		return (void*)soap_instantiate_ns__DataSpecificationArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Data:
		return (void*)soap_instantiate_ns__Data(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDataResponse:
		return (void*)soap_instantiate_ns__GetDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetData:
		return (void*)soap_instantiate_ns__GetData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DataBlockHeader:
		return (void*)soap_instantiate_ns__DataBlockHeader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SendServerCustomCommandResponse:
		return (void*)soap_instantiate_ns__SendServerCustomCommandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SendServerCustomCommand:
		return (void*)soap_instantiate_ns__SendServerCustomCommand(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AutoSequence:
		return (void*)soap_instantiate_ns__AutoSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__LoadAutosequenceResponse:
		return (void*)soap_instantiate_ns__LoadAutosequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__LoadAutosequence:
		return (void*)soap_instantiate_ns__LoadAutosequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__StartAutoSequenceResponse:
		return (void*)soap_instantiate_ns__StartAutoSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__StartAutoSequence:
		return (void*)soap_instantiate_ns__StartAutoSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__StopAutoSequenceResponse:
		return (void*)soap_instantiate_ns__StopAutoSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__StopAutoSequence:
		return (void*)soap_instantiate_ns__StopAutoSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAutoSequenceResponse:
		return (void*)soap_instantiate_ns__GetAutoSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAutoSequence:
		return (void*)soap_instantiate_ns__GetAutoSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetDeviceSettings:
		return (void*)soap_instantiate_ns__SetDeviceSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DiskSpace:
		return (void*)soap_instantiate_ns__DiskSpace(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetFreeDiskSpace:
		return (void*)soap_instantiate_ns__GetFreeDiskSpace(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetMACAddressResponse:
		return (void*)soap_instantiate_ns__GetMACAddressResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetMACAddress:
		return (void*)soap_instantiate_ns__GetMACAddress(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns__DummyResponse:
		if (p->size < 0)
			delete (struct ns__DummyResponse*)p->ptr;
		else
			delete[] (struct ns__DummyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__DateTime:
		if (p->size < 0)
			delete (struct ns__DateTime*)p->ptr;
		else
			delete[] (struct ns__DateTime*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetInterfaceVersionResponse:
		if (p->size < 0)
			delete (struct ns__GetInterfaceVersionResponse*)p->ptr;
		else
			delete[] (struct ns__GetInterfaceVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetInterfaceVersion:
		if (p->size < 0)
			delete (struct ns__GetInterfaceVersion*)p->ptr;
		else
			delete[] (struct ns__GetInterfaceVersion*)p->ptr;
		break;
	case SOAP_TYPE_ns__ResetConfiguration:
		if (p->size < 0)
			delete (struct ns__ResetConfiguration*)p->ptr;
		else
			delete[] (struct ns__ResetConfiguration*)p->ptr;
		break;
	case SOAP_TYPE_ns__AcquireDeviceLock:
		if (p->size < 0)
			delete (struct ns__AcquireDeviceLock*)p->ptr;
		else
			delete[] (struct ns__AcquireDeviceLock*)p->ptr;
		break;
	case SOAP_TYPE_ns__ReleaseDeviceLock:
		if (p->size < 0)
			delete (struct ns__ReleaseDeviceLock*)p->ptr;
		else
			delete[] (struct ns__ReleaseDeviceLock*)p->ptr;
		break;
	case SOAP_TYPE_ns__ClusterConfiguration:
		if (p->size < 0)
			delete (struct ns__ClusterConfiguration*)p->ptr;
		else
			delete[] (struct ns__ClusterConfiguration*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetClusterConfiguration:
		if (p->size < 0)
			delete (struct ns__GetClusterConfiguration*)p->ptr;
		else
			delete[] (struct ns__GetClusterConfiguration*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetClusterConfiguration:
		if (p->size < 0)
			delete (struct ns__SetClusterConfiguration*)p->ptr;
		else
			delete[] (struct ns__SetClusterConfiguration*)p->ptr;
		break;
	case SOAP_TYPE_ns__DeviceInfo:
		if (p->size < 0)
			delete (ns__DeviceInfo*)p->ptr;
		else
			delete[] (ns__DeviceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__BoardInfo:
		if (p->size < 0)
			delete (struct ns__BoardInfo*)p->ptr;
		else
			delete[] (struct ns__BoardInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__InputInfo:
		if (p->size < 0)
			delete (struct ns__InputInfo*)p->ptr;
		else
			delete[] (struct ns__InputInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__TaggedBoardInfo:
		if (p->size < 0)
			delete (struct ns__TaggedBoardInfo*)p->ptr;
		else
			delete[] (struct ns__TaggedBoardInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__TaggedInputInfo:
		if (p->size < 0)
			delete (struct ns__TaggedInputInfo*)p->ptr;
		else
			delete[] (struct ns__TaggedInputInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__BoardInfoArray:
		if (p->size < 0)
			delete (ns__BoardInfoArray*)p->ptr;
		else
			delete[] (ns__BoardInfoArray*)p->ptr;
		break;
	case SOAP_TYPE_ns__InputInfoArray:
		if (p->size < 0)
			delete (ns__InputInfoArray*)p->ptr;
		else
			delete[] (ns__InputInfoArray*)p->ptr;
		break;
	case SOAP_TYPE_ns__HardwareInfo:
		if (p->size < 0)
			delete (struct ns__HardwareInfo*)p->ptr;
		else
			delete[] (struct ns__HardwareInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetHardwareInfo:
		if (p->size < 0)
			delete (struct ns__GetHardwareInfo*)p->ptr;
		else
			delete[] (struct ns__GetHardwareInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__Parameter:
		if (p->size < 0)
			delete (struct ns__Parameter*)p->ptr;
		else
			delete[] (struct ns__Parameter*)p->ptr;
		break;
	case SOAP_TYPE_ns__ParameterList:
		if (p->size < 0)
			delete (ns__ParameterList*)p->ptr;
		else
			delete[] (ns__ParameterList*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetOneParameterResult:
		if (p->size < 0)
			delete (struct ns__SetOneParameterResult*)p->ptr;
		else
			delete[] (struct ns__SetOneParameterResult*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetParameterResultList:
		if (p->size < 0)
			delete (ns__SetParameterResultList*)p->ptr;
		else
			delete[] (ns__SetParameterResultList*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetOneParameter:
		if (p->size < 0)
			delete (struct ns__SetOneParameter*)p->ptr;
		else
			delete[] (struct ns__SetOneParameter*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetMultipleParametersResponse:
		if (p->size < 0)
			delete (struct ns__SetMultipleParametersResponse*)p->ptr;
		else
			delete[] (struct ns__SetMultipleParametersResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetMultipleParameters:
		if (p->size < 0)
			delete (struct ns__SetMultipleParameters*)p->ptr;
		else
			delete[] (struct ns__SetMultipleParameters*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllCurrentParametersResponse:
		if (p->size < 0)
			delete (struct ns__GetAllCurrentParametersResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllCurrentParametersResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllCurrentParameters:
		if (p->size < 0)
			delete (struct ns__GetAllCurrentParameters*)p->ptr;
		else
			delete[] (struct ns__GetAllCurrentParameters*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllPreviousParametersResponse:
		if (p->size < 0)
			delete (struct ns__GetAllPreviousParametersResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllPreviousParametersResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllPreviousParameters:
		if (p->size < 0)
			delete (struct ns__GetAllPreviousParameters*)p->ptr;
		else
			delete[] (struct ns__GetAllPreviousParameters*)p->ptr;
		break;
	case SOAP_TYPE_ns__Attribute:
		if (p->size < 0)
			delete (struct ns__Attribute*)p->ptr;
		else
			delete[] (struct ns__Attribute*)p->ptr;
		break;
	case SOAP_TYPE_ns__AttributeList:
		if (p->size < 0)
			delete (ns__AttributeList*)p->ptr;
		else
			delete[] (ns__AttributeList*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetAttributes:
		if (p->size < 0)
			delete (struct ns__SetAttributes*)p->ptr;
		else
			delete[] (struct ns__SetAttributes*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllCurrentAttributesResponse:
		if (p->size < 0)
			delete (struct ns__GetAllCurrentAttributesResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllCurrentAttributesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllCurrentAttributes:
		if (p->size < 0)
			delete (struct ns__GetAllCurrentAttributes*)p->ptr;
		else
			delete[] (struct ns__GetAllCurrentAttributes*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllPreviousAttributesResponse:
		if (p->size < 0)
			delete (struct ns__GetAllPreviousAttributesResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllPreviousAttributesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllPreviousAttributes:
		if (p->size < 0)
			delete (struct ns__GetAllPreviousAttributes*)p->ptr;
		else
			delete[] (struct ns__GetAllPreviousAttributes*)p->ptr;
		break;
	case SOAP_TYPE_ns__I2CTriggerSettings:
		if (p->size < 0)
			delete (struct ns__I2CTriggerSettings*)p->ptr;
		else
			delete[] (struct ns__I2CTriggerSettings*)p->ptr;
		break;
	case SOAP_TYPE_ns__CANTriggerSettings:
		if (p->size < 0)
			delete (struct ns__CANTriggerSettings*)p->ptr;
		else
			delete[] (struct ns__CANTriggerSettings*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetSerTrgProtocolResponse:
		if (p->size < 0)
			delete (struct ns__GetSerTrgProtocolResponse*)p->ptr;
		else
			delete[] (struct ns__GetSerTrgProtocolResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetSerTrgProtocol:
		if (p->size < 0)
			delete (struct ns__GetSerTrgProtocol*)p->ptr;
		else
			delete[] (struct ns__GetSerTrgProtocol*)p->ptr;
		break;
	case SOAP_TYPE_ns__ResetSerTrg:
		if (p->size < 0)
			delete (struct ns__ResetSerTrg*)p->ptr;
		else
			delete[] (struct ns__ResetSerTrg*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetI2CTrigger:
		if (p->size < 0)
			delete (struct ns__SetI2CTrigger*)p->ptr;
		else
			delete[] (struct ns__SetI2CTrigger*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetI2CTrigger:
		if (p->size < 0)
			delete (struct ns__GetI2CTrigger*)p->ptr;
		else
			delete[] (struct ns__GetI2CTrigger*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetCANTrigger:
		if (p->size < 0)
			delete (struct ns__SetCANTrigger*)p->ptr;
		else
			delete[] (struct ns__SetCANTrigger*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetCANTrigger:
		if (p->size < 0)
			delete (struct ns__GetCANTrigger*)p->ptr;
		else
			delete[] (struct ns__GetCANTrigger*)p->ptr;
		break;
	case SOAP_TYPE_ns__AssociationChannel:
		if (p->size < 0)
			delete (struct ns__AssociationChannel*)p->ptr;
		else
			delete[] (struct ns__AssociationChannel*)p->ptr;
		break;
	case SOAP_TYPE_ns__AssociationChannelList:
		if (p->size < 0)
			delete (struct ns__AssociationChannelList*)p->ptr;
		else
			delete[] (struct ns__AssociationChannelList*)p->ptr;
		break;
	case SOAP_TYPE_ns__AssociationRow:
		if (p->size < 0)
			delete (struct ns__AssociationRow*)p->ptr;
		else
			delete[] (struct ns__AssociationRow*)p->ptr;
		break;
	case SOAP_TYPE_ns__AssociationRowList:
		if (p->size < 0)
			delete (struct ns__AssociationRowList*)p->ptr;
		else
			delete[] (struct ns__AssociationRowList*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllCurrentAssociationsResponse:
		if (p->size < 0)
			delete (struct ns__GetAllCurrentAssociationsResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllCurrentAssociationsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllCurrentAssociations:
		if (p->size < 0)
			delete (struct ns__GetAllCurrentAssociations*)p->ptr;
		else
			delete[] (struct ns__GetAllCurrentAssociations*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllPreviousAssociationsResponse:
		if (p->size < 0)
			delete (struct ns__GetAllPreviousAssociationsResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllPreviousAssociationsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllPreviousAssociations:
		if (p->size < 0)
			delete (struct ns__GetAllPreviousAssociations*)p->ptr;
		else
			delete[] (struct ns__GetAllPreviousAssociations*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetAssociations:
		if (p->size < 0)
			delete (struct ns__SetAssociations*)p->ptr;
		else
			delete[] (struct ns__SetAssociations*)p->ptr;
		break;
	case SOAP_TYPE_ns__GPSLog:
		if (p->size < 0)
			delete (struct ns__GPSLog*)p->ptr;
		else
			delete[] (struct ns__GPSLog*)p->ptr;
		break;
	case SOAP_TYPE_ns__GPSLogList:
		if (p->size < 0)
			delete (struct ns__GPSLogList*)p->ptr;
		else
			delete[] (struct ns__GPSLogList*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetGPSLogListResponse:
		if (p->size < 0)
			delete (struct ns__GetGPSLogListResponse*)p->ptr;
		else
			delete[] (struct ns__GetGPSLogListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetGPSLogList:
		if (p->size < 0)
			delete (struct ns__GetGPSLogList*)p->ptr;
		else
			delete[] (struct ns__GetGPSLogList*)p->ptr;
		break;
	case SOAP_TYPE_ns__DeviceData:
		if (p->size < 0)
			delete (ns__DeviceData*)p->ptr;
		else
			delete[] (ns__DeviceData*)p->ptr;
		break;
	case SOAP_TYPE_ns__WriteDev:
		if (p->size < 0)
			delete (struct ns__WriteDev*)p->ptr;
		else
			delete[] (struct ns__WriteDev*)p->ptr;
		break;
	case SOAP_TYPE_ns__ReadDevResponse:
		if (p->size < 0)
			delete (struct ns__ReadDevResponse*)p->ptr;
		else
			delete[] (struct ns__ReadDevResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__ReadDev:
		if (p->size < 0)
			delete (struct ns__ReadDev*)p->ptr;
		else
			delete[] (struct ns__ReadDev*)p->ptr;
		break;
	case SOAP_TYPE_ns__ReadWriteTwiResponse:
		if (p->size < 0)
			delete (struct ns__ReadWriteTwiResponse*)p->ptr;
		else
			delete[] (struct ns__ReadWriteTwiResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__ReadWriteTwi:
		if (p->size < 0)
			delete (struct ns__ReadWriteTwi*)p->ptr;
		else
			delete[] (struct ns__ReadWriteTwi*)p->ptr;
		break;
	case SOAP_TYPE_ns__PrepareStartResponse:
		if (p->size < 0)
			delete (struct ns__PrepareStartResponse*)p->ptr;
		else
			delete[] (struct ns__PrepareStartResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__PrepareStart:
		if (p->size < 0)
			delete (struct ns__PrepareStart*)p->ptr;
		else
			delete[] (struct ns__PrepareStart*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetStartInfo:
		if (p->size < 0)
			delete (struct ns__SetStartInfo*)p->ptr;
		else
			delete[] (struct ns__SetStartInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns__ExecuteCommand:
		if (p->size < 0)
			delete (struct ns__ExecuteCommand*)p->ptr;
		else
			delete[] (struct ns__ExecuteCommand*)p->ptr;
		break;
	case SOAP_TYPE_ns__StartCalibration:
		if (p->size < 0)
			delete (struct ns__StartCalibration*)p->ptr;
		else
			delete[] (struct ns__StartCalibration*)p->ptr;
		break;
	case SOAP_TYPE_ns__InputStatus:
		if (p->size < 0)
			delete (struct ns__InputStatus*)p->ptr;
		else
			delete[] (struct ns__InputStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__BoardStatus:
		if (p->size < 0)
			delete (struct ns__BoardStatus*)p->ptr;
		else
			delete[] (struct ns__BoardStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__GPSStatus:
		if (p->size < 0)
			delete (struct ns__GPSStatus*)p->ptr;
		else
			delete[] (struct ns__GPSStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__TempStatus:
		if (p->size < 0)
			delete (struct ns__TempStatus*)p->ptr;
		else
			delete[] (struct ns__TempStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__DeviceStatus:
		if (p->size < 0)
			delete (struct ns__DeviceStatus*)p->ptr;
		else
			delete[] (struct ns__DeviceStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__Status:
		if (p->size < 0)
			delete (struct ns__Status*)p->ptr;
		else
			delete[] (struct ns__Status*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetStatus:
		if (p->size < 0)
			delete (struct ns__GetStatus*)p->ptr;
		else
			delete[] (struct ns__GetStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__WaitForStatusChange:
		if (p->size < 0)
			delete (struct ns__WaitForStatusChange*)p->ptr;
		else
			delete[] (struct ns__WaitForStatusChange*)p->ptr;
		break;
	case SOAP_TYPE_ns__LeaveWaitStatus:
		if (p->size < 0)
			delete (struct ns__LeaveWaitStatus*)p->ptr;
		else
			delete[] (struct ns__LeaveWaitStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__Metadata:
		if (p->size < 0)
			delete (struct ns__Metadata*)p->ptr;
		else
			delete[] (struct ns__Metadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__MetadataList:
		if (p->size < 0)
			delete (ns__MetadataList*)p->ptr;
		else
			delete[] (ns__MetadataList*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetMetadataResponse:
		if (p->size < 0)
			delete (struct ns__GetMetadataResponse*)p->ptr;
		else
			delete[] (struct ns__GetMetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetMetadata:
		if (p->size < 0)
			delete (struct ns__GetMetadata*)p->ptr;
		else
			delete[] (struct ns__GetMetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__YMetadata:
		if (p->size < 0)
			delete (struct ns__YMetadata*)p->ptr;
		else
			delete[] (struct ns__YMetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__YMetadataList:
		if (p->size < 0)
			delete (ns__YMetadataList*)p->ptr;
		else
			delete[] (ns__YMetadataList*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllYMetadataResponse:
		if (p->size < 0)
			delete (struct ns__GetAllYMetadataResponse*)p->ptr;
		else
			delete[] (struct ns__GetAllYMetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAllYMetadata:
		if (p->size < 0)
			delete (struct ns__GetAllYMetadata*)p->ptr;
		else
			delete[] (struct ns__GetAllYMetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__DataSpecification:
		if (p->size < 0)
			delete (ns__DataSpecification*)p->ptr;
		else
			delete[] (ns__DataSpecification*)p->ptr;
		break;
	case SOAP_TYPE_ns__RangeDataSpecification:
		if (p->size < 0)
			delete (ns__RangeDataSpecification*)p->ptr;
		else
			delete[] (ns__RangeDataSpecification*)p->ptr;
		break;
	case SOAP_TYPE_ns__IndexList:
		if (p->size < 0)
			delete (ns__IndexList*)p->ptr;
		else
			delete[] (ns__IndexList*)p->ptr;
		break;
	case SOAP_TYPE_ns__EnvelopeDataSpecification:
		if (p->size < 0)
			delete (ns__EnvelopeDataSpecification*)p->ptr;
		else
			delete[] (ns__EnvelopeDataSpecification*)p->ptr;
		break;
	case SOAP_TYPE_ns__DataSpecificationArray:
		if (p->size < 0)
			delete (ns__DataSpecificationArray*)p->ptr;
		else
			delete[] (ns__DataSpecificationArray*)p->ptr;
		break;
	case SOAP_TYPE_ns__Data:
		if (p->size < 0)
			delete (ns__Data*)p->ptr;
		else
			delete[] (ns__Data*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetDataResponse:
		if (p->size < 0)
			delete (struct ns__GetDataResponse*)p->ptr;
		else
			delete[] (struct ns__GetDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetData:
		if (p->size < 0)
			delete (struct ns__GetData*)p->ptr;
		else
			delete[] (struct ns__GetData*)p->ptr;
		break;
	case SOAP_TYPE_ns__DataBlockHeader:
		if (p->size < 0)
			delete (struct ns__DataBlockHeader*)p->ptr;
		else
			delete[] (struct ns__DataBlockHeader*)p->ptr;
		break;
	case SOAP_TYPE_ns__SendServerCustomCommandResponse:
		if (p->size < 0)
			delete (struct ns__SendServerCustomCommandResponse*)p->ptr;
		else
			delete[] (struct ns__SendServerCustomCommandResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__SendServerCustomCommand:
		if (p->size < 0)
			delete (struct ns__SendServerCustomCommand*)p->ptr;
		else
			delete[] (struct ns__SendServerCustomCommand*)p->ptr;
		break;
	case SOAP_TYPE_ns__AutoSequence:
		if (p->size < 0)
			delete (ns__AutoSequence*)p->ptr;
		else
			delete[] (ns__AutoSequence*)p->ptr;
		break;
	case SOAP_TYPE_ns__LoadAutosequenceResponse:
		if (p->size < 0)
			delete (struct ns__LoadAutosequenceResponse*)p->ptr;
		else
			delete[] (struct ns__LoadAutosequenceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__LoadAutosequence:
		if (p->size < 0)
			delete (struct ns__LoadAutosequence*)p->ptr;
		else
			delete[] (struct ns__LoadAutosequence*)p->ptr;
		break;
	case SOAP_TYPE_ns__StartAutoSequenceResponse:
		if (p->size < 0)
			delete (struct ns__StartAutoSequenceResponse*)p->ptr;
		else
			delete[] (struct ns__StartAutoSequenceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__StartAutoSequence:
		if (p->size < 0)
			delete (struct ns__StartAutoSequence*)p->ptr;
		else
			delete[] (struct ns__StartAutoSequence*)p->ptr;
		break;
	case SOAP_TYPE_ns__StopAutoSequenceResponse:
		if (p->size < 0)
			delete (struct ns__StopAutoSequenceResponse*)p->ptr;
		else
			delete[] (struct ns__StopAutoSequenceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__StopAutoSequence:
		if (p->size < 0)
			delete (struct ns__StopAutoSequence*)p->ptr;
		else
			delete[] (struct ns__StopAutoSequence*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAutoSequenceResponse:
		if (p->size < 0)
			delete (struct ns__GetAutoSequenceResponse*)p->ptr;
		else
			delete[] (struct ns__GetAutoSequenceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetAutoSequence:
		if (p->size < 0)
			delete (struct ns__GetAutoSequence*)p->ptr;
		else
			delete[] (struct ns__GetAutoSequence*)p->ptr;
		break;
	case SOAP_TYPE_ns__SetDeviceSettings:
		if (p->size < 0)
			delete (struct ns__SetDeviceSettings*)p->ptr;
		else
			delete[] (struct ns__SetDeviceSettings*)p->ptr;
		break;
	case SOAP_TYPE_ns__DiskSpace:
		if (p->size < 0)
			delete (ns__DiskSpace*)p->ptr;
		else
			delete[] (ns__DiskSpace*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetFreeDiskSpace:
		if (p->size < 0)
			delete (struct ns__GetFreeDiskSpace*)p->ptr;
		else
			delete[] (struct ns__GetFreeDiskSpace*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetMACAddressResponse:
		if (p->size < 0)
			delete (struct ns__GetMACAddressResponse*)p->ptr;
		else
			delete[] (struct ns__GetMACAddressResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__GetMACAddress:
		if (p->size < 0)
			delete (struct ns__GetMACAddress*)p->ptr;
		else
			delete[] (struct ns__GetMACAddress*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TpcConstants(struct soap *soap, enum ns__TpcConstants *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__TpcConstants
	*a = SOAP_DEFAULT_ns__TpcConstants;
#else
	*a = (enum ns__TpcConstants)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TpcConstants(struct soap *soap, const enum ns__TpcConstants *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__TpcConstants);
	if (soap_out_ns__TpcConstants(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__TpcConstants[] =
{	{ (long)ns__maxBoards, "ns:maxBoards" },
	{ (long)ns__maxInputs, "ns:maxInputs" },
	{ (long)ns__maxInputRanges, "ns:maxInputRanges" },
	{ (long)ns__maxChargeInputRanges, "ns:maxChargeInputRanges" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__TpcConstants2s(struct soap *soap, enum ns__TpcConstants n)
{	const char *s = soap_code_str(soap_codes_ns__TpcConstants, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TpcConstants(struct soap *soap, const char *tag, int id, const enum ns__TpcConstants *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TpcConstants), type) || soap_send(soap, soap_ns__TpcConstants2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__TpcConstants * SOAP_FMAC4 soap_get_ns__TpcConstants(struct soap *soap, enum ns__TpcConstants *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TpcConstants(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__TpcConstants(struct soap *soap, const char *s, enum ns__TpcConstants *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_ns__TpcConstants, t);
	if (map)
		*a = (enum ns__TpcConstants)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__TpcConstants)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__TpcConstants * SOAP_FMAC4 soap_in_ns__TpcConstants(struct soap *soap, const char *tag, enum ns__TpcConstants *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__TpcConstants *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TpcConstants, sizeof(enum ns__TpcConstants), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__TpcConstants(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__TpcConstants *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TpcConstants, 0, sizeof(enum ns__TpcConstants), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ns__DiskSpace::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &this->ns__DiskSpace::freeDiskSpace);
	soap_default_unsignedLONG64(soap, &this->ns__DiskSpace::DiskSize);
}

void ns__DiskSpace::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns__DiskSpace::freeDiskSpace, SOAP_TYPE_unsignedLONG64);
	soap_embedded(soap, &this->ns__DiskSpace::DiskSize, SOAP_TYPE_unsignedLONG64);
}

int ns__DiskSpace::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__DiskSpace);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__DiskSpace::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DiskSpace(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DiskSpace(struct soap *soap, const char *tag, int id, const ns__DiskSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DiskSpace), type))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "freeDiskSpace", -1, &(a->ns__DiskSpace::freeDiskSpace), ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "DiskSize", -1, &(a->ns__DiskSpace::DiskSize), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DiskSpace::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DiskSpace(soap, this, tag, type);
}

SOAP_FMAC3 ns__DiskSpace * SOAP_FMAC4 soap_get_ns__DiskSpace(struct soap *soap, ns__DiskSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__DiskSpace::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DiskSpace(soap, tag, this, type);
}

SOAP_FMAC3 ns__DiskSpace * SOAP_FMAC4 soap_in_ns__DiskSpace(struct soap *soap, const char *tag, ns__DiskSpace *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DiskSpace *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DiskSpace, sizeof(ns__DiskSpace), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__DiskSpace)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__DiskSpace *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_freeDiskSpace1 = 1;
	size_t soap_flag_DiskSize1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_freeDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "freeDiskSpace", &(a->ns__DiskSpace::freeDiskSpace), "xsd:unsignedLong"))
				{	soap_flag_freeDiskSpace1--;
					continue;
				}
			if (soap_flag_DiskSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "DiskSize", &(a->ns__DiskSpace::DiskSize), "xsd:unsignedLong"))
				{	soap_flag_DiskSize1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__DiskSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DiskSpace, 0, sizeof(ns__DiskSpace), 0, soap_copy_ns__DiskSpace);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_freeDiskSpace1 > 0 || soap_flag_DiskSize1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__DiskSpace * SOAP_FMAC6 soap_new_ns__DiskSpace(struct soap *soap, int n)
{	return soap_instantiate_ns__DiskSpace(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DiskSpace(struct soap *soap, ns__DiskSpace *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__DiskSpace * SOAP_FMAC4 soap_instantiate_ns__DiskSpace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DiskSpace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DiskSpace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__DiskSpace;
		if (size)
			*size = sizeof(ns__DiskSpace);
	}
	else
	{	cp->ptr = (void*)new ns__DiskSpace[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__DiskSpace);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__DiskSpace*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DiskSpace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__DiskSpace %p -> %p\n", q, p));
	*(ns__DiskSpace*)p = *(ns__DiskSpace*)q;
}

void ns__AutoSequence::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__AutoSequence::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__AutoSequence))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_byte);
		}
}

int ns__AutoSequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__AutoSequence);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__AutoSequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__AutoSequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AutoSequence(struct soap *soap, const char *tag, int id, const ns__AutoSequence *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__AutoSequence);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_byte(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__AutoSequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__AutoSequence(soap, this, tag, type);
}

SOAP_FMAC3 ns__AutoSequence * SOAP_FMAC4 soap_get_ns__AutoSequence(struct soap *soap, ns__AutoSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AutoSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__AutoSequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__AutoSequence(soap, tag, this, type);
}

SOAP_FMAC3 ns__AutoSequence * SOAP_FMAC4 soap_in_ns__AutoSequence(struct soap *soap, const char *tag, ns__AutoSequence *a, const char *type)
{	int i, j;
	char *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:byte") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__AutoSequence *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AutoSequence, sizeof(ns__AutoSequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char *)soap_malloc(soap, sizeof(char) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_byte(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_byte(soap, NULL, a->__ptr + i, "xsd:byte"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char *)soap_push_block(soap, NULL, sizeof(char));
				if (!p)
					return NULL;
				soap_default_byte(soap, p);
				if (!soap_in_byte(soap, NULL, p, "xsd:byte"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__AutoSequence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AutoSequence, 0, sizeof(ns__AutoSequence), 0, soap_copy_ns__AutoSequence);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__AutoSequence * SOAP_FMAC6 soap_new_ns__AutoSequence(struct soap *soap, int n)
{	return soap_instantiate_ns__AutoSequence(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AutoSequence(struct soap *soap, ns__AutoSequence *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__AutoSequence * SOAP_FMAC4 soap_instantiate_ns__AutoSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AutoSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AutoSequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__AutoSequence;
		if (size)
			*size = sizeof(ns__AutoSequence);
	}
	else
	{	cp->ptr = (void*)new ns__AutoSequence[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__AutoSequence);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__AutoSequence*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AutoSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__AutoSequence %p -> %p\n", q, p));
	*(ns__AutoSequence*)p = *(ns__AutoSequence*)q;
}

void ns__Data::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void ns__Data::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__Data))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int ns__Data::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__Data);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__Data::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__Data(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Data(struct soap *soap, const char *tag, int id, const ns__Data *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_ns__Data);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__Data);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Data::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Data(soap, this, tag, type);
}

SOAP_FMAC3 ns__Data * SOAP_FMAC4 soap_get_ns__Data(struct soap *soap, ns__Data *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Data(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__Data::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Data(soap, tag, this, type);
}

SOAP_FMAC3 ns__Data * SOAP_FMAC4 soap_in_ns__Data(struct soap *soap, const char *tag, ns__Data *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__Data *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Data, sizeof(ns__Data), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (ns__Data *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Data, 0, sizeof(ns__Data), 0, soap_copy_ns__Data);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__Data * SOAP_FMAC6 soap_new_ns__Data(struct soap *soap, int n)
{	return soap_instantiate_ns__Data(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__Data(struct soap *soap, ns__Data *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__Data * SOAP_FMAC4 soap_instantiate_ns__Data(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Data(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Data, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__Data;
		if (size)
			*size = sizeof(ns__Data);
	}
	else
	{	cp->ptr = (void*)new ns__Data[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__Data);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__Data*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Data(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Data %p -> %p\n", q, p));
	*(ns__Data*)p = *(ns__Data*)q;
}

void ns__DataSpecificationArray::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__DataSpecificationArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__DataSpecificationArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons__DataSpecification(soap, this->__ptr + i);
		}
}

int ns__DataSpecificationArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__DataSpecificationArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__DataSpecificationArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__DataSpecificationArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DataSpecificationArray(struct soap *soap, const char *tag, int id, const ns__DataSpecificationArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__DataSpecificationArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_PointerTons__DataSpecification(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__DataSpecificationArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DataSpecificationArray(soap, this, tag, type);
}

SOAP_FMAC3 ns__DataSpecificationArray * SOAP_FMAC4 soap_get_ns__DataSpecificationArray(struct soap *soap, ns__DataSpecificationArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DataSpecificationArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__DataSpecificationArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DataSpecificationArray(soap, tag, this, type);
}

SOAP_FMAC3 ns__DataSpecificationArray * SOAP_FMAC4 soap_in_ns__DataSpecificationArray(struct soap *soap, const char *tag, ns__DataSpecificationArray *a, const char *type)
{	int i, j;
	ns__DataSpecification **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:DataSpecification") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__DataSpecificationArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DataSpecificationArray, sizeof(ns__DataSpecificationArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns__DataSpecification **)soap_malloc(soap, sizeof(ns__DataSpecification *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons__DataSpecification(soap, NULL, a->__ptr + i, "ns:DataSpecification"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns__DataSpecification **)soap_push_block(soap, NULL, sizeof(ns__DataSpecification *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons__DataSpecification(soap, NULL, p, "ns:DataSpecification"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns__DataSpecification **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__DataSpecificationArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DataSpecificationArray, 0, sizeof(ns__DataSpecificationArray), 0, soap_copy_ns__DataSpecificationArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__DataSpecificationArray * SOAP_FMAC6 soap_new_ns__DataSpecificationArray(struct soap *soap, int n)
{	return soap_instantiate_ns__DataSpecificationArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DataSpecificationArray(struct soap *soap, ns__DataSpecificationArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__DataSpecificationArray * SOAP_FMAC4 soap_instantiate_ns__DataSpecificationArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DataSpecificationArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DataSpecificationArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__DataSpecificationArray;
		if (size)
			*size = sizeof(ns__DataSpecificationArray);
	}
	else
	{	cp->ptr = (void*)new ns__DataSpecificationArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__DataSpecificationArray);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__DataSpecificationArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DataSpecificationArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__DataSpecificationArray %p -> %p\n", q, p));
	*(ns__DataSpecificationArray*)p = *(ns__DataSpecificationArray*)q;
}

void ns__EnvelopeDataSpecification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__EnvelopeDataSpecification::indices.ns__IndexList::soap_default(soap);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::boardAddress);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::inputNumber);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::blockNumber);
}

void ns__EnvelopeDataSpecification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__EnvelopeDataSpecification::indices.soap_serialize(soap);
}

int ns__EnvelopeDataSpecification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__EnvelopeDataSpecification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__EnvelopeDataSpecification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__EnvelopeDataSpecification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__EnvelopeDataSpecification(struct soap *soap, const char *tag, int id, const ns__EnvelopeDataSpecification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__EnvelopeDataSpecification), "ns:EnvelopeDataSpecification"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "boardAddress", -1, &(a->ns__DataSpecification::boardAddress), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "inputNumber", -1, &(a->ns__DataSpecification::inputNumber), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "blockNumber", -1, &(a->ns__DataSpecification::blockNumber), ""))
		return soap->error;
	if ((a->ns__EnvelopeDataSpecification::indices).soap_out(soap, "indices", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__EnvelopeDataSpecification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__EnvelopeDataSpecification(soap, this, tag, type);
}

SOAP_FMAC3 ns__EnvelopeDataSpecification * SOAP_FMAC4 soap_get_ns__EnvelopeDataSpecification(struct soap *soap, ns__EnvelopeDataSpecification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__EnvelopeDataSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__EnvelopeDataSpecification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__EnvelopeDataSpecification(soap, tag, this, type);
}

SOAP_FMAC3 ns__EnvelopeDataSpecification * SOAP_FMAC4 soap_in_ns__EnvelopeDataSpecification(struct soap *soap, const char *tag, ns__EnvelopeDataSpecification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__EnvelopeDataSpecification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__EnvelopeDataSpecification, sizeof(ns__EnvelopeDataSpecification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__EnvelopeDataSpecification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__EnvelopeDataSpecification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_boardAddress2 = 1;
	size_t soap_flag_inputNumber2 = 1;
	size_t soap_flag_blockNumber2 = 1;
	size_t soap_flag_indices1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boardAddress", &(a->ns__DataSpecification::boardAddress), "xsd:unsignedInt"))
				{	soap_flag_boardAddress2--;
					continue;
				}
			if (soap_flag_inputNumber2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "inputNumber", &(a->ns__DataSpecification::inputNumber), "xsd:unsignedInt"))
				{	soap_flag_inputNumber2--;
					continue;
				}
			if (soap_flag_blockNumber2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "blockNumber", &(a->ns__DataSpecification::blockNumber), "xsd:unsignedInt"))
				{	soap_flag_blockNumber2--;
					continue;
				}
			if (soap_flag_indices1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EnvelopeDataSpecification::indices).soap_in(soap, "indices", "ns:IndexList"))
				{	soap_flag_indices1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__EnvelopeDataSpecification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__EnvelopeDataSpecification, 0, sizeof(ns__EnvelopeDataSpecification), 0, soap_copy_ns__EnvelopeDataSpecification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress2 > 0 || soap_flag_inputNumber2 > 0 || soap_flag_blockNumber2 > 0 || soap_flag_indices1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__EnvelopeDataSpecification * SOAP_FMAC6 soap_new_ns__EnvelopeDataSpecification(struct soap *soap, int n)
{	return soap_instantiate_ns__EnvelopeDataSpecification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__EnvelopeDataSpecification(struct soap *soap, ns__EnvelopeDataSpecification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__EnvelopeDataSpecification * SOAP_FMAC4 soap_instantiate_ns__EnvelopeDataSpecification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__EnvelopeDataSpecification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__EnvelopeDataSpecification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__EnvelopeDataSpecification;
		if (size)
			*size = sizeof(ns__EnvelopeDataSpecification);
	}
	else
	{	cp->ptr = (void*)new ns__EnvelopeDataSpecification[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__EnvelopeDataSpecification);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__EnvelopeDataSpecification*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__EnvelopeDataSpecification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__EnvelopeDataSpecification %p -> %p\n", q, p));
	*(ns__EnvelopeDataSpecification*)p = *(ns__EnvelopeDataSpecification*)q;
}

void ns__IndexList::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__IndexList::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__IndexList))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_unsignedLONG64);
		}
}

int ns__IndexList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__IndexList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__IndexList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__IndexList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__IndexList(struct soap *soap, const char *tag, int id, const ns__IndexList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__IndexList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_unsignedLONG64(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__IndexList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__IndexList(soap, this, tag, type);
}

SOAP_FMAC3 ns__IndexList * SOAP_FMAC4 soap_get_ns__IndexList(struct soap *soap, ns__IndexList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__IndexList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__IndexList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__IndexList(soap, tag, this, type);
}

SOAP_FMAC3 ns__IndexList * SOAP_FMAC4 soap_in_ns__IndexList(struct soap *soap, const char *tag, ns__IndexList *a, const char *type)
{	int i, j;
	ULONG64 *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:unsignedLong") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__IndexList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__IndexList, sizeof(ns__IndexList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ULONG64 *)soap_malloc(soap, sizeof(ULONG64) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_unsignedLONG64(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_unsignedLONG64(soap, NULL, a->__ptr + i, "xsd:unsignedLong"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ULONG64 *)soap_push_block(soap, NULL, sizeof(ULONG64));
				if (!p)
					return NULL;
				soap_default_unsignedLONG64(soap, p);
				if (!soap_in_unsignedLONG64(soap, NULL, p, "xsd:unsignedLong"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ULONG64 *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__IndexList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__IndexList, 0, sizeof(ns__IndexList), 0, soap_copy_ns__IndexList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__IndexList * SOAP_FMAC6 soap_new_ns__IndexList(struct soap *soap, int n)
{	return soap_instantiate_ns__IndexList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__IndexList(struct soap *soap, ns__IndexList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__IndexList * SOAP_FMAC4 soap_instantiate_ns__IndexList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__IndexList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__IndexList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__IndexList;
		if (size)
			*size = sizeof(ns__IndexList);
	}
	else
	{	cp->ptr = (void*)new ns__IndexList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__IndexList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__IndexList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__IndexList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__IndexList %p -> %p\n", q, p));
	*(ns__IndexList*)p = *(ns__IndexList*)q;
}

void ns__RangeDataSpecification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns__RangeDataSpecification::readoutType);
	soap_default_unsignedLONG64(soap, &this->ns__RangeDataSpecification::dataStart);
	soap_default_unsignedLONG64(soap, &this->ns__RangeDataSpecification::dataLength);
	soap_default_unsignedInt(soap, &this->ns__RangeDataSpecification::resultLength);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::boardAddress);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::inputNumber);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::blockNumber);
}

void ns__RangeDataSpecification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns__RangeDataSpecification::dataStart, SOAP_TYPE_unsignedLONG64);
	soap_embedded(soap, &this->ns__RangeDataSpecification::dataLength, SOAP_TYPE_unsignedLONG64);
}

int ns__RangeDataSpecification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__RangeDataSpecification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__RangeDataSpecification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__RangeDataSpecification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__RangeDataSpecification(struct soap *soap, const char *tag, int id, const ns__RangeDataSpecification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__RangeDataSpecification), "ns:RangeDataSpecification"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "boardAddress", -1, &(a->ns__DataSpecification::boardAddress), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "inputNumber", -1, &(a->ns__DataSpecification::inputNumber), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "blockNumber", -1, &(a->ns__DataSpecification::blockNumber), ""))
		return soap->error;
	if (soap_out_int(soap, "readoutType", -1, &(a->ns__RangeDataSpecification::readoutType), ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "dataStart", -1, &(a->ns__RangeDataSpecification::dataStart), ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "dataLength", -1, &(a->ns__RangeDataSpecification::dataLength), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "resultLength", -1, &(a->ns__RangeDataSpecification::resultLength), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__RangeDataSpecification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__RangeDataSpecification(soap, this, tag, type);
}

SOAP_FMAC3 ns__RangeDataSpecification * SOAP_FMAC4 soap_get_ns__RangeDataSpecification(struct soap *soap, ns__RangeDataSpecification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__RangeDataSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__RangeDataSpecification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__RangeDataSpecification(soap, tag, this, type);
}

SOAP_FMAC3 ns__RangeDataSpecification * SOAP_FMAC4 soap_in_ns__RangeDataSpecification(struct soap *soap, const char *tag, ns__RangeDataSpecification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__RangeDataSpecification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__RangeDataSpecification, sizeof(ns__RangeDataSpecification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__RangeDataSpecification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__RangeDataSpecification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_boardAddress2 = 1;
	size_t soap_flag_inputNumber2 = 1;
	size_t soap_flag_blockNumber2 = 1;
	size_t soap_flag_readoutType1 = 1;
	size_t soap_flag_dataStart1 = 1;
	size_t soap_flag_dataLength1 = 1;
	size_t soap_flag_resultLength1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boardAddress", &(a->ns__DataSpecification::boardAddress), "xsd:unsignedInt"))
				{	soap_flag_boardAddress2--;
					continue;
				}
			if (soap_flag_inputNumber2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "inputNumber", &(a->ns__DataSpecification::inputNumber), "xsd:unsignedInt"))
				{	soap_flag_inputNumber2--;
					continue;
				}
			if (soap_flag_blockNumber2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "blockNumber", &(a->ns__DataSpecification::blockNumber), "xsd:unsignedInt"))
				{	soap_flag_blockNumber2--;
					continue;
				}
			if (soap_flag_readoutType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "readoutType", &(a->ns__RangeDataSpecification::readoutType), "xsd:int"))
				{	soap_flag_readoutType1--;
					continue;
				}
			if (soap_flag_dataStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "dataStart", &(a->ns__RangeDataSpecification::dataStart), "xsd:unsignedLong"))
				{	soap_flag_dataStart1--;
					continue;
				}
			if (soap_flag_dataLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "dataLength", &(a->ns__RangeDataSpecification::dataLength), "xsd:unsignedLong"))
				{	soap_flag_dataLength1--;
					continue;
				}
			if (soap_flag_resultLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "resultLength", &(a->ns__RangeDataSpecification::resultLength), "xsd:unsignedInt"))
				{	soap_flag_resultLength1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__RangeDataSpecification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__RangeDataSpecification, 0, sizeof(ns__RangeDataSpecification), 0, soap_copy_ns__RangeDataSpecification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress2 > 0 || soap_flag_inputNumber2 > 0 || soap_flag_blockNumber2 > 0 || soap_flag_readoutType1 > 0 || soap_flag_dataStart1 > 0 || soap_flag_dataLength1 > 0 || soap_flag_resultLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__RangeDataSpecification * SOAP_FMAC6 soap_new_ns__RangeDataSpecification(struct soap *soap, int n)
{	return soap_instantiate_ns__RangeDataSpecification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__RangeDataSpecification(struct soap *soap, ns__RangeDataSpecification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__RangeDataSpecification * SOAP_FMAC4 soap_instantiate_ns__RangeDataSpecification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__RangeDataSpecification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__RangeDataSpecification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__RangeDataSpecification;
		if (size)
			*size = sizeof(ns__RangeDataSpecification);
	}
	else
	{	cp->ptr = (void*)new ns__RangeDataSpecification[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__RangeDataSpecification);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__RangeDataSpecification*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__RangeDataSpecification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__RangeDataSpecification %p -> %p\n", q, p));
	*(ns__RangeDataSpecification*)p = *(ns__RangeDataSpecification*)q;
}

void ns__DataSpecification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::boardAddress);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::inputNumber);
	soap_default_unsignedInt(soap, &this->ns__DataSpecification::blockNumber);
}

void ns__DataSpecification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__DataSpecification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__DataSpecification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__DataSpecification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DataSpecification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DataSpecification(struct soap *soap, const char *tag, int id, const ns__DataSpecification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DataSpecification), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "boardAddress", -1, &(a->ns__DataSpecification::boardAddress), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "inputNumber", -1, &(a->ns__DataSpecification::inputNumber), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "blockNumber", -1, &(a->ns__DataSpecification::blockNumber), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DataSpecification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DataSpecification(soap, this, tag, type);
}

SOAP_FMAC3 ns__DataSpecification * SOAP_FMAC4 soap_get_ns__DataSpecification(struct soap *soap, ns__DataSpecification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DataSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__DataSpecification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DataSpecification(soap, tag, this, type);
}

SOAP_FMAC3 ns__DataSpecification * SOAP_FMAC4 soap_in_ns__DataSpecification(struct soap *soap, const char *tag, ns__DataSpecification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DataSpecification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DataSpecification, sizeof(ns__DataSpecification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__DataSpecification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__DataSpecification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_boardAddress1 = 1;
	size_t soap_flag_inputNumber1 = 1;
	size_t soap_flag_blockNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boardAddress", &(a->ns__DataSpecification::boardAddress), "xsd:unsignedInt"))
				{	soap_flag_boardAddress1--;
					continue;
				}
			if (soap_flag_inputNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "inputNumber", &(a->ns__DataSpecification::inputNumber), "xsd:unsignedInt"))
				{	soap_flag_inputNumber1--;
					continue;
				}
			if (soap_flag_blockNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "blockNumber", &(a->ns__DataSpecification::blockNumber), "xsd:unsignedInt"))
				{	soap_flag_blockNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__DataSpecification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DataSpecification, 0, sizeof(ns__DataSpecification), 0, soap_copy_ns__DataSpecification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress1 > 0 || soap_flag_inputNumber1 > 0 || soap_flag_blockNumber1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__DataSpecification * SOAP_FMAC6 soap_new_ns__DataSpecification(struct soap *soap, int n)
{	return soap_instantiate_ns__DataSpecification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DataSpecification(struct soap *soap, ns__DataSpecification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__DataSpecification * SOAP_FMAC4 soap_instantiate_ns__DataSpecification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DataSpecification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DataSpecification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns:RangeDataSpecification"))
	{	cp->type = SOAP_TYPE_ns__RangeDataSpecification;
		if (n < 0)
		{	cp->ptr = (void*)new ns__RangeDataSpecification;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns__RangeDataSpecification);
		}
		else
		{	cp->ptr = (void*)new ns__RangeDataSpecification[n];
			if (size)
				*size = n * sizeof(ns__RangeDataSpecification);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__RangeDataSpecification*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:EnvelopeDataSpecification"))
	{	cp->type = SOAP_TYPE_ns__EnvelopeDataSpecification;
		if (n < 0)
		{	cp->ptr = (void*)new ns__EnvelopeDataSpecification;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns__EnvelopeDataSpecification);
		}
		else
		{	cp->ptr = (void*)new ns__EnvelopeDataSpecification[n];
			if (size)
				*size = n * sizeof(ns__EnvelopeDataSpecification);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__EnvelopeDataSpecification*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns__DataSpecification;
		if (size)
			*size = sizeof(ns__DataSpecification);
	}
	else
	{	cp->ptr = (void*)new ns__DataSpecification[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__DataSpecification);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__DataSpecification*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DataSpecification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__DataSpecification %p -> %p\n", q, p));
	*(ns__DataSpecification*)p = *(ns__DataSpecification*)q;
}

void ns__YMetadataList::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__YMetadataList::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__YMetadataList))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__YMetadata);
			soap_serialize_ns__YMetadata(soap, this->__ptr + i);
		}
}

int ns__YMetadataList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__YMetadataList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__YMetadataList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__YMetadataList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__YMetadataList(struct soap *soap, const char *tag, int id, const ns__YMetadataList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__YMetadataList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__YMetadata(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__YMetadataList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__YMetadataList(soap, this, tag, type);
}

SOAP_FMAC3 ns__YMetadataList * SOAP_FMAC4 soap_get_ns__YMetadataList(struct soap *soap, ns__YMetadataList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__YMetadataList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__YMetadataList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__YMetadataList(soap, tag, this, type);
}

SOAP_FMAC3 ns__YMetadataList * SOAP_FMAC4 soap_in_ns__YMetadataList(struct soap *soap, const char *tag, ns__YMetadataList *a, const char *type)
{	int i, j;
	struct ns__YMetadata *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:YMetadata") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__YMetadataList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__YMetadataList, sizeof(ns__YMetadataList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__YMetadata *)soap_malloc(soap, sizeof(struct ns__YMetadata) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__YMetadata(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__YMetadata(soap, NULL, a->__ptr + i, "ns:YMetadata"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__YMetadata *)soap_push_block(soap, NULL, sizeof(struct ns__YMetadata));
				if (!p)
					return NULL;
				soap_default_ns__YMetadata(soap, p);
				if (!soap_in_ns__YMetadata(soap, NULL, p, "ns:YMetadata"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__YMetadata *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__YMetadataList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__YMetadataList, 0, sizeof(ns__YMetadataList), 0, soap_copy_ns__YMetadataList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__YMetadataList * SOAP_FMAC6 soap_new_ns__YMetadataList(struct soap *soap, int n)
{	return soap_instantiate_ns__YMetadataList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__YMetadataList(struct soap *soap, ns__YMetadataList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__YMetadataList * SOAP_FMAC4 soap_instantiate_ns__YMetadataList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__YMetadataList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__YMetadataList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__YMetadataList;
		if (size)
			*size = sizeof(ns__YMetadataList);
	}
	else
	{	cp->ptr = (void*)new ns__YMetadataList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__YMetadataList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__YMetadataList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__YMetadataList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__YMetadataList %p -> %p\n", q, p));
	*(ns__YMetadataList*)p = *(ns__YMetadataList*)q;
}

void ns__MetadataList::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__MetadataList::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__MetadataList))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__Metadata);
			soap_serialize_ns__Metadata(soap, this->__ptr + i);
		}
}

int ns__MetadataList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__MetadataList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__MetadataList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__MetadataList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__MetadataList(struct soap *soap, const char *tag, int id, const ns__MetadataList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__MetadataList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__Metadata(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__MetadataList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__MetadataList(soap, this, tag, type);
}

SOAP_FMAC3 ns__MetadataList * SOAP_FMAC4 soap_get_ns__MetadataList(struct soap *soap, ns__MetadataList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__MetadataList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__MetadataList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__MetadataList(soap, tag, this, type);
}

SOAP_FMAC3 ns__MetadataList * SOAP_FMAC4 soap_in_ns__MetadataList(struct soap *soap, const char *tag, ns__MetadataList *a, const char *type)
{	int i, j;
	struct ns__Metadata *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:Metadata") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__MetadataList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__MetadataList, sizeof(ns__MetadataList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__Metadata *)soap_malloc(soap, sizeof(struct ns__Metadata) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__Metadata(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__Metadata(soap, NULL, a->__ptr + i, "ns:Metadata"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__Metadata *)soap_push_block(soap, NULL, sizeof(struct ns__Metadata));
				if (!p)
					return NULL;
				soap_default_ns__Metadata(soap, p);
				if (!soap_in_ns__Metadata(soap, NULL, p, "ns:Metadata"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__Metadata *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__MetadataList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__MetadataList, 0, sizeof(ns__MetadataList), 0, soap_copy_ns__MetadataList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__MetadataList * SOAP_FMAC6 soap_new_ns__MetadataList(struct soap *soap, int n)
{	return soap_instantiate_ns__MetadataList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__MetadataList(struct soap *soap, ns__MetadataList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__MetadataList * SOAP_FMAC4 soap_instantiate_ns__MetadataList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__MetadataList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__MetadataList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__MetadataList;
		if (size)
			*size = sizeof(ns__MetadataList);
	}
	else
	{	cp->ptr = (void*)new ns__MetadataList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__MetadataList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__MetadataList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__MetadataList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__MetadataList %p -> %p\n", q, p));
	*(ns__MetadataList*)p = *(ns__MetadataList*)q;
}

void ns__DeviceData::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__DeviceData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__DeviceData);
}

int ns__DeviceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__DeviceData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__DeviceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__DeviceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceData(struct soap *soap, const char *tag, int id, const ns__DeviceData *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__DeviceData);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceData(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceData * SOAP_FMAC4 soap_get_ns__DeviceData(struct soap *soap, ns__DeviceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__DeviceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceData(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceData * SOAP_FMAC4 soap_in_ns__DeviceData(struct soap *soap, const char *tag, ns__DeviceData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__DeviceData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceData, sizeof(ns__DeviceData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__DeviceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceData, 0, sizeof(ns__DeviceData), 0, soap_copy_ns__DeviceData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__DeviceData * SOAP_FMAC6 soap_new_ns__DeviceData(struct soap *soap, int n)
{	return soap_instantiate_ns__DeviceData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DeviceData(struct soap *soap, ns__DeviceData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__DeviceData * SOAP_FMAC4 soap_instantiate_ns__DeviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DeviceData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__DeviceData;
		if (size)
			*size = sizeof(ns__DeviceData);
	}
	else
	{	cp->ptr = (void*)new ns__DeviceData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__DeviceData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__DeviceData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DeviceData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__DeviceData %p -> %p\n", q, p));
	*(ns__DeviceData*)p = *(ns__DeviceData*)q;
}

void ns__AttributeList::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__AttributeList::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__AttributeList))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__Attribute);
			soap_serialize_ns__Attribute(soap, this->__ptr + i);
		}
}

int ns__AttributeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__AttributeList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__AttributeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__AttributeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AttributeList(struct soap *soap, const char *tag, int id, const ns__AttributeList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__AttributeList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__Attribute(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__AttributeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__AttributeList(soap, this, tag, type);
}

SOAP_FMAC3 ns__AttributeList * SOAP_FMAC4 soap_get_ns__AttributeList(struct soap *soap, ns__AttributeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AttributeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__AttributeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__AttributeList(soap, tag, this, type);
}

SOAP_FMAC3 ns__AttributeList * SOAP_FMAC4 soap_in_ns__AttributeList(struct soap *soap, const char *tag, ns__AttributeList *a, const char *type)
{	int i, j;
	struct ns__Attribute *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:Attribute") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__AttributeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AttributeList, sizeof(ns__AttributeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__Attribute *)soap_malloc(soap, sizeof(struct ns__Attribute) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__Attribute(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__Attribute(soap, NULL, a->__ptr + i, "ns:Attribute"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__Attribute *)soap_push_block(soap, NULL, sizeof(struct ns__Attribute));
				if (!p)
					return NULL;
				soap_default_ns__Attribute(soap, p);
				if (!soap_in_ns__Attribute(soap, NULL, p, "ns:Attribute"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__Attribute *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__AttributeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AttributeList, 0, sizeof(ns__AttributeList), 0, soap_copy_ns__AttributeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__AttributeList * SOAP_FMAC6 soap_new_ns__AttributeList(struct soap *soap, int n)
{	return soap_instantiate_ns__AttributeList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AttributeList(struct soap *soap, ns__AttributeList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__AttributeList * SOAP_FMAC4 soap_instantiate_ns__AttributeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AttributeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AttributeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__AttributeList;
		if (size)
			*size = sizeof(ns__AttributeList);
	}
	else
	{	cp->ptr = (void*)new ns__AttributeList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__AttributeList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__AttributeList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AttributeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__AttributeList %p -> %p\n", q, p));
	*(ns__AttributeList*)p = *(ns__AttributeList*)q;
}

void ns__SetParameterResultList::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__SetParameterResultList::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__SetParameterResultList))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__SetOneParameterResult);
			soap_serialize_ns__SetOneParameterResult(soap, this->__ptr + i);
		}
}

int ns__SetParameterResultList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__SetParameterResultList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__SetParameterResultList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__SetParameterResultList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetParameterResultList(struct soap *soap, const char *tag, int id, const ns__SetParameterResultList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__SetParameterResultList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__SetOneParameterResult(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__SetParameterResultList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__SetParameterResultList(soap, this, tag, type);
}

SOAP_FMAC3 ns__SetParameterResultList * SOAP_FMAC4 soap_get_ns__SetParameterResultList(struct soap *soap, ns__SetParameterResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetParameterResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__SetParameterResultList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__SetParameterResultList(soap, tag, this, type);
}

SOAP_FMAC3 ns__SetParameterResultList * SOAP_FMAC4 soap_in_ns__SetParameterResultList(struct soap *soap, const char *tag, ns__SetParameterResultList *a, const char *type)
{	int i, j;
	struct ns__SetOneParameterResult *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:SetOneParameterResult") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__SetParameterResultList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetParameterResultList, sizeof(ns__SetParameterResultList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__SetOneParameterResult *)soap_malloc(soap, sizeof(struct ns__SetOneParameterResult) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__SetOneParameterResult(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__SetOneParameterResult(soap, NULL, a->__ptr + i, "ns:SetOneParameterResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__SetOneParameterResult *)soap_push_block(soap, NULL, sizeof(struct ns__SetOneParameterResult));
				if (!p)
					return NULL;
				soap_default_ns__SetOneParameterResult(soap, p);
				if (!soap_in_ns__SetOneParameterResult(soap, NULL, p, "ns:SetOneParameterResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__SetOneParameterResult *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__SetParameterResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetParameterResultList, 0, sizeof(ns__SetParameterResultList), 0, soap_copy_ns__SetParameterResultList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__SetParameterResultList * SOAP_FMAC6 soap_new_ns__SetParameterResultList(struct soap *soap, int n)
{	return soap_instantiate_ns__SetParameterResultList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetParameterResultList(struct soap *soap, ns__SetParameterResultList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__SetParameterResultList * SOAP_FMAC4 soap_instantiate_ns__SetParameterResultList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetParameterResultList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetParameterResultList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__SetParameterResultList;
		if (size)
			*size = sizeof(ns__SetParameterResultList);
	}
	else
	{	cp->ptr = (void*)new ns__SetParameterResultList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__SetParameterResultList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__SetParameterResultList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetParameterResultList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__SetParameterResultList %p -> %p\n", q, p));
	*(ns__SetParameterResultList*)p = *(ns__SetParameterResultList*)q;
}

void ns__ParameterList::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__ParameterList::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__ParameterList))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__Parameter);
			soap_serialize_ns__Parameter(soap, this->__ptr + i);
		}
}

int ns__ParameterList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__ParameterList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__ParameterList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__ParameterList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ParameterList(struct soap *soap, const char *tag, int id, const ns__ParameterList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__ParameterList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__Parameter(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__ParameterList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ParameterList(soap, this, tag, type);
}

SOAP_FMAC3 ns__ParameterList * SOAP_FMAC4 soap_get_ns__ParameterList(struct soap *soap, ns__ParameterList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ParameterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__ParameterList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ParameterList(soap, tag, this, type);
}

SOAP_FMAC3 ns__ParameterList * SOAP_FMAC4 soap_in_ns__ParameterList(struct soap *soap, const char *tag, ns__ParameterList *a, const char *type)
{	int i, j;
	struct ns__Parameter *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:Parameter") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__ParameterList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ParameterList, sizeof(ns__ParameterList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__Parameter *)soap_malloc(soap, sizeof(struct ns__Parameter) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__Parameter(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__Parameter(soap, NULL, a->__ptr + i, "ns:Parameter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__Parameter *)soap_push_block(soap, NULL, sizeof(struct ns__Parameter));
				if (!p)
					return NULL;
				soap_default_ns__Parameter(soap, p);
				if (!soap_in_ns__Parameter(soap, NULL, p, "ns:Parameter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__Parameter *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__ParameterList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ParameterList, 0, sizeof(ns__ParameterList), 0, soap_copy_ns__ParameterList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__ParameterList * SOAP_FMAC6 soap_new_ns__ParameterList(struct soap *soap, int n)
{	return soap_instantiate_ns__ParameterList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ParameterList(struct soap *soap, ns__ParameterList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__ParameterList * SOAP_FMAC4 soap_instantiate_ns__ParameterList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ParameterList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ParameterList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__ParameterList;
		if (size)
			*size = sizeof(ns__ParameterList);
	}
	else
	{	cp->ptr = (void*)new ns__ParameterList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__ParameterList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__ParameterList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ParameterList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__ParameterList %p -> %p\n", q, p));
	*(ns__ParameterList*)p = *(ns__ParameterList*)q;
}

void ns__InputInfoArray::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__InputInfoArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__InputInfoArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__TaggedInputInfo);
			soap_serialize_ns__TaggedInputInfo(soap, this->__ptr + i);
		}
}

int ns__InputInfoArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__InputInfoArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__InputInfoArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__InputInfoArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__InputInfoArray(struct soap *soap, const char *tag, int id, const ns__InputInfoArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__InputInfoArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__TaggedInputInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__InputInfoArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__InputInfoArray(soap, this, tag, type);
}

SOAP_FMAC3 ns__InputInfoArray * SOAP_FMAC4 soap_get_ns__InputInfoArray(struct soap *soap, ns__InputInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__InputInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__InputInfoArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__InputInfoArray(soap, tag, this, type);
}

SOAP_FMAC3 ns__InputInfoArray * SOAP_FMAC4 soap_in_ns__InputInfoArray(struct soap *soap, const char *tag, ns__InputInfoArray *a, const char *type)
{	int i, j;
	struct ns__TaggedInputInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:TaggedInputInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__InputInfoArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__InputInfoArray, sizeof(ns__InputInfoArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__TaggedInputInfo *)soap_malloc(soap, sizeof(struct ns__TaggedInputInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__TaggedInputInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__TaggedInputInfo(soap, NULL, a->__ptr + i, "ns:TaggedInputInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__TaggedInputInfo *)soap_push_block(soap, NULL, sizeof(struct ns__TaggedInputInfo));
				if (!p)
					return NULL;
				soap_default_ns__TaggedInputInfo(soap, p);
				if (!soap_in_ns__TaggedInputInfo(soap, NULL, p, "ns:TaggedInputInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__TaggedInputInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__InputInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__InputInfoArray, 0, sizeof(ns__InputInfoArray), 0, soap_copy_ns__InputInfoArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__InputInfoArray * SOAP_FMAC6 soap_new_ns__InputInfoArray(struct soap *soap, int n)
{	return soap_instantiate_ns__InputInfoArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__InputInfoArray(struct soap *soap, ns__InputInfoArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__InputInfoArray * SOAP_FMAC4 soap_instantiate_ns__InputInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__InputInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__InputInfoArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__InputInfoArray;
		if (size)
			*size = sizeof(ns__InputInfoArray);
	}
	else
	{	cp->ptr = (void*)new ns__InputInfoArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__InputInfoArray);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__InputInfoArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__InputInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__InputInfoArray %p -> %p\n", q, p));
	*(ns__InputInfoArray*)p = *(ns__InputInfoArray*)q;
}

void ns__BoardInfoArray::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void ns__BoardInfoArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ns__BoardInfoArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns__TaggedBoardInfo);
			soap_serialize_ns__TaggedBoardInfo(soap, this->__ptr + i);
		}
}

int ns__BoardInfoArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ns__BoardInfoArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__BoardInfoArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ns__BoardInfoArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__BoardInfoArray(struct soap *soap, const char *tag, int id, const ns__BoardInfoArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__BoardInfoArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__TaggedBoardInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

void *ns__BoardInfoArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__BoardInfoArray(soap, this, tag, type);
}

SOAP_FMAC3 ns__BoardInfoArray * SOAP_FMAC4 soap_get_ns__BoardInfoArray(struct soap *soap, ns__BoardInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__BoardInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__BoardInfoArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__BoardInfoArray(soap, tag, this, type);
}

SOAP_FMAC3 ns__BoardInfoArray * SOAP_FMAC4 soap_in_ns__BoardInfoArray(struct soap *soap, const char *tag, ns__BoardInfoArray *a, const char *type)
{	int i, j;
	struct ns__TaggedBoardInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:TaggedBoardInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ns__BoardInfoArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__BoardInfoArray, sizeof(ns__BoardInfoArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__TaggedBoardInfo *)soap_malloc(soap, sizeof(struct ns__TaggedBoardInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__TaggedBoardInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__TaggedBoardInfo(soap, NULL, a->__ptr + i, "ns:TaggedBoardInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__TaggedBoardInfo *)soap_push_block(soap, NULL, sizeof(struct ns__TaggedBoardInfo));
				if (!p)
					return NULL;
				soap_default_ns__TaggedBoardInfo(soap, p);
				if (!soap_in_ns__TaggedBoardInfo(soap, NULL, p, "ns:TaggedBoardInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__TaggedBoardInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__BoardInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__BoardInfoArray, 0, sizeof(ns__BoardInfoArray), 0, soap_copy_ns__BoardInfoArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__BoardInfoArray * SOAP_FMAC6 soap_new_ns__BoardInfoArray(struct soap *soap, int n)
{	return soap_instantiate_ns__BoardInfoArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__BoardInfoArray(struct soap *soap, ns__BoardInfoArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__BoardInfoArray * SOAP_FMAC4 soap_instantiate_ns__BoardInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__BoardInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__BoardInfoArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__BoardInfoArray;
		if (size)
			*size = sizeof(ns__BoardInfoArray);
	}
	else
	{	cp->ptr = (void*)new ns__BoardInfoArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__BoardInfoArray);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__BoardInfoArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__BoardInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__BoardInfoArray %p -> %p\n", q, p));
	*(ns__BoardInfoArray*)p = *(ns__BoardInfoArray*)q;
}

void ns__DeviceInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &this->ns__DeviceInfo::deviceID);
	soap_default_int(soap, &this->ns__DeviceInfo::serverSoftwareVersion);
	soap_default_bool(soap, &this->ns__DeviceInfo::simulatedHardware);
	soap_default_string(soap, &this->ns__DeviceInfo::deviceName);
	soap_default_string(soap, &this->ns__DeviceInfo::DeviceDescription);
	soap_default_bool(soap, &this->ns__DeviceInfo::UseLocalTime);
	soap_default_bool(soap, &this->ns__DeviceInfo::AutoStartMeasurement);
	soap_default_bool(soap, &this->ns__DeviceInfo::AutoStartAutosequence);
	soap_default_int(soap, &this->ns__DeviceInfo::ServerPort);
	soap_default_int(soap, &this->ns__DeviceInfo::ServerPortTwoinOne);
	soap_default_int(soap, &this->ns__DeviceInfo::TargetPort);
	soap_default_bool(soap, &this->ns__DeviceInfo::TwoInOne);
	soap_default_string(soap, &this->ns__DeviceInfo::TwoInOnepassword);
	soap_default_string(soap, &this->ns__DeviceInfo::DataFileName);
	soap_default_int(soap, &this->ns__DeviceInfo::NumberOfBackupFiles);
	soap_default_int(soap, &this->ns__DeviceInfo::HdFlushInterval);
	soap_default_bool(soap, &this->ns__DeviceInfo::WriteTroughCache);
	soap_default_int(soap, &this->ns__DeviceInfo::ModelType);
	soap_default_int(soap, &this->ns__DeviceInfo::SyncLinkDetected);
}

void ns__DeviceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns__DeviceInfo::deviceID, SOAP_TYPE_unsignedLONG64);
	soap_serialize_string(soap, &this->ns__DeviceInfo::deviceName);
	soap_serialize_string(soap, &this->ns__DeviceInfo::DeviceDescription);
	soap_serialize_string(soap, &this->ns__DeviceInfo::TwoInOnepassword);
	soap_serialize_string(soap, &this->ns__DeviceInfo::DataFileName);
}

int ns__DeviceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__DeviceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__DeviceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceInfo(struct soap *soap, const char *tag, int id, const ns__DeviceInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceInfo), type))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "deviceID", -1, &(a->ns__DeviceInfo::deviceID), ""))
		return soap->error;
	if (soap_out_int(soap, "serverSoftwareVersion", -1, &(a->ns__DeviceInfo::serverSoftwareVersion), ""))
		return soap->error;
	if (soap_out_bool(soap, "simulatedHardware", -1, &(a->ns__DeviceInfo::simulatedHardware), ""))
		return soap->error;
	if (soap_out_string(soap, "deviceName", -1, &(a->ns__DeviceInfo::deviceName), ""))
		return soap->error;
	if (soap_out_string(soap, "DeviceDescription", -1, &(a->ns__DeviceInfo::DeviceDescription), ""))
		return soap->error;
	if (soap_out_bool(soap, "UseLocalTime", -1, &(a->ns__DeviceInfo::UseLocalTime), ""))
		return soap->error;
	if (soap_out_bool(soap, "AutoStartMeasurement", -1, &(a->ns__DeviceInfo::AutoStartMeasurement), ""))
		return soap->error;
	if (soap_out_bool(soap, "AutoStartAutosequence", -1, &(a->ns__DeviceInfo::AutoStartAutosequence), ""))
		return soap->error;
	if (soap_out_int(soap, "ServerPort", -1, &(a->ns__DeviceInfo::ServerPort), ""))
		return soap->error;
	if (soap_out_int(soap, "ServerPortTwoinOne", -1, &(a->ns__DeviceInfo::ServerPortTwoinOne), ""))
		return soap->error;
	if (soap_out_int(soap, "TargetPort", -1, &(a->ns__DeviceInfo::TargetPort), ""))
		return soap->error;
	if (soap_out_bool(soap, "TwoInOne", -1, &(a->ns__DeviceInfo::TwoInOne), ""))
		return soap->error;
	if (soap_out_string(soap, "TwoInOnepassword", -1, &(a->ns__DeviceInfo::TwoInOnepassword), ""))
		return soap->error;
	if (soap_out_string(soap, "DataFileName", -1, &(a->ns__DeviceInfo::DataFileName), ""))
		return soap->error;
	if (soap_out_int(soap, "NumberOfBackupFiles", -1, &(a->ns__DeviceInfo::NumberOfBackupFiles), ""))
		return soap->error;
	if (soap_out_int(soap, "HdFlushInterval", -1, &(a->ns__DeviceInfo::HdFlushInterval), ""))
		return soap->error;
	if (soap_out_bool(soap, "WriteTroughCache", -1, &(a->ns__DeviceInfo::WriteTroughCache), ""))
		return soap->error;
	if (soap_out_int(soap, "ModelType", -1, &(a->ns__DeviceInfo::ModelType), ""))
		return soap->error;
	if (soap_out_int(soap, "SyncLinkDetected", -1, &(a->ns__DeviceInfo::SyncLinkDetected), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceInfo * SOAP_FMAC4 soap_get_ns__DeviceInfo(struct soap *soap, ns__DeviceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns__DeviceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceInfo * SOAP_FMAC4 soap_in_ns__DeviceInfo(struct soap *soap, const char *tag, ns__DeviceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceInfo, sizeof(ns__DeviceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__DeviceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__DeviceInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_deviceID1 = 1;
	size_t soap_flag_serverSoftwareVersion1 = 1;
	size_t soap_flag_simulatedHardware1 = 1;
	size_t soap_flag_deviceName1 = 1;
	size_t soap_flag_DeviceDescription1 = 1;
	size_t soap_flag_UseLocalTime1 = 1;
	size_t soap_flag_AutoStartMeasurement1 = 1;
	size_t soap_flag_AutoStartAutosequence1 = 1;
	size_t soap_flag_ServerPort1 = 1;
	size_t soap_flag_ServerPortTwoinOne1 = 1;
	size_t soap_flag_TargetPort1 = 1;
	size_t soap_flag_TwoInOne1 = 1;
	size_t soap_flag_TwoInOnepassword1 = 1;
	size_t soap_flag_DataFileName1 = 1;
	size_t soap_flag_NumberOfBackupFiles1 = 1;
	size_t soap_flag_HdFlushInterval1 = 1;
	size_t soap_flag_WriteTroughCache1 = 1;
	size_t soap_flag_ModelType1 = 1;
	size_t soap_flag_SyncLinkDetected1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "deviceID", &(a->ns__DeviceInfo::deviceID), "xsd:unsignedLong"))
				{	soap_flag_deviceID1--;
					continue;
				}
			if (soap_flag_serverSoftwareVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "serverSoftwareVersion", &(a->ns__DeviceInfo::serverSoftwareVersion), "xsd:int"))
				{	soap_flag_serverSoftwareVersion1--;
					continue;
				}
			if (soap_flag_simulatedHardware1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "simulatedHardware", &(a->ns__DeviceInfo::simulatedHardware), "xsd:boolean"))
				{	soap_flag_simulatedHardware1--;
					continue;
				}
			if (soap_flag_deviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "deviceName", &(a->ns__DeviceInfo::deviceName), "xsd:string"))
				{	soap_flag_deviceName1--;
					continue;
				}
			if (soap_flag_DeviceDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DeviceDescription", &(a->ns__DeviceInfo::DeviceDescription), "xsd:string"))
				{	soap_flag_DeviceDescription1--;
					continue;
				}
			if (soap_flag_UseLocalTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "UseLocalTime", &(a->ns__DeviceInfo::UseLocalTime), "xsd:boolean"))
				{	soap_flag_UseLocalTime1--;
					continue;
				}
			if (soap_flag_AutoStartMeasurement1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "AutoStartMeasurement", &(a->ns__DeviceInfo::AutoStartMeasurement), "xsd:boolean"))
				{	soap_flag_AutoStartMeasurement1--;
					continue;
				}
			if (soap_flag_AutoStartAutosequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "AutoStartAutosequence", &(a->ns__DeviceInfo::AutoStartAutosequence), "xsd:boolean"))
				{	soap_flag_AutoStartAutosequence1--;
					continue;
				}
			if (soap_flag_ServerPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ServerPort", &(a->ns__DeviceInfo::ServerPort), "xsd:int"))
				{	soap_flag_ServerPort1--;
					continue;
				}
			if (soap_flag_ServerPortTwoinOne1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ServerPortTwoinOne", &(a->ns__DeviceInfo::ServerPortTwoinOne), "xsd:int"))
				{	soap_flag_ServerPortTwoinOne1--;
					continue;
				}
			if (soap_flag_TargetPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TargetPort", &(a->ns__DeviceInfo::TargetPort), "xsd:int"))
				{	soap_flag_TargetPort1--;
					continue;
				}
			if (soap_flag_TwoInOne1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "TwoInOne", &(a->ns__DeviceInfo::TwoInOne), "xsd:boolean"))
				{	soap_flag_TwoInOne1--;
					continue;
				}
			if (soap_flag_TwoInOnepassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TwoInOnepassword", &(a->ns__DeviceInfo::TwoInOnepassword), "xsd:string"))
				{	soap_flag_TwoInOnepassword1--;
					continue;
				}
			if (soap_flag_DataFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DataFileName", &(a->ns__DeviceInfo::DataFileName), "xsd:string"))
				{	soap_flag_DataFileName1--;
					continue;
				}
			if (soap_flag_NumberOfBackupFiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "NumberOfBackupFiles", &(a->ns__DeviceInfo::NumberOfBackupFiles), "xsd:int"))
				{	soap_flag_NumberOfBackupFiles1--;
					continue;
				}
			if (soap_flag_HdFlushInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "HdFlushInterval", &(a->ns__DeviceInfo::HdFlushInterval), "xsd:int"))
				{	soap_flag_HdFlushInterval1--;
					continue;
				}
			if (soap_flag_WriteTroughCache1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "WriteTroughCache", &(a->ns__DeviceInfo::WriteTroughCache), "xsd:boolean"))
				{	soap_flag_WriteTroughCache1--;
					continue;
				}
			if (soap_flag_ModelType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ModelType", &(a->ns__DeviceInfo::ModelType), "xsd:int"))
				{	soap_flag_ModelType1--;
					continue;
				}
			if (soap_flag_SyncLinkDetected1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "SyncLinkDetected", &(a->ns__DeviceInfo::SyncLinkDetected), "xsd:int"))
				{	soap_flag_SyncLinkDetected1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__DeviceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceInfo, 0, sizeof(ns__DeviceInfo), 0, soap_copy_ns__DeviceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID1 > 0 || soap_flag_serverSoftwareVersion1 > 0 || soap_flag_simulatedHardware1 > 0 || soap_flag_UseLocalTime1 > 0 || soap_flag_AutoStartMeasurement1 > 0 || soap_flag_AutoStartAutosequence1 > 0 || soap_flag_ServerPort1 > 0 || soap_flag_ServerPortTwoinOne1 > 0 || soap_flag_TargetPort1 > 0 || soap_flag_TwoInOne1 > 0 || soap_flag_NumberOfBackupFiles1 > 0 || soap_flag_HdFlushInterval1 > 0 || soap_flag_WriteTroughCache1 > 0 || soap_flag_ModelType1 > 0 || soap_flag_SyncLinkDetected1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__DeviceInfo * SOAP_FMAC6 soap_new_ns__DeviceInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__DeviceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DeviceInfo(struct soap *soap, ns__DeviceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__DeviceInfo * SOAP_FMAC4 soap_instantiate_ns__DeviceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DeviceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__DeviceInfo;
		if (size)
			*size = sizeof(ns__DeviceInfo);
	}
	else
	{	cp->ptr = (void*)new ns__DeviceInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns__DeviceInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__DeviceInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DeviceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__DeviceInfo %p -> %p\n", q, p));
	*(ns__DeviceInfo*)p = *(ns__DeviceInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetMACAddress(struct soap *soap, struct ns__GetMACAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetMACAddress(struct soap *soap, const struct ns__GetMACAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->IPAddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetMACAddress(struct soap *soap, const struct ns__GetMACAddress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetMACAddress);
	if (soap_out_ns__GetMACAddress(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetMACAddress(struct soap *soap, const char *tag, int id, const struct ns__GetMACAddress *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetMACAddress), type))
		return soap->error;
	if (soap_out_string(soap, "IPAddress", -1, &a->IPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetMACAddress * SOAP_FMAC4 soap_get_ns__GetMACAddress(struct soap *soap, struct ns__GetMACAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetMACAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetMACAddress * SOAP_FMAC4 soap_in_ns__GetMACAddress(struct soap *soap, const char *tag, struct ns__GetMACAddress *a, const char *type)
{
	size_t soap_flag_IPAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetMACAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetMACAddress, sizeof(struct ns__GetMACAddress), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetMACAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "IPAddress", &a->IPAddress, "xsd:string"))
				{	soap_flag_IPAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetMACAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetMACAddress, 0, sizeof(struct ns__GetMACAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetMACAddress * SOAP_FMAC6 soap_new_ns__GetMACAddress(struct soap *soap, int n)
{	return soap_instantiate_ns__GetMACAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetMACAddress(struct soap *soap, struct ns__GetMACAddress *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetMACAddress * SOAP_FMAC4 soap_instantiate_ns__GetMACAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetMACAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetMACAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetMACAddress;
		if (size)
			*size = sizeof(struct ns__GetMACAddress);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetMACAddress[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetMACAddress);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetMACAddress*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetMACAddress(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetMACAddress %p -> %p\n", q, p));
	*(struct ns__GetMACAddress*)p = *(struct ns__GetMACAddress*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetMACAddressResponse(struct soap *soap, struct ns__GetMACAddressResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &a->MACAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetMACAddressResponse(struct soap *soap, const struct ns__GetMACAddressResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->MACAddress, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetMACAddressResponse(struct soap *soap, const struct ns__GetMACAddressResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetMACAddressResponse);
	if (soap_out_ns__GetMACAddressResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetMACAddressResponse(struct soap *soap, const char *tag, int id, const struct ns__GetMACAddressResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetMACAddressResponse), type))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "MACAddress", -1, &a->MACAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetMACAddressResponse * SOAP_FMAC4 soap_get_ns__GetMACAddressResponse(struct soap *soap, struct ns__GetMACAddressResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetMACAddressResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetMACAddressResponse * SOAP_FMAC4 soap_in_ns__GetMACAddressResponse(struct soap *soap, const char *tag, struct ns__GetMACAddressResponse *a, const char *type)
{
	size_t soap_flag_MACAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetMACAddressResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetMACAddressResponse, sizeof(struct ns__GetMACAddressResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetMACAddressResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MACAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "MACAddress", &a->MACAddress, "xsd:unsignedLong"))
				{	soap_flag_MACAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetMACAddressResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetMACAddressResponse, 0, sizeof(struct ns__GetMACAddressResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MACAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetMACAddressResponse * SOAP_FMAC6 soap_new_ns__GetMACAddressResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetMACAddressResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetMACAddressResponse(struct soap *soap, struct ns__GetMACAddressResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetMACAddressResponse * SOAP_FMAC4 soap_instantiate_ns__GetMACAddressResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetMACAddressResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetMACAddressResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetMACAddressResponse;
		if (size)
			*size = sizeof(struct ns__GetMACAddressResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetMACAddressResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetMACAddressResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetMACAddressResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetMACAddressResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetMACAddressResponse %p -> %p\n", q, p));
	*(struct ns__GetMACAddressResponse*)p = *(struct ns__GetMACAddressResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetFreeDiskSpace(struct soap *soap, struct ns__GetFreeDiskSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetFreeDiskSpace(struct soap *soap, const struct ns__GetFreeDiskSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetFreeDiskSpace(struct soap *soap, const struct ns__GetFreeDiskSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetFreeDiskSpace);
	if (soap_out_ns__GetFreeDiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetFreeDiskSpace(struct soap *soap, const char *tag, int id, const struct ns__GetFreeDiskSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetFreeDiskSpace), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetFreeDiskSpace * SOAP_FMAC4 soap_get_ns__GetFreeDiskSpace(struct soap *soap, struct ns__GetFreeDiskSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetFreeDiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetFreeDiskSpace * SOAP_FMAC4 soap_in_ns__GetFreeDiskSpace(struct soap *soap, const char *tag, struct ns__GetFreeDiskSpace *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetFreeDiskSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetFreeDiskSpace, sizeof(struct ns__GetFreeDiskSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetFreeDiskSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetFreeDiskSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetFreeDiskSpace, 0, sizeof(struct ns__GetFreeDiskSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetFreeDiskSpace * SOAP_FMAC6 soap_new_ns__GetFreeDiskSpace(struct soap *soap, int n)
{	return soap_instantiate_ns__GetFreeDiskSpace(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetFreeDiskSpace(struct soap *soap, struct ns__GetFreeDiskSpace *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetFreeDiskSpace * SOAP_FMAC4 soap_instantiate_ns__GetFreeDiskSpace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetFreeDiskSpace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetFreeDiskSpace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetFreeDiskSpace;
		if (size)
			*size = sizeof(struct ns__GetFreeDiskSpace);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetFreeDiskSpace[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetFreeDiskSpace);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetFreeDiskSpace*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetFreeDiskSpace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetFreeDiskSpace %p -> %p\n", q, p));
	*(struct ns__GetFreeDiskSpace*)p = *(struct ns__GetFreeDiskSpace*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceSettings(struct soap *soap, struct ns__SetDeviceSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Settings.ns__DeviceInfo::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceSettings(struct soap *soap, const struct ns__SetDeviceSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Settings.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceSettings(struct soap *soap, const struct ns__SetDeviceSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetDeviceSettings);
	if (soap_out_ns__SetDeviceSettings(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceSettings(struct soap *soap, const char *tag, int id, const struct ns__SetDeviceSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetDeviceSettings), type))
		return soap->error;
	if (a->Settings.soap_out(soap, "Settings", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetDeviceSettings * SOAP_FMAC4 soap_get_ns__SetDeviceSettings(struct soap *soap, struct ns__SetDeviceSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetDeviceSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetDeviceSettings * SOAP_FMAC4 soap_in_ns__SetDeviceSettings(struct soap *soap, const char *tag, struct ns__SetDeviceSettings *a, const char *type)
{
	size_t soap_flag_Settings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetDeviceSettings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetDeviceSettings, sizeof(struct ns__SetDeviceSettings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__SetDeviceSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Settings && soap->error == SOAP_TAG_MISMATCH)
				if (a->Settings.soap_in(soap, "Settings", "ns:DeviceInfo"))
				{	soap_flag_Settings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetDeviceSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetDeviceSettings, 0, sizeof(struct ns__SetDeviceSettings), 0, soap_copy_ns__SetDeviceSettings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Settings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetDeviceSettings * SOAP_FMAC6 soap_new_ns__SetDeviceSettings(struct soap *soap, int n)
{	return soap_instantiate_ns__SetDeviceSettings(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetDeviceSettings(struct soap *soap, struct ns__SetDeviceSettings *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetDeviceSettings * SOAP_FMAC4 soap_instantiate_ns__SetDeviceSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetDeviceSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetDeviceSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetDeviceSettings;
		if (size)
			*size = sizeof(struct ns__SetDeviceSettings);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetDeviceSettings[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetDeviceSettings);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetDeviceSettings*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetDeviceSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetDeviceSettings %p -> %p\n", q, p));
	*(struct ns__SetDeviceSettings*)p = *(struct ns__SetDeviceSettings*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAutoSequence(struct soap *soap, struct ns__GetAutoSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAutoSequence(struct soap *soap, const struct ns__GetAutoSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAutoSequence(struct soap *soap, const struct ns__GetAutoSequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAutoSequence);
	if (soap_out_ns__GetAutoSequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAutoSequence(struct soap *soap, const char *tag, int id, const struct ns__GetAutoSequence *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAutoSequence), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAutoSequence * SOAP_FMAC4 soap_get_ns__GetAutoSequence(struct soap *soap, struct ns__GetAutoSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAutoSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAutoSequence * SOAP_FMAC4 soap_in_ns__GetAutoSequence(struct soap *soap, const char *tag, struct ns__GetAutoSequence *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAutoSequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAutoSequence, sizeof(struct ns__GetAutoSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAutoSequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAutoSequence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAutoSequence, 0, sizeof(struct ns__GetAutoSequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAutoSequence * SOAP_FMAC6 soap_new_ns__GetAutoSequence(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAutoSequence(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAutoSequence(struct soap *soap, struct ns__GetAutoSequence *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAutoSequence * SOAP_FMAC4 soap_instantiate_ns__GetAutoSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAutoSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAutoSequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAutoSequence;
		if (size)
			*size = sizeof(struct ns__GetAutoSequence);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAutoSequence[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAutoSequence);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAutoSequence*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAutoSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAutoSequence %p -> %p\n", q, p));
	*(struct ns__GetAutoSequence*)p = *(struct ns__GetAutoSequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAutoSequenceResponse(struct soap *soap, struct ns__GetAutoSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.ns__AutoSequence::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAutoSequenceResponse(struct soap *soap, const struct ns__GetAutoSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAutoSequenceResponse(struct soap *soap, const struct ns__GetAutoSequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAutoSequenceResponse);
	if (soap_out_ns__GetAutoSequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAutoSequenceResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAutoSequenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAutoSequenceResponse), type))
		return soap->error;
	if (a->result.soap_out(soap, "result", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAutoSequenceResponse * SOAP_FMAC4 soap_get_ns__GetAutoSequenceResponse(struct soap *soap, struct ns__GetAutoSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAutoSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAutoSequenceResponse * SOAP_FMAC4 soap_in_ns__GetAutoSequenceResponse(struct soap *soap, const char *tag, struct ns__GetAutoSequenceResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAutoSequenceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAutoSequenceResponse, sizeof(struct ns__GetAutoSequenceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetAutoSequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (a->result.soap_in(soap, "result", "ns:AutoSequence"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAutoSequenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAutoSequenceResponse, 0, sizeof(struct ns__GetAutoSequenceResponse), 0, soap_copy_ns__GetAutoSequenceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAutoSequenceResponse * SOAP_FMAC6 soap_new_ns__GetAutoSequenceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAutoSequenceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAutoSequenceResponse(struct soap *soap, struct ns__GetAutoSequenceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAutoSequenceResponse * SOAP_FMAC4 soap_instantiate_ns__GetAutoSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAutoSequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAutoSequenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAutoSequenceResponse;
		if (size)
			*size = sizeof(struct ns__GetAutoSequenceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAutoSequenceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAutoSequenceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAutoSequenceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAutoSequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAutoSequenceResponse %p -> %p\n", q, p));
	*(struct ns__GetAutoSequenceResponse*)p = *(struct ns__GetAutoSequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__StopAutoSequence(struct soap *soap, struct ns__StopAutoSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__StopAutoSequence(struct soap *soap, const struct ns__StopAutoSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__StopAutoSequence(struct soap *soap, const struct ns__StopAutoSequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__StopAutoSequence);
	if (soap_out_ns__StopAutoSequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__StopAutoSequence(struct soap *soap, const char *tag, int id, const struct ns__StopAutoSequence *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__StopAutoSequence), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__StopAutoSequence * SOAP_FMAC4 soap_get_ns__StopAutoSequence(struct soap *soap, struct ns__StopAutoSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__StopAutoSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__StopAutoSequence * SOAP_FMAC4 soap_in_ns__StopAutoSequence(struct soap *soap, const char *tag, struct ns__StopAutoSequence *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__StopAutoSequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__StopAutoSequence, sizeof(struct ns__StopAutoSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__StopAutoSequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__StopAutoSequence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__StopAutoSequence, 0, sizeof(struct ns__StopAutoSequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__StopAutoSequence * SOAP_FMAC6 soap_new_ns__StopAutoSequence(struct soap *soap, int n)
{	return soap_instantiate_ns__StopAutoSequence(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__StopAutoSequence(struct soap *soap, struct ns__StopAutoSequence *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__StopAutoSequence * SOAP_FMAC4 soap_instantiate_ns__StopAutoSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__StopAutoSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__StopAutoSequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__StopAutoSequence;
		if (size)
			*size = sizeof(struct ns__StopAutoSequence);
	}
	else
	{	cp->ptr = (void*)new struct ns__StopAutoSequence[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__StopAutoSequence);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__StopAutoSequence*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__StopAutoSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__StopAutoSequence %p -> %p\n", q, p));
	*(struct ns__StopAutoSequence*)p = *(struct ns__StopAutoSequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__StopAutoSequenceResponse(struct soap *soap, struct ns__StopAutoSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__StopAutoSequenceResponse(struct soap *soap, const struct ns__StopAutoSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__StopAutoSequenceResponse(struct soap *soap, const struct ns__StopAutoSequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__StopAutoSequenceResponse);
	if (soap_out_ns__StopAutoSequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__StopAutoSequenceResponse(struct soap *soap, const char *tag, int id, const struct ns__StopAutoSequenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__StopAutoSequenceResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__StopAutoSequenceResponse * SOAP_FMAC4 soap_get_ns__StopAutoSequenceResponse(struct soap *soap, struct ns__StopAutoSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__StopAutoSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__StopAutoSequenceResponse * SOAP_FMAC4 soap_in_ns__StopAutoSequenceResponse(struct soap *soap, const char *tag, struct ns__StopAutoSequenceResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__StopAutoSequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__StopAutoSequenceResponse, sizeof(struct ns__StopAutoSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__StopAutoSequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__StopAutoSequenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__StopAutoSequenceResponse, 0, sizeof(struct ns__StopAutoSequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__StopAutoSequenceResponse * SOAP_FMAC6 soap_new_ns__StopAutoSequenceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__StopAutoSequenceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__StopAutoSequenceResponse(struct soap *soap, struct ns__StopAutoSequenceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__StopAutoSequenceResponse * SOAP_FMAC4 soap_instantiate_ns__StopAutoSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__StopAutoSequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__StopAutoSequenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__StopAutoSequenceResponse;
		if (size)
			*size = sizeof(struct ns__StopAutoSequenceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__StopAutoSequenceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__StopAutoSequenceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__StopAutoSequenceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__StopAutoSequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__StopAutoSequenceResponse %p -> %p\n", q, p));
	*(struct ns__StopAutoSequenceResponse*)p = *(struct ns__StopAutoSequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__StartAutoSequence(struct soap *soap, struct ns__StartAutoSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__StartAutoSequence(struct soap *soap, const struct ns__StartAutoSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__StartAutoSequence(struct soap *soap, const struct ns__StartAutoSequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__StartAutoSequence);
	if (soap_out_ns__StartAutoSequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__StartAutoSequence(struct soap *soap, const char *tag, int id, const struct ns__StartAutoSequence *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__StartAutoSequence), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__StartAutoSequence * SOAP_FMAC4 soap_get_ns__StartAutoSequence(struct soap *soap, struct ns__StartAutoSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__StartAutoSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__StartAutoSequence * SOAP_FMAC4 soap_in_ns__StartAutoSequence(struct soap *soap, const char *tag, struct ns__StartAutoSequence *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__StartAutoSequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__StartAutoSequence, sizeof(struct ns__StartAutoSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__StartAutoSequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__StartAutoSequence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__StartAutoSequence, 0, sizeof(struct ns__StartAutoSequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__StartAutoSequence * SOAP_FMAC6 soap_new_ns__StartAutoSequence(struct soap *soap, int n)
{	return soap_instantiate_ns__StartAutoSequence(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__StartAutoSequence(struct soap *soap, struct ns__StartAutoSequence *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__StartAutoSequence * SOAP_FMAC4 soap_instantiate_ns__StartAutoSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__StartAutoSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__StartAutoSequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__StartAutoSequence;
		if (size)
			*size = sizeof(struct ns__StartAutoSequence);
	}
	else
	{	cp->ptr = (void*)new struct ns__StartAutoSequence[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__StartAutoSequence);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__StartAutoSequence*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__StartAutoSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__StartAutoSequence %p -> %p\n", q, p));
	*(struct ns__StartAutoSequence*)p = *(struct ns__StartAutoSequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__StartAutoSequenceResponse(struct soap *soap, struct ns__StartAutoSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__StartAutoSequenceResponse(struct soap *soap, const struct ns__StartAutoSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__StartAutoSequenceResponse(struct soap *soap, const struct ns__StartAutoSequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__StartAutoSequenceResponse);
	if (soap_out_ns__StartAutoSequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__StartAutoSequenceResponse(struct soap *soap, const char *tag, int id, const struct ns__StartAutoSequenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__StartAutoSequenceResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__StartAutoSequenceResponse * SOAP_FMAC4 soap_get_ns__StartAutoSequenceResponse(struct soap *soap, struct ns__StartAutoSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__StartAutoSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__StartAutoSequenceResponse * SOAP_FMAC4 soap_in_ns__StartAutoSequenceResponse(struct soap *soap, const char *tag, struct ns__StartAutoSequenceResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__StartAutoSequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__StartAutoSequenceResponse, sizeof(struct ns__StartAutoSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__StartAutoSequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__StartAutoSequenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__StartAutoSequenceResponse, 0, sizeof(struct ns__StartAutoSequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__StartAutoSequenceResponse * SOAP_FMAC6 soap_new_ns__StartAutoSequenceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__StartAutoSequenceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__StartAutoSequenceResponse(struct soap *soap, struct ns__StartAutoSequenceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__StartAutoSequenceResponse * SOAP_FMAC4 soap_instantiate_ns__StartAutoSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__StartAutoSequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__StartAutoSequenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__StartAutoSequenceResponse;
		if (size)
			*size = sizeof(struct ns__StartAutoSequenceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__StartAutoSequenceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__StartAutoSequenceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__StartAutoSequenceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__StartAutoSequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__StartAutoSequenceResponse %p -> %p\n", q, p));
	*(struct ns__StartAutoSequenceResponse*)p = *(struct ns__StartAutoSequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__LoadAutosequence(struct soap *soap, struct ns__LoadAutosequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sequence.ns__AutoSequence::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__LoadAutosequence(struct soap *soap, const struct ns__LoadAutosequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sequence.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__LoadAutosequence(struct soap *soap, const struct ns__LoadAutosequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__LoadAutosequence);
	if (soap_out_ns__LoadAutosequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__LoadAutosequence(struct soap *soap, const char *tag, int id, const struct ns__LoadAutosequence *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__LoadAutosequence), type))
		return soap->error;
	if (a->Sequence.soap_out(soap, "Sequence", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__LoadAutosequence * SOAP_FMAC4 soap_get_ns__LoadAutosequence(struct soap *soap, struct ns__LoadAutosequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__LoadAutosequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__LoadAutosequence * SOAP_FMAC4 soap_in_ns__LoadAutosequence(struct soap *soap, const char *tag, struct ns__LoadAutosequence *a, const char *type)
{
	size_t soap_flag_Sequence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__LoadAutosequence *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__LoadAutosequence, sizeof(struct ns__LoadAutosequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__LoadAutosequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sequence && soap->error == SOAP_TAG_MISMATCH)
				if (a->Sequence.soap_in(soap, "Sequence", "ns:AutoSequence"))
				{	soap_flag_Sequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__LoadAutosequence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__LoadAutosequence, 0, sizeof(struct ns__LoadAutosequence), 0, soap_copy_ns__LoadAutosequence);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Sequence > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__LoadAutosequence * SOAP_FMAC6 soap_new_ns__LoadAutosequence(struct soap *soap, int n)
{	return soap_instantiate_ns__LoadAutosequence(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__LoadAutosequence(struct soap *soap, struct ns__LoadAutosequence *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__LoadAutosequence * SOAP_FMAC4 soap_instantiate_ns__LoadAutosequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__LoadAutosequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__LoadAutosequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__LoadAutosequence;
		if (size)
			*size = sizeof(struct ns__LoadAutosequence);
	}
	else
	{	cp->ptr = (void*)new struct ns__LoadAutosequence[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__LoadAutosequence);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__LoadAutosequence*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__LoadAutosequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__LoadAutosequence %p -> %p\n", q, p));
	*(struct ns__LoadAutosequence*)p = *(struct ns__LoadAutosequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__LoadAutosequenceResponse(struct soap *soap, struct ns__LoadAutosequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__LoadAutosequenceResponse(struct soap *soap, const struct ns__LoadAutosequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__LoadAutosequenceResponse(struct soap *soap, const struct ns__LoadAutosequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__LoadAutosequenceResponse);
	if (soap_out_ns__LoadAutosequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__LoadAutosequenceResponse(struct soap *soap, const char *tag, int id, const struct ns__LoadAutosequenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__LoadAutosequenceResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__LoadAutosequenceResponse * SOAP_FMAC4 soap_get_ns__LoadAutosequenceResponse(struct soap *soap, struct ns__LoadAutosequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__LoadAutosequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__LoadAutosequenceResponse * SOAP_FMAC4 soap_in_ns__LoadAutosequenceResponse(struct soap *soap, const char *tag, struct ns__LoadAutosequenceResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__LoadAutosequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__LoadAutosequenceResponse, sizeof(struct ns__LoadAutosequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__LoadAutosequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__LoadAutosequenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__LoadAutosequenceResponse, 0, sizeof(struct ns__LoadAutosequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__LoadAutosequenceResponse * SOAP_FMAC6 soap_new_ns__LoadAutosequenceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__LoadAutosequenceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__LoadAutosequenceResponse(struct soap *soap, struct ns__LoadAutosequenceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__LoadAutosequenceResponse * SOAP_FMAC4 soap_instantiate_ns__LoadAutosequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__LoadAutosequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__LoadAutosequenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__LoadAutosequenceResponse;
		if (size)
			*size = sizeof(struct ns__LoadAutosequenceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__LoadAutosequenceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__LoadAutosequenceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__LoadAutosequenceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__LoadAutosequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__LoadAutosequenceResponse %p -> %p\n", q, p));
	*(struct ns__LoadAutosequenceResponse*)p = *(struct ns__LoadAutosequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SendServerCustomCommand(struct soap *soap, struct ns__SendServerCustomCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->command);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SendServerCustomCommand(struct soap *soap, const struct ns__SendServerCustomCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->command);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SendServerCustomCommand(struct soap *soap, const struct ns__SendServerCustomCommand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SendServerCustomCommand);
	if (soap_out_ns__SendServerCustomCommand(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SendServerCustomCommand(struct soap *soap, const char *tag, int id, const struct ns__SendServerCustomCommand *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SendServerCustomCommand), type))
		return soap->error;
	if (soap_out_string(soap, "command", -1, &a->command, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SendServerCustomCommand * SOAP_FMAC4 soap_get_ns__SendServerCustomCommand(struct soap *soap, struct ns__SendServerCustomCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SendServerCustomCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SendServerCustomCommand * SOAP_FMAC4 soap_in_ns__SendServerCustomCommand(struct soap *soap, const char *tag, struct ns__SendServerCustomCommand *a, const char *type)
{
	size_t soap_flag_command = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SendServerCustomCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SendServerCustomCommand, sizeof(struct ns__SendServerCustomCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SendServerCustomCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_command && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "command", &a->command, "xsd:string"))
				{	soap_flag_command--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SendServerCustomCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SendServerCustomCommand, 0, sizeof(struct ns__SendServerCustomCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SendServerCustomCommand * SOAP_FMAC6 soap_new_ns__SendServerCustomCommand(struct soap *soap, int n)
{	return soap_instantiate_ns__SendServerCustomCommand(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SendServerCustomCommand(struct soap *soap, struct ns__SendServerCustomCommand *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SendServerCustomCommand * SOAP_FMAC4 soap_instantiate_ns__SendServerCustomCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SendServerCustomCommand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SendServerCustomCommand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SendServerCustomCommand;
		if (size)
			*size = sizeof(struct ns__SendServerCustomCommand);
	}
	else
	{	cp->ptr = (void*)new struct ns__SendServerCustomCommand[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SendServerCustomCommand);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SendServerCustomCommand*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SendServerCustomCommand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SendServerCustomCommand %p -> %p\n", q, p));
	*(struct ns__SendServerCustomCommand*)p = *(struct ns__SendServerCustomCommand*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SendServerCustomCommandResponse(struct soap *soap, struct ns__SendServerCustomCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SendServerCustomCommandResponse(struct soap *soap, const struct ns__SendServerCustomCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SendServerCustomCommandResponse(struct soap *soap, const struct ns__SendServerCustomCommandResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SendServerCustomCommandResponse);
	if (soap_out_ns__SendServerCustomCommandResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SendServerCustomCommandResponse(struct soap *soap, const char *tag, int id, const struct ns__SendServerCustomCommandResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SendServerCustomCommandResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SendServerCustomCommandResponse * SOAP_FMAC4 soap_get_ns__SendServerCustomCommandResponse(struct soap *soap, struct ns__SendServerCustomCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SendServerCustomCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SendServerCustomCommandResponse * SOAP_FMAC4 soap_in_ns__SendServerCustomCommandResponse(struct soap *soap, const char *tag, struct ns__SendServerCustomCommandResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SendServerCustomCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SendServerCustomCommandResponse, sizeof(struct ns__SendServerCustomCommandResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SendServerCustomCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SendServerCustomCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SendServerCustomCommandResponse, 0, sizeof(struct ns__SendServerCustomCommandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SendServerCustomCommandResponse * SOAP_FMAC6 soap_new_ns__SendServerCustomCommandResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__SendServerCustomCommandResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SendServerCustomCommandResponse(struct soap *soap, struct ns__SendServerCustomCommandResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SendServerCustomCommandResponse * SOAP_FMAC4 soap_instantiate_ns__SendServerCustomCommandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SendServerCustomCommandResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SendServerCustomCommandResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SendServerCustomCommandResponse;
		if (size)
			*size = sizeof(struct ns__SendServerCustomCommandResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__SendServerCustomCommandResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SendServerCustomCommandResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SendServerCustomCommandResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SendServerCustomCommandResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SendServerCustomCommandResponse %p -> %p\n", q, p));
	*(struct ns__SendServerCustomCommandResponse*)p = *(struct ns__SendServerCustomCommandResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DataBlockHeader(struct soap *soap, struct ns__DataBlockHeader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->error);
	soap_default_unsignedInt(soap, &a->numberOfSamples);
	soap_default_int(soap, &a->sampleFormat);
	soap_default_unsignedInt(soap, &a->totalBytes);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DataBlockHeader(struct soap *soap, const struct ns__DataBlockHeader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DataBlockHeader(struct soap *soap, const struct ns__DataBlockHeader *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__DataBlockHeader);
	if (soap_out_ns__DataBlockHeader(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DataBlockHeader(struct soap *soap, const char *tag, int id, const struct ns__DataBlockHeader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DataBlockHeader), type))
		return soap->error;
	if (soap_out_int(soap, "error", -1, &a->error, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "numberOfSamples", -1, &a->numberOfSamples, ""))
		return soap->error;
	if (soap_out_int(soap, "sampleFormat", -1, &a->sampleFormat, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "totalBytes", -1, &a->totalBytes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DataBlockHeader * SOAP_FMAC4 soap_get_ns__DataBlockHeader(struct soap *soap, struct ns__DataBlockHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DataBlockHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__DataBlockHeader * SOAP_FMAC4 soap_in_ns__DataBlockHeader(struct soap *soap, const char *tag, struct ns__DataBlockHeader *a, const char *type)
{
	size_t soap_flag_error = 1;
	size_t soap_flag_numberOfSamples = 1;
	size_t soap_flag_sampleFormat = 1;
	size_t soap_flag_totalBytes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DataBlockHeader *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DataBlockHeader, sizeof(struct ns__DataBlockHeader), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__DataBlockHeader(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "error", &a->error, "xsd:int"))
				{	soap_flag_error--;
					continue;
				}
			if (soap_flag_numberOfSamples && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "numberOfSamples", &a->numberOfSamples, "xsd:unsignedInt"))
				{	soap_flag_numberOfSamples--;
					continue;
				}
			if (soap_flag_sampleFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sampleFormat", &a->sampleFormat, "xsd:int"))
				{	soap_flag_sampleFormat--;
					continue;
				}
			if (soap_flag_totalBytes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "totalBytes", &a->totalBytes, "xsd:unsignedInt"))
				{	soap_flag_totalBytes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__DataBlockHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DataBlockHeader, 0, sizeof(struct ns__DataBlockHeader), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error > 0 || soap_flag_numberOfSamples > 0 || soap_flag_sampleFormat > 0 || soap_flag_totalBytes > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__DataBlockHeader * SOAP_FMAC6 soap_new_ns__DataBlockHeader(struct soap *soap, int n)
{	return soap_instantiate_ns__DataBlockHeader(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DataBlockHeader(struct soap *soap, struct ns__DataBlockHeader *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__DataBlockHeader * SOAP_FMAC4 soap_instantiate_ns__DataBlockHeader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DataBlockHeader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DataBlockHeader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__DataBlockHeader;
		if (size)
			*size = sizeof(struct ns__DataBlockHeader);
	}
	else
	{	cp->ptr = (void*)new struct ns__DataBlockHeader[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__DataBlockHeader);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__DataBlockHeader*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DataBlockHeader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__DataBlockHeader %p -> %p\n", q, p));
	*(struct ns__DataBlockHeader*)p = *(struct ns__DataBlockHeader*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetData(struct soap *soap, struct ns__GetData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->currentMeasurementNumber);
	a->requests.ns__DataSpecificationArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetData(struct soap *soap, const struct ns__GetData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requests.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetData(struct soap *soap, const struct ns__GetData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetData);
	if (soap_out_ns__GetData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetData(struct soap *soap, const char *tag, int id, const struct ns__GetData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetData), type))
		return soap->error;
	if (soap_out_int(soap, "currentMeasurementNumber", -1, &a->currentMeasurementNumber, ""))
		return soap->error;
	if (a->requests.soap_out(soap, "requests", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetData * SOAP_FMAC4 soap_get_ns__GetData(struct soap *soap, struct ns__GetData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetData * SOAP_FMAC4 soap_in_ns__GetData(struct soap *soap, const char *tag, struct ns__GetData *a, const char *type)
{
	size_t soap_flag_currentMeasurementNumber = 1;
	size_t soap_flag_requests = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetData, sizeof(struct ns__GetData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentMeasurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentMeasurementNumber", &a->currentMeasurementNumber, "xsd:int"))
				{	soap_flag_currentMeasurementNumber--;
					continue;
				}
			if (soap_flag_requests && soap->error == SOAP_TAG_MISMATCH)
				if (a->requests.soap_in(soap, "requests", "ns:DataSpecificationArray"))
				{	soap_flag_requests--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetData, 0, sizeof(struct ns__GetData), 0, soap_copy_ns__GetData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentMeasurementNumber > 0 || soap_flag_requests > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetData * SOAP_FMAC6 soap_new_ns__GetData(struct soap *soap, int n)
{	return soap_instantiate_ns__GetData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetData(struct soap *soap, struct ns__GetData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetData * SOAP_FMAC4 soap_instantiate_ns__GetData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetData;
		if (size)
			*size = sizeof(struct ns__GetData);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetData %p -> %p\n", q, p));
	*(struct ns__GetData*)p = *(struct ns__GetData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDataResponse(struct soap *soap, struct ns__GetDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->data.ns__Data::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDataResponse(struct soap *soap, const struct ns__GetDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->data.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDataResponse(struct soap *soap, const struct ns__GetDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetDataResponse);
	if (soap_out_ns__GetDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDataResponse(struct soap *soap, const char *tag, int id, const struct ns__GetDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDataResponse), type))
		return soap->error;
	if (a->data.soap_out(soap, "data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDataResponse * SOAP_FMAC4 soap_get_ns__GetDataResponse(struct soap *soap, struct ns__GetDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetDataResponse * SOAP_FMAC4 soap_in_ns__GetDataResponse(struct soap *soap, const char *tag, struct ns__GetDataResponse *a, const char *type)
{
	size_t soap_flag_data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDataResponse, sizeof(struct ns__GetDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data && soap->error == SOAP_TAG_MISMATCH)
				if (a->data.soap_in(soap, "data", "ns:Data"))
				{	soap_flag_data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDataResponse, 0, sizeof(struct ns__GetDataResponse), 0, soap_copy_ns__GetDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_data > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetDataResponse * SOAP_FMAC6 soap_new_ns__GetDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetDataResponse(struct soap *soap, struct ns__GetDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetDataResponse * SOAP_FMAC4 soap_instantiate_ns__GetDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetDataResponse;
		if (size)
			*size = sizeof(struct ns__GetDataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetDataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetDataResponse %p -> %p\n", q, p));
	*(struct ns__GetDataResponse*)p = *(struct ns__GetDataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllYMetadata(struct soap *soap, struct ns__GetAllYMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->currentMeasurementNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllYMetadata(struct soap *soap, const struct ns__GetAllYMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllYMetadata(struct soap *soap, const struct ns__GetAllYMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllYMetadata);
	if (soap_out_ns__GetAllYMetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllYMetadata(struct soap *soap, const char *tag, int id, const struct ns__GetAllYMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllYMetadata), type))
		return soap->error;
	if (soap_out_int(soap, "currentMeasurementNumber", -1, &a->currentMeasurementNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllYMetadata * SOAP_FMAC4 soap_get_ns__GetAllYMetadata(struct soap *soap, struct ns__GetAllYMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllYMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllYMetadata * SOAP_FMAC4 soap_in_ns__GetAllYMetadata(struct soap *soap, const char *tag, struct ns__GetAllYMetadata *a, const char *type)
{
	size_t soap_flag_currentMeasurementNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllYMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllYMetadata, sizeof(struct ns__GetAllYMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllYMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentMeasurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentMeasurementNumber", &a->currentMeasurementNumber, "xsd:int"))
				{	soap_flag_currentMeasurementNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllYMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllYMetadata, 0, sizeof(struct ns__GetAllYMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentMeasurementNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllYMetadata * SOAP_FMAC6 soap_new_ns__GetAllYMetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllYMetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllYMetadata(struct soap *soap, struct ns__GetAllYMetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllYMetadata * SOAP_FMAC4 soap_instantiate_ns__GetAllYMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllYMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllYMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllYMetadata;
		if (size)
			*size = sizeof(struct ns__GetAllYMetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllYMetadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllYMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllYMetadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllYMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllYMetadata %p -> %p\n", q, p));
	*(struct ns__GetAllYMetadata*)p = *(struct ns__GetAllYMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllYMetadataResponse(struct soap *soap, struct ns__GetAllYMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->metadata.ns__YMetadataList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllYMetadataResponse(struct soap *soap, const struct ns__GetAllYMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->metadata.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllYMetadataResponse(struct soap *soap, const struct ns__GetAllYMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllYMetadataResponse);
	if (soap_out_ns__GetAllYMetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllYMetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllYMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllYMetadataResponse), type))
		return soap->error;
	if (a->metadata.soap_out(soap, "metadata", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllYMetadataResponse * SOAP_FMAC4 soap_get_ns__GetAllYMetadataResponse(struct soap *soap, struct ns__GetAllYMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllYMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllYMetadataResponse * SOAP_FMAC4 soap_in_ns__GetAllYMetadataResponse(struct soap *soap, const char *tag, struct ns__GetAllYMetadataResponse *a, const char *type)
{
	size_t soap_flag_metadata = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllYMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllYMetadataResponse, sizeof(struct ns__GetAllYMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetAllYMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_metadata && soap->error == SOAP_TAG_MISMATCH)
				if (a->metadata.soap_in(soap, "metadata", "ns:YMetadataList"))
				{	soap_flag_metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllYMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllYMetadataResponse, 0, sizeof(struct ns__GetAllYMetadataResponse), 0, soap_copy_ns__GetAllYMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_metadata > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllYMetadataResponse * SOAP_FMAC6 soap_new_ns__GetAllYMetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllYMetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllYMetadataResponse(struct soap *soap, struct ns__GetAllYMetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllYMetadataResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllYMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllYMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllYMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllYMetadataResponse;
		if (size)
			*size = sizeof(struct ns__GetAllYMetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllYMetadataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllYMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllYMetadataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllYMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllYMetadataResponse %p -> %p\n", q, p));
	*(struct ns__GetAllYMetadataResponse*)p = *(struct ns__GetAllYMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__YMetadata(struct soap *soap, struct ns__YMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->inputNumber);
	soap_default_bool(soap, &a->isActive);
	soap_default_int(soap, &a->resolutionInBits);
	soap_default_unsignedInt(soap, &a->analogMask);
	soap_default_unsignedInt(soap, &a->markerMask);
	soap_default_int(soap, &a->numberOfMarkerBits);
	soap_default_int(soap, &a->bytesPerSample);
	soap_default_double(soap, &a->binToVoltFactor);
	soap_default_double(soap, &a->binToVoltConst);
	soap_default_double(soap, &a->voltToPhysicalFactor);
	soap_default_double(soap, &a->voltToPhysicalConstant);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__YMetadata(struct soap *soap, const struct ns__YMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->binToVoltFactor, SOAP_TYPE_double);
	soap_embedded(soap, &a->binToVoltConst, SOAP_TYPE_double);
	soap_embedded(soap, &a->voltToPhysicalFactor, SOAP_TYPE_double);
	soap_embedded(soap, &a->voltToPhysicalConstant, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__YMetadata(struct soap *soap, const struct ns__YMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__YMetadata);
	if (soap_out_ns__YMetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__YMetadata(struct soap *soap, const char *tag, int id, const struct ns__YMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__YMetadata), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	if (soap_out_bool(soap, "isActive", -1, &a->isActive, ""))
		return soap->error;
	if (soap_out_int(soap, "resolutionInBits", -1, &a->resolutionInBits, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "analogMask", -1, &a->analogMask, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "markerMask", -1, &a->markerMask, ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfMarkerBits", -1, &a->numberOfMarkerBits, ""))
		return soap->error;
	if (soap_out_int(soap, "bytesPerSample", -1, &a->bytesPerSample, ""))
		return soap->error;
	if (soap_out_double(soap, "binToVoltFactor", -1, &a->binToVoltFactor, ""))
		return soap->error;
	if (soap_out_double(soap, "binToVoltConst", -1, &a->binToVoltConst, ""))
		return soap->error;
	if (soap_out_double(soap, "voltToPhysicalFactor", -1, &a->voltToPhysicalFactor, ""))
		return soap->error;
	if (soap_out_double(soap, "voltToPhysicalConstant", -1, &a->voltToPhysicalConstant, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__YMetadata * SOAP_FMAC4 soap_get_ns__YMetadata(struct soap *soap, struct ns__YMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__YMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__YMetadata * SOAP_FMAC4 soap_in_ns__YMetadata(struct soap *soap, const char *tag, struct ns__YMetadata *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	size_t soap_flag_isActive = 1;
	size_t soap_flag_resolutionInBits = 1;
	size_t soap_flag_analogMask = 1;
	size_t soap_flag_markerMask = 1;
	size_t soap_flag_numberOfMarkerBits = 1;
	size_t soap_flag_bytesPerSample = 1;
	size_t soap_flag_binToVoltFactor = 1;
	size_t soap_flag_binToVoltConst = 1;
	size_t soap_flag_voltToPhysicalFactor = 1;
	size_t soap_flag_voltToPhysicalConstant = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__YMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__YMetadata, sizeof(struct ns__YMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__YMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputNumber", &a->inputNumber, "xsd:int"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap_flag_isActive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isActive", &a->isActive, "xsd:boolean"))
				{	soap_flag_isActive--;
					continue;
				}
			if (soap_flag_resolutionInBits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "resolutionInBits", &a->resolutionInBits, "xsd:int"))
				{	soap_flag_resolutionInBits--;
					continue;
				}
			if (soap_flag_analogMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "analogMask", &a->analogMask, "xsd:unsignedInt"))
				{	soap_flag_analogMask--;
					continue;
				}
			if (soap_flag_markerMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "markerMask", &a->markerMask, "xsd:unsignedInt"))
				{	soap_flag_markerMask--;
					continue;
				}
			if (soap_flag_numberOfMarkerBits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfMarkerBits", &a->numberOfMarkerBits, "xsd:int"))
				{	soap_flag_numberOfMarkerBits--;
					continue;
				}
			if (soap_flag_bytesPerSample && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "bytesPerSample", &a->bytesPerSample, "xsd:int"))
				{	soap_flag_bytesPerSample--;
					continue;
				}
			if (soap_flag_binToVoltFactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "binToVoltFactor", &a->binToVoltFactor, "xsd:double"))
				{	soap_flag_binToVoltFactor--;
					continue;
				}
			if (soap_flag_binToVoltConst && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "binToVoltConst", &a->binToVoltConst, "xsd:double"))
				{	soap_flag_binToVoltConst--;
					continue;
				}
			if (soap_flag_voltToPhysicalFactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "voltToPhysicalFactor", &a->voltToPhysicalFactor, "xsd:double"))
				{	soap_flag_voltToPhysicalFactor--;
					continue;
				}
			if (soap_flag_voltToPhysicalConstant && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "voltToPhysicalConstant", &a->voltToPhysicalConstant, "xsd:double"))
				{	soap_flag_voltToPhysicalConstant--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__YMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__YMetadata, 0, sizeof(struct ns__YMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0 || soap_flag_isActive > 0 || soap_flag_resolutionInBits > 0 || soap_flag_analogMask > 0 || soap_flag_markerMask > 0 || soap_flag_numberOfMarkerBits > 0 || soap_flag_bytesPerSample > 0 || soap_flag_binToVoltFactor > 0 || soap_flag_binToVoltConst > 0 || soap_flag_voltToPhysicalFactor > 0 || soap_flag_voltToPhysicalConstant > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__YMetadata * SOAP_FMAC6 soap_new_ns__YMetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__YMetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__YMetadata(struct soap *soap, struct ns__YMetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__YMetadata * SOAP_FMAC4 soap_instantiate_ns__YMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__YMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__YMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__YMetadata;
		if (size)
			*size = sizeof(struct ns__YMetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__YMetadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__YMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__YMetadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__YMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__YMetadata %p -> %p\n", q, p));
	*(struct ns__YMetadata*)p = *(struct ns__YMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetMetadata(struct soap *soap, struct ns__GetMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->currentMeasurementNumber);
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->blockFrom);
	soap_default_int(soap, &a->blockTo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetMetadata(struct soap *soap, const struct ns__GetMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetMetadata(struct soap *soap, const struct ns__GetMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetMetadata);
	if (soap_out_ns__GetMetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetMetadata(struct soap *soap, const char *tag, int id, const struct ns__GetMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetMetadata), type))
		return soap->error;
	if (soap_out_int(soap, "currentMeasurementNumber", -1, &a->currentMeasurementNumber, ""))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "blockFrom", -1, &a->blockFrom, ""))
		return soap->error;
	if (soap_out_int(soap, "blockTo", -1, &a->blockTo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetMetadata * SOAP_FMAC4 soap_get_ns__GetMetadata(struct soap *soap, struct ns__GetMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetMetadata * SOAP_FMAC4 soap_in_ns__GetMetadata(struct soap *soap, const char *tag, struct ns__GetMetadata *a, const char *type)
{
	size_t soap_flag_currentMeasurementNumber = 1;
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_blockFrom = 1;
	size_t soap_flag_blockTo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetMetadata, sizeof(struct ns__GetMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentMeasurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentMeasurementNumber", &a->currentMeasurementNumber, "xsd:int"))
				{	soap_flag_currentMeasurementNumber--;
					continue;
				}
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_blockFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockFrom", &a->blockFrom, "xsd:int"))
				{	soap_flag_blockFrom--;
					continue;
				}
			if (soap_flag_blockTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockTo", &a->blockTo, "xsd:int"))
				{	soap_flag_blockTo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetMetadata, 0, sizeof(struct ns__GetMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentMeasurementNumber > 0 || soap_flag_boardAddress > 0 || soap_flag_blockFrom > 0 || soap_flag_blockTo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetMetadata * SOAP_FMAC6 soap_new_ns__GetMetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__GetMetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetMetadata(struct soap *soap, struct ns__GetMetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetMetadata * SOAP_FMAC4 soap_instantiate_ns__GetMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetMetadata;
		if (size)
			*size = sizeof(struct ns__GetMetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetMetadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetMetadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetMetadata %p -> %p\n", q, p));
	*(struct ns__GetMetadata*)p = *(struct ns__GetMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetMetadataResponse(struct soap *soap, struct ns__GetMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->metadata.ns__MetadataList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetMetadataResponse(struct soap *soap, const struct ns__GetMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->metadata.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetMetadataResponse(struct soap *soap, const struct ns__GetMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetMetadataResponse);
	if (soap_out_ns__GetMetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetMetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__GetMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetMetadataResponse), type))
		return soap->error;
	if (a->metadata.soap_out(soap, "metadata", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetMetadataResponse * SOAP_FMAC4 soap_get_ns__GetMetadataResponse(struct soap *soap, struct ns__GetMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetMetadataResponse * SOAP_FMAC4 soap_in_ns__GetMetadataResponse(struct soap *soap, const char *tag, struct ns__GetMetadataResponse *a, const char *type)
{
	size_t soap_flag_metadata = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetMetadataResponse, sizeof(struct ns__GetMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_metadata && soap->error == SOAP_TAG_MISMATCH)
				if (a->metadata.soap_in(soap, "metadata", "ns:MetadataList"))
				{	soap_flag_metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetMetadataResponse, 0, sizeof(struct ns__GetMetadataResponse), 0, soap_copy_ns__GetMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_metadata > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetMetadataResponse * SOAP_FMAC6 soap_new_ns__GetMetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetMetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetMetadataResponse(struct soap *soap, struct ns__GetMetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetMetadataResponse * SOAP_FMAC4 soap_instantiate_ns__GetMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetMetadataResponse;
		if (size)
			*size = sizeof(struct ns__GetMetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetMetadataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetMetadataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetMetadataResponse %p -> %p\n", q, p));
	*(struct ns__GetMetadataResponse*)p = *(struct ns__GetMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Metadata(struct soap *soap, struct ns__Metadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &a->triggerTime);
	soap_default_unsignedLONG64(soap, &a->triggerSample);
	soap_default_unsignedLONG64(soap, &a->blockLength);
	soap_default_unsignedLONG64(soap, &a->stopTriggerSample);
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->inputNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Metadata(struct soap *soap, const struct ns__Metadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->triggerTime, SOAP_TYPE_unsignedLONG64);
	soap_embedded(soap, &a->triggerSample, SOAP_TYPE_unsignedLONG64);
	soap_embedded(soap, &a->blockLength, SOAP_TYPE_unsignedLONG64);
	soap_embedded(soap, &a->stopTriggerSample, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Metadata(struct soap *soap, const struct ns__Metadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Metadata);
	if (soap_out_ns__Metadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Metadata(struct soap *soap, const char *tag, int id, const struct ns__Metadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Metadata), type))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "triggerTime", -1, &a->triggerTime, ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "triggerSample", -1, &a->triggerSample, ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "blockLength", -1, &a->blockLength, ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "stopTriggerSample", -1, &a->stopTriggerSample, ""))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Metadata * SOAP_FMAC4 soap_get_ns__Metadata(struct soap *soap, struct ns__Metadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Metadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Metadata * SOAP_FMAC4 soap_in_ns__Metadata(struct soap *soap, const char *tag, struct ns__Metadata *a, const char *type)
{
	size_t soap_flag_triggerTime = 1;
	size_t soap_flag_triggerSample = 1;
	size_t soap_flag_blockLength = 1;
	size_t soap_flag_stopTriggerSample = 1;
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Metadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Metadata, sizeof(struct ns__Metadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Metadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_triggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "triggerTime", &a->triggerTime, "xsd:unsignedLong"))
				{	soap_flag_triggerTime--;
					continue;
				}
			if (soap_flag_triggerSample && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "triggerSample", &a->triggerSample, "xsd:unsignedLong"))
				{	soap_flag_triggerSample--;
					continue;
				}
			if (soap_flag_blockLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "blockLength", &a->blockLength, "xsd:unsignedLong"))
				{	soap_flag_blockLength--;
					continue;
				}
			if (soap_flag_stopTriggerSample && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "stopTriggerSample", &a->stopTriggerSample, "xsd:unsignedLong"))
				{	soap_flag_stopTriggerSample--;
					continue;
				}
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputNumber", &a->inputNumber, "xsd:int"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Metadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Metadata, 0, sizeof(struct ns__Metadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_triggerTime > 0 || soap_flag_triggerSample > 0 || soap_flag_blockLength > 0 || soap_flag_stopTriggerSample > 0 || soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__Metadata * SOAP_FMAC6 soap_new_ns__Metadata(struct soap *soap, int n)
{	return soap_instantiate_ns__Metadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__Metadata(struct soap *soap, struct ns__Metadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__Metadata * SOAP_FMAC4 soap_instantiate_ns__Metadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Metadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Metadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__Metadata;
		if (size)
			*size = sizeof(struct ns__Metadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__Metadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__Metadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__Metadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Metadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Metadata %p -> %p\n", q, p));
	*(struct ns__Metadata*)p = *(struct ns__Metadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__LeaveWaitStatus(struct soap *soap, struct ns__LeaveWaitStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__LeaveWaitStatus(struct soap *soap, const struct ns__LeaveWaitStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__LeaveWaitStatus(struct soap *soap, const struct ns__LeaveWaitStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__LeaveWaitStatus);
	if (soap_out_ns__LeaveWaitStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__LeaveWaitStatus(struct soap *soap, const char *tag, int id, const struct ns__LeaveWaitStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__LeaveWaitStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__LeaveWaitStatus * SOAP_FMAC4 soap_get_ns__LeaveWaitStatus(struct soap *soap, struct ns__LeaveWaitStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__LeaveWaitStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__LeaveWaitStatus * SOAP_FMAC4 soap_in_ns__LeaveWaitStatus(struct soap *soap, const char *tag, struct ns__LeaveWaitStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__LeaveWaitStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__LeaveWaitStatus, sizeof(struct ns__LeaveWaitStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__LeaveWaitStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__LeaveWaitStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__LeaveWaitStatus, 0, sizeof(struct ns__LeaveWaitStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__LeaveWaitStatus * SOAP_FMAC6 soap_new_ns__LeaveWaitStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__LeaveWaitStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__LeaveWaitStatus(struct soap *soap, struct ns__LeaveWaitStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__LeaveWaitStatus * SOAP_FMAC4 soap_instantiate_ns__LeaveWaitStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__LeaveWaitStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__LeaveWaitStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__LeaveWaitStatus;
		if (size)
			*size = sizeof(struct ns__LeaveWaitStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__LeaveWaitStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__LeaveWaitStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__LeaveWaitStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__LeaveWaitStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__LeaveWaitStatus %p -> %p\n", q, p));
	*(struct ns__LeaveWaitStatus*)p = *(struct ns__LeaveWaitStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__WaitForStatusChange(struct soap *soap, struct ns__WaitForStatusChange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->eventCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__WaitForStatusChange(struct soap *soap, const struct ns__WaitForStatusChange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__WaitForStatusChange(struct soap *soap, const struct ns__WaitForStatusChange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__WaitForStatusChange);
	if (soap_out_ns__WaitForStatusChange(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__WaitForStatusChange(struct soap *soap, const char *tag, int id, const struct ns__WaitForStatusChange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__WaitForStatusChange), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "eventCounter", -1, &a->eventCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__WaitForStatusChange * SOAP_FMAC4 soap_get_ns__WaitForStatusChange(struct soap *soap, struct ns__WaitForStatusChange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__WaitForStatusChange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__WaitForStatusChange * SOAP_FMAC4 soap_in_ns__WaitForStatusChange(struct soap *soap, const char *tag, struct ns__WaitForStatusChange *a, const char *type)
{
	size_t soap_flag_eventCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__WaitForStatusChange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__WaitForStatusChange, sizeof(struct ns__WaitForStatusChange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__WaitForStatusChange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "eventCounter", &a->eventCounter, "xsd:unsignedInt"))
				{	soap_flag_eventCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__WaitForStatusChange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__WaitForStatusChange, 0, sizeof(struct ns__WaitForStatusChange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__WaitForStatusChange * SOAP_FMAC6 soap_new_ns__WaitForStatusChange(struct soap *soap, int n)
{	return soap_instantiate_ns__WaitForStatusChange(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__WaitForStatusChange(struct soap *soap, struct ns__WaitForStatusChange *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__WaitForStatusChange * SOAP_FMAC4 soap_instantiate_ns__WaitForStatusChange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__WaitForStatusChange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__WaitForStatusChange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__WaitForStatusChange;
		if (size)
			*size = sizeof(struct ns__WaitForStatusChange);
	}
	else
	{	cp->ptr = (void*)new struct ns__WaitForStatusChange[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__WaitForStatusChange);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__WaitForStatusChange*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__WaitForStatusChange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__WaitForStatusChange %p -> %p\n", q, p));
	*(struct ns__WaitForStatusChange*)p = *(struct ns__WaitForStatusChange*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetStatus(struct soap *soap, struct ns__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetStatus(struct soap *soap, const struct ns__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetStatus(struct soap *soap, const struct ns__GetStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetStatus);
	if (soap_out_ns__GetStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetStatus(struct soap *soap, const char *tag, int id, const struct ns__GetStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetStatus * SOAP_FMAC4 soap_get_ns__GetStatus(struct soap *soap, struct ns__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetStatus * SOAP_FMAC4 soap_in_ns__GetStatus(struct soap *soap, const char *tag, struct ns__GetStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetStatus, sizeof(struct ns__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetStatus, 0, sizeof(struct ns__GetStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetStatus * SOAP_FMAC6 soap_new_ns__GetStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetStatus(struct soap *soap, struct ns__GetStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetStatus * SOAP_FMAC4 soap_instantiate_ns__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetStatus;
		if (size)
			*size = sizeof(struct ns__GetStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetStatus %p -> %p\n", q, p));
	*(struct ns__GetStatus*)p = *(struct ns__GetStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Status(struct soap *soap, struct ns__Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->eventCounter);
	soap_default_ns__DeviceStatus(soap, &a->status);
	soap_default_ns__ClusterConfiguration(soap, &a->clusters);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Status(struct soap *soap, const struct ns__Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__DeviceStatus(soap, &a->status);
	soap_serialize_ns__ClusterConfiguration(soap, &a->clusters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Status(struct soap *soap, const struct ns__Status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Status);
	if (soap_out_ns__Status(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Status(struct soap *soap, const char *tag, int id, const struct ns__Status *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Status), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "eventCounter", -1, &a->eventCounter, ""))
		return soap->error;
	if (soap_out_ns__DeviceStatus(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_ns__ClusterConfiguration(soap, "clusters", -1, &a->clusters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Status * SOAP_FMAC4 soap_get_ns__Status(struct soap *soap, struct ns__Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Status * SOAP_FMAC4 soap_in_ns__Status(struct soap *soap, const char *tag, struct ns__Status *a, const char *type)
{
	size_t soap_flag_eventCounter = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_clusters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Status, sizeof(struct ns__Status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "eventCounter", &a->eventCounter, "xsd:unsignedInt"))
				{	soap_flag_eventCounter--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__DeviceStatus(soap, "status", &a->status, "ns:DeviceStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_clusters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__ClusterConfiguration(soap, "clusters", &a->clusters, "ns:ClusterConfiguration"))
				{	soap_flag_clusters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Status, 0, sizeof(struct ns__Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventCounter > 0 || soap_flag_status > 0 || soap_flag_clusters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__Status * SOAP_FMAC6 soap_new_ns__Status(struct soap *soap, int n)
{	return soap_instantiate_ns__Status(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__Status(struct soap *soap, struct ns__Status *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__Status * SOAP_FMAC4 soap_instantiate_ns__Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__Status;
		if (size)
			*size = sizeof(struct ns__Status);
	}
	else
	{	cp->ptr = (void*)new struct ns__Status[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__Status);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__Status*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Status(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Status %p -> %p\n", q, p));
	*(struct ns__Status*)p = *(struct ns__Status*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeviceStatus(struct soap *soap, struct ns__DeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->deviceError);
	soap_default_Array16Ofns__BoardStatus(soap, a->boards);
	soap_default_int(soap, &a->settingsChangesCounter);
	soap_default_ns__DateTime(soap, &a->startTime);
	soap_default_int(soap, &a->measurementNumber);
	soap_default_bool(soap, &a->startInProgress);
	soap_default_int(soap, &a->autosequenceState);
	soap_default_int(soap, &a->extStartState);
	soap_default_ns__GPSStatus(soap, &a->gpsStatus);
	soap_default_ns__TempStatus(soap, &a->tempStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeviceStatus(struct soap *soap, const struct ns__DeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array16Ofns__BoardStatus(soap, a->boards);
	soap_serialize_ns__DateTime(soap, &a->startTime);
	soap_serialize_ns__GPSStatus(soap, &a->gpsStatus);
	soap_serialize_ns__TempStatus(soap, &a->tempStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeviceStatus(struct soap *soap, const struct ns__DeviceStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__DeviceStatus);
	if (soap_out_ns__DeviceStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatus(struct soap *soap, const char *tag, int id, const struct ns__DeviceStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatus), type))
		return soap->error;
	if (soap_out_int(soap, "deviceError", -1, &a->deviceError, ""))
		return soap->error;
	soap_out_Array16Ofns__BoardStatus(soap, "boards", -1, a->boards, "");
	if (soap_out_int(soap, "settingsChangesCounter", -1, &a->settingsChangesCounter, ""))
		return soap->error;
	if (soap_out_ns__DateTime(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_int(soap, "measurementNumber", -1, &a->measurementNumber, ""))
		return soap->error;
	if (soap_out_bool(soap, "startInProgress", -1, &a->startInProgress, ""))
		return soap->error;
	if (soap_out_int(soap, "autosequenceState", -1, &a->autosequenceState, ""))
		return soap->error;
	if (soap_out_int(soap, "extStartState", -1, &a->extStartState, ""))
		return soap->error;
	if (soap_out_ns__GPSStatus(soap, "gpsStatus", -1, &a->gpsStatus, ""))
		return soap->error;
	if (soap_out_ns__TempStatus(soap, "tempStatus", -1, &a->tempStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeviceStatus * SOAP_FMAC4 soap_get_ns__DeviceStatus(struct soap *soap, struct ns__DeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__DeviceStatus * SOAP_FMAC4 soap_in_ns__DeviceStatus(struct soap *soap, const char *tag, struct ns__DeviceStatus *a, const char *type)
{
	size_t soap_flag_deviceError = 1;
	size_t soap_flag_boards = 1;
	size_t soap_flag_settingsChangesCounter = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_measurementNumber = 1;
	size_t soap_flag_startInProgress = 1;
	size_t soap_flag_autosequenceState = 1;
	size_t soap_flag_extStartState = 1;
	size_t soap_flag_gpsStatus = 1;
	size_t soap_flag_tempStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeviceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatus, sizeof(struct ns__DeviceStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__DeviceStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deviceError", &a->deviceError, "xsd:int"))
				{	soap_flag_deviceError--;
					continue;
				}
			if (soap_flag_boards && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array16Ofns__BoardStatus(soap, "boards", a->boards, "ns:BoardStatus"))
				{	soap_flag_boards--;
					continue;
				}
			if (soap_flag_settingsChangesCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "settingsChangesCounter", &a->settingsChangesCounter, "xsd:int"))
				{	soap_flag_settingsChangesCounter--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__DateTime(soap, "startTime", &a->startTime, "ns:DateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_measurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "measurementNumber", &a->measurementNumber, "xsd:int"))
				{	soap_flag_measurementNumber--;
					continue;
				}
			if (soap_flag_startInProgress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "startInProgress", &a->startInProgress, "xsd:boolean"))
				{	soap_flag_startInProgress--;
					continue;
				}
			if (soap_flag_autosequenceState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "autosequenceState", &a->autosequenceState, "xsd:int"))
				{	soap_flag_autosequenceState--;
					continue;
				}
			if (soap_flag_extStartState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "extStartState", &a->extStartState, "xsd:int"))
				{	soap_flag_extStartState--;
					continue;
				}
			if (soap_flag_gpsStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__GPSStatus(soap, "gpsStatus", &a->gpsStatus, "ns:GPSStatus"))
				{	soap_flag_gpsStatus--;
					continue;
				}
			if (soap_flag_tempStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__TempStatus(soap, "tempStatus", &a->tempStatus, "ns:TempStatus"))
				{	soap_flag_tempStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__DeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatus, 0, sizeof(struct ns__DeviceStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceError > 0 || soap_flag_boards > 0 || soap_flag_settingsChangesCounter > 0 || soap_flag_startTime > 0 || soap_flag_measurementNumber > 0 || soap_flag_startInProgress > 0 || soap_flag_autosequenceState > 0 || soap_flag_extStartState > 0 || soap_flag_gpsStatus > 0 || soap_flag_tempStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__DeviceStatus * SOAP_FMAC6 soap_new_ns__DeviceStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__DeviceStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DeviceStatus(struct soap *soap, struct ns__DeviceStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__DeviceStatus * SOAP_FMAC4 soap_instantiate_ns__DeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DeviceStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__DeviceStatus;
		if (size)
			*size = sizeof(struct ns__DeviceStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__DeviceStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__DeviceStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__DeviceStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DeviceStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__DeviceStatus %p -> %p\n", q, p));
	*(struct ns__DeviceStatus*)p = *(struct ns__DeviceStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TempStatus(struct soap *soap, struct ns__TempStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->CPUTemp);
	soap_default_Array16Ofint(soap, a->BoardTemp);
	soap_default_int(soap, &a->Res1Temp);
	soap_default_int(soap, &a->Res2Temp);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__TempStatus(struct soap *soap, const struct ns__TempStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array16Ofint(soap, a->BoardTemp);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TempStatus(struct soap *soap, const struct ns__TempStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__TempStatus);
	if (soap_out_ns__TempStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TempStatus(struct soap *soap, const char *tag, int id, const struct ns__TempStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TempStatus), type))
		return soap->error;
	if (soap_out_int(soap, "CPUTemp", -1, &a->CPUTemp, ""))
		return soap->error;
	soap_out_Array16Ofint(soap, "BoardTemp", -1, a->BoardTemp, "");
	if (soap_out_int(soap, "Res1Temp", -1, &a->Res1Temp, ""))
		return soap->error;
	if (soap_out_int(soap, "Res2Temp", -1, &a->Res2Temp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__TempStatus * SOAP_FMAC4 soap_get_ns__TempStatus(struct soap *soap, struct ns__TempStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TempStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__TempStatus * SOAP_FMAC4 soap_in_ns__TempStatus(struct soap *soap, const char *tag, struct ns__TempStatus *a, const char *type)
{
	size_t soap_flag_CPUTemp = 1;
	size_t soap_flag_BoardTemp = 1;
	size_t soap_flag_Res1Temp = 1;
	size_t soap_flag_Res2Temp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__TempStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TempStatus, sizeof(struct ns__TempStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__TempStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CPUTemp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CPUTemp", &a->CPUTemp, "xsd:int"))
				{	soap_flag_CPUTemp--;
					continue;
				}
			if (soap_flag_BoardTemp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array16Ofint(soap, "BoardTemp", a->BoardTemp, "xsd:int"))
				{	soap_flag_BoardTemp--;
					continue;
				}
			if (soap_flag_Res1Temp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Res1Temp", &a->Res1Temp, "xsd:int"))
				{	soap_flag_Res1Temp--;
					continue;
				}
			if (soap_flag_Res2Temp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Res2Temp", &a->Res2Temp, "xsd:int"))
				{	soap_flag_Res2Temp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__TempStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TempStatus, 0, sizeof(struct ns__TempStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CPUTemp > 0 || soap_flag_BoardTemp > 0 || soap_flag_Res1Temp > 0 || soap_flag_Res2Temp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__TempStatus * SOAP_FMAC6 soap_new_ns__TempStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__TempStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__TempStatus(struct soap *soap, struct ns__TempStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__TempStatus * SOAP_FMAC4 soap_instantiate_ns__TempStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__TempStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__TempStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__TempStatus;
		if (size)
			*size = sizeof(struct ns__TempStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__TempStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__TempStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__TempStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__TempStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__TempStatus %p -> %p\n", q, p));
	*(struct ns__TempStatus*)p = *(struct ns__TempStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GPSStatus(struct soap *soap, struct ns__GPSStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->locked);
	soap_default_int(soap, &a->NrOfSatVisible);
	soap_default_Array128Ofbyte(soap, a->gpsTime);
	soap_default_Array128Ofbyte(soap, a->lastFrame);
	soap_default_int(soap, &a->nrOfloggedPositions);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GPSStatus(struct soap *soap, const struct ns__GPSStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array128Ofbyte(soap, a->gpsTime);
	soap_serialize_Array128Ofbyte(soap, a->lastFrame);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GPSStatus(struct soap *soap, const struct ns__GPSStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GPSStatus);
	if (soap_out_ns__GPSStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GPSStatus(struct soap *soap, const char *tag, int id, const struct ns__GPSStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GPSStatus), type))
		return soap->error;
	if (soap_out_bool(soap, "locked", -1, &a->locked, ""))
		return soap->error;
	if (soap_out_int(soap, "NrOfSatVisible", -1, &a->NrOfSatVisible, ""))
		return soap->error;
	soap_out_Array128Ofbyte(soap, "gpsTime", -1, a->gpsTime, "");
	soap_out_Array128Ofbyte(soap, "lastFrame", -1, a->lastFrame, "");
	if (soap_out_int(soap, "nrOfloggedPositions", -1, &a->nrOfloggedPositions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GPSStatus * SOAP_FMAC4 soap_get_ns__GPSStatus(struct soap *soap, struct ns__GPSStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GPSStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GPSStatus * SOAP_FMAC4 soap_in_ns__GPSStatus(struct soap *soap, const char *tag, struct ns__GPSStatus *a, const char *type)
{
	size_t soap_flag_locked = 1;
	size_t soap_flag_NrOfSatVisible = 1;
	size_t soap_flag_gpsTime = 1;
	size_t soap_flag_lastFrame = 1;
	size_t soap_flag_nrOfloggedPositions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GPSStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GPSStatus, sizeof(struct ns__GPSStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GPSStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locked && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "locked", &a->locked, "xsd:boolean"))
				{	soap_flag_locked--;
					continue;
				}
			if (soap_flag_NrOfSatVisible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "NrOfSatVisible", &a->NrOfSatVisible, "xsd:int"))
				{	soap_flag_NrOfSatVisible--;
					continue;
				}
			if (soap_flag_gpsTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array128Ofbyte(soap, "gpsTime", a->gpsTime, "xsd:byte"))
				{	soap_flag_gpsTime--;
					continue;
				}
			if (soap_flag_lastFrame && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array128Ofbyte(soap, "lastFrame", a->lastFrame, "xsd:byte"))
				{	soap_flag_lastFrame--;
					continue;
				}
			if (soap_flag_nrOfloggedPositions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nrOfloggedPositions", &a->nrOfloggedPositions, "xsd:int"))
				{	soap_flag_nrOfloggedPositions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GPSStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GPSStatus, 0, sizeof(struct ns__GPSStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locked > 0 || soap_flag_NrOfSatVisible > 0 || soap_flag_gpsTime > 0 || soap_flag_lastFrame > 0 || soap_flag_nrOfloggedPositions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GPSStatus * SOAP_FMAC6 soap_new_ns__GPSStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__GPSStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GPSStatus(struct soap *soap, struct ns__GPSStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GPSStatus * SOAP_FMAC4 soap_instantiate_ns__GPSStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GPSStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GPSStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GPSStatus;
		if (size)
			*size = sizeof(struct ns__GPSStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__GPSStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GPSStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GPSStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GPSStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GPSStatus %p -> %p\n", q, p));
	*(struct ns__GPSStatus*)p = *(struct ns__GPSStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__BoardStatus(struct soap *soap, struct ns__BoardStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->recordingState);
	soap_default_int(soap, &a->triggerState);
	soap_default_int(soap, &a->blockCounter);
	soap_default_LONG64(soap, &a->dataCounter);
	soap_default_int(soap, &a->dataLostCounter);
	soap_default_int(soap, &a->blockLostCounter);
	soap_default_Array8Ofns__InputStatus(soap, a->inputs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__BoardStatus(struct soap *soap, const struct ns__BoardStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array8Ofns__InputStatus(soap, a->inputs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__BoardStatus(struct soap *soap, const struct ns__BoardStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__BoardStatus);
	if (soap_out_ns__BoardStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__BoardStatus(struct soap *soap, const char *tag, int id, const struct ns__BoardStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__BoardStatus), type))
		return soap->error;
	if (soap_out_int(soap, "recordingState", -1, &a->recordingState, ""))
		return soap->error;
	if (soap_out_int(soap, "triggerState", -1, &a->triggerState, ""))
		return soap->error;
	if (soap_out_int(soap, "blockCounter", -1, &a->blockCounter, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "dataCounter", -1, &a->dataCounter, ""))
		return soap->error;
	if (soap_out_int(soap, "dataLostCounter", -1, &a->dataLostCounter, ""))
		return soap->error;
	if (soap_out_int(soap, "blockLostCounter", -1, &a->blockLostCounter, ""))
		return soap->error;
	soap_out_Array8Ofns__InputStatus(soap, "inputs", -1, a->inputs, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__BoardStatus * SOAP_FMAC4 soap_get_ns__BoardStatus(struct soap *soap, struct ns__BoardStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__BoardStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__BoardStatus * SOAP_FMAC4 soap_in_ns__BoardStatus(struct soap *soap, const char *tag, struct ns__BoardStatus *a, const char *type)
{
	size_t soap_flag_recordingState = 1;
	size_t soap_flag_triggerState = 1;
	size_t soap_flag_blockCounter = 1;
	size_t soap_flag_dataCounter = 1;
	size_t soap_flag_dataLostCounter = 1;
	size_t soap_flag_blockLostCounter = 1;
	size_t soap_flag_inputs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__BoardStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__BoardStatus, sizeof(struct ns__BoardStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__BoardStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordingState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "recordingState", &a->recordingState, "xsd:int"))
				{	soap_flag_recordingState--;
					continue;
				}
			if (soap_flag_triggerState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "triggerState", &a->triggerState, "xsd:int"))
				{	soap_flag_triggerState--;
					continue;
				}
			if (soap_flag_blockCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockCounter", &a->blockCounter, "xsd:int"))
				{	soap_flag_blockCounter--;
					continue;
				}
			if (soap_flag_dataCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "dataCounter", &a->dataCounter, "xsd:long"))
				{	soap_flag_dataCounter--;
					continue;
				}
			if (soap_flag_dataLostCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dataLostCounter", &a->dataLostCounter, "xsd:int"))
				{	soap_flag_dataLostCounter--;
					continue;
				}
			if (soap_flag_blockLostCounter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockLostCounter", &a->blockLostCounter, "xsd:int"))
				{	soap_flag_blockLostCounter--;
					continue;
				}
			if (soap_flag_inputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array8Ofns__InputStatus(soap, "inputs", a->inputs, "ns:InputStatus"))
				{	soap_flag_inputs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__BoardStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__BoardStatus, 0, sizeof(struct ns__BoardStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordingState > 0 || soap_flag_triggerState > 0 || soap_flag_blockCounter > 0 || soap_flag_dataCounter > 0 || soap_flag_dataLostCounter > 0 || soap_flag_blockLostCounter > 0 || soap_flag_inputs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__BoardStatus * SOAP_FMAC6 soap_new_ns__BoardStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__BoardStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__BoardStatus(struct soap *soap, struct ns__BoardStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__BoardStatus * SOAP_FMAC4 soap_instantiate_ns__BoardStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__BoardStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__BoardStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__BoardStatus;
		if (size)
			*size = sizeof(struct ns__BoardStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__BoardStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__BoardStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__BoardStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__BoardStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__BoardStatus %p -> %p\n", q, p));
	*(struct ns__BoardStatus*)p = *(struct ns__BoardStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__InputStatus(struct soap *soap, struct ns__InputStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->OverloadLive);
	soap_default_int(soap, &a->OverloadMeas);
	soap_default_int(soap, &a->IEPEStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__InputStatus(struct soap *soap, const struct ns__InputStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__InputStatus(struct soap *soap, const struct ns__InputStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__InputStatus);
	if (soap_out_ns__InputStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__InputStatus(struct soap *soap, const char *tag, int id, const struct ns__InputStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__InputStatus), type))
		return soap->error;
	if (soap_out_int(soap, "OverloadLive", -1, &a->OverloadLive, ""))
		return soap->error;
	if (soap_out_int(soap, "OverloadMeas", -1, &a->OverloadMeas, ""))
		return soap->error;
	if (soap_out_int(soap, "IEPEStatus", -1, &a->IEPEStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__InputStatus * SOAP_FMAC4 soap_get_ns__InputStatus(struct soap *soap, struct ns__InputStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__InputStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__InputStatus * SOAP_FMAC4 soap_in_ns__InputStatus(struct soap *soap, const char *tag, struct ns__InputStatus *a, const char *type)
{
	size_t soap_flag_OverloadLive = 1;
	size_t soap_flag_OverloadMeas = 1;
	size_t soap_flag_IEPEStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__InputStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__InputStatus, sizeof(struct ns__InputStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__InputStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OverloadLive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "OverloadLive", &a->OverloadLive, "xsd:int"))
				{	soap_flag_OverloadLive--;
					continue;
				}
			if (soap_flag_OverloadMeas && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "OverloadMeas", &a->OverloadMeas, "xsd:int"))
				{	soap_flag_OverloadMeas--;
					continue;
				}
			if (soap_flag_IEPEStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "IEPEStatus", &a->IEPEStatus, "xsd:int"))
				{	soap_flag_IEPEStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__InputStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__InputStatus, 0, sizeof(struct ns__InputStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OverloadLive > 0 || soap_flag_OverloadMeas > 0 || soap_flag_IEPEStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__InputStatus * SOAP_FMAC6 soap_new_ns__InputStatus(struct soap *soap, int n)
{	return soap_instantiate_ns__InputStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__InputStatus(struct soap *soap, struct ns__InputStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__InputStatus * SOAP_FMAC4 soap_instantiate_ns__InputStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__InputStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__InputStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__InputStatus;
		if (size)
			*size = sizeof(struct ns__InputStatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__InputStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__InputStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__InputStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__InputStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__InputStatus %p -> %p\n", q, p));
	*(struct ns__InputStatus*)p = *(struct ns__InputStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__StartCalibration(struct soap *soap, struct ns__StartCalibration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__StartCalibration(struct soap *soap, const struct ns__StartCalibration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__StartCalibration(struct soap *soap, const struct ns__StartCalibration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__StartCalibration);
	if (soap_out_ns__StartCalibration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__StartCalibration(struct soap *soap, const char *tag, int id, const struct ns__StartCalibration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__StartCalibration), type))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__StartCalibration * SOAP_FMAC4 soap_get_ns__StartCalibration(struct soap *soap, struct ns__StartCalibration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__StartCalibration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__StartCalibration * SOAP_FMAC4 soap_in_ns__StartCalibration(struct soap *soap, const char *tag, struct ns__StartCalibration *a, const char *type)
{
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__StartCalibration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__StartCalibration, sizeof(struct ns__StartCalibration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__StartCalibration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__StartCalibration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__StartCalibration, 0, sizeof(struct ns__StartCalibration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__StartCalibration * SOAP_FMAC6 soap_new_ns__StartCalibration(struct soap *soap, int n)
{	return soap_instantiate_ns__StartCalibration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__StartCalibration(struct soap *soap, struct ns__StartCalibration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__StartCalibration * SOAP_FMAC4 soap_instantiate_ns__StartCalibration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__StartCalibration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__StartCalibration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__StartCalibration;
		if (size)
			*size = sizeof(struct ns__StartCalibration);
	}
	else
	{	cp->ptr = (void*)new struct ns__StartCalibration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__StartCalibration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__StartCalibration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__StartCalibration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__StartCalibration %p -> %p\n", q, p));
	*(struct ns__StartCalibration*)p = *(struct ns__StartCalibration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ExecuteCommand(struct soap *soap, struct ns__ExecuteCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->command);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ExecuteCommand(struct soap *soap, const struct ns__ExecuteCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ExecuteCommand(struct soap *soap, const struct ns__ExecuteCommand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ExecuteCommand);
	if (soap_out_ns__ExecuteCommand(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ExecuteCommand(struct soap *soap, const char *tag, int id, const struct ns__ExecuteCommand *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ExecuteCommand), type))
		return soap->error;
	if (soap_out_int(soap, "command", -1, &a->command, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ExecuteCommand * SOAP_FMAC4 soap_get_ns__ExecuteCommand(struct soap *soap, struct ns__ExecuteCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ExecuteCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ExecuteCommand * SOAP_FMAC4 soap_in_ns__ExecuteCommand(struct soap *soap, const char *tag, struct ns__ExecuteCommand *a, const char *type)
{
	size_t soap_flag_command = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ExecuteCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ExecuteCommand, sizeof(struct ns__ExecuteCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ExecuteCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_command && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "command", &a->command, "xsd:int"))
				{	soap_flag_command--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ExecuteCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ExecuteCommand, 0, sizeof(struct ns__ExecuteCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_command > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ExecuteCommand * SOAP_FMAC6 soap_new_ns__ExecuteCommand(struct soap *soap, int n)
{	return soap_instantiate_ns__ExecuteCommand(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ExecuteCommand(struct soap *soap, struct ns__ExecuteCommand *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ExecuteCommand * SOAP_FMAC4 soap_instantiate_ns__ExecuteCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ExecuteCommand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ExecuteCommand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ExecuteCommand;
		if (size)
			*size = sizeof(struct ns__ExecuteCommand);
	}
	else
	{	cp->ptr = (void*)new struct ns__ExecuteCommand[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ExecuteCommand);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ExecuteCommand*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ExecuteCommand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ExecuteCommand %p -> %p\n", q, p));
	*(struct ns__ExecuteCommand*)p = *(struct ns__ExecuteCommand*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetStartInfo(struct soap *soap, struct ns__SetStartInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns__DateTime(soap, &a->startTime);
	soap_default_int(soap, &a->measurementNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetStartInfo(struct soap *soap, const struct ns__SetStartInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__DateTime(soap, &a->startTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetStartInfo(struct soap *soap, const struct ns__SetStartInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetStartInfo);
	if (soap_out_ns__SetStartInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetStartInfo(struct soap *soap, const char *tag, int id, const struct ns__SetStartInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetStartInfo), type))
		return soap->error;
	if (soap_out_ns__DateTime(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_int(soap, "measurementNr", -1, &a->measurementNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetStartInfo * SOAP_FMAC4 soap_get_ns__SetStartInfo(struct soap *soap, struct ns__SetStartInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetStartInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetStartInfo * SOAP_FMAC4 soap_in_ns__SetStartInfo(struct soap *soap, const char *tag, struct ns__SetStartInfo *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	size_t soap_flag_measurementNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetStartInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetStartInfo, sizeof(struct ns__SetStartInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetStartInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__DateTime(soap, "startTime", &a->startTime, "ns:DateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_measurementNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "measurementNr", &a->measurementNr, "xsd:int"))
				{	soap_flag_measurementNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetStartInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetStartInfo, 0, sizeof(struct ns__SetStartInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_measurementNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetStartInfo * SOAP_FMAC6 soap_new_ns__SetStartInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__SetStartInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetStartInfo(struct soap *soap, struct ns__SetStartInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetStartInfo * SOAP_FMAC4 soap_instantiate_ns__SetStartInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetStartInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetStartInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetStartInfo;
		if (size)
			*size = sizeof(struct ns__SetStartInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetStartInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetStartInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetStartInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetStartInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetStartInfo %p -> %p\n", q, p));
	*(struct ns__SetStartInfo*)p = *(struct ns__SetStartInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__PrepareStart(struct soap *soap, struct ns__PrepareStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__PrepareStart(struct soap *soap, const struct ns__PrepareStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__PrepareStart(struct soap *soap, const struct ns__PrepareStart *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__PrepareStart);
	if (soap_out_ns__PrepareStart(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PrepareStart(struct soap *soap, const char *tag, int id, const struct ns__PrepareStart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__PrepareStart), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__PrepareStart * SOAP_FMAC4 soap_get_ns__PrepareStart(struct soap *soap, struct ns__PrepareStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__PrepareStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__PrepareStart * SOAP_FMAC4 soap_in_ns__PrepareStart(struct soap *soap, const char *tag, struct ns__PrepareStart *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__PrepareStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__PrepareStart, sizeof(struct ns__PrepareStart), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__PrepareStart(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__PrepareStart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__PrepareStart, 0, sizeof(struct ns__PrepareStart), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__PrepareStart * SOAP_FMAC6 soap_new_ns__PrepareStart(struct soap *soap, int n)
{	return soap_instantiate_ns__PrepareStart(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__PrepareStart(struct soap *soap, struct ns__PrepareStart *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__PrepareStart * SOAP_FMAC4 soap_instantiate_ns__PrepareStart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__PrepareStart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__PrepareStart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__PrepareStart;
		if (size)
			*size = sizeof(struct ns__PrepareStart);
	}
	else
	{	cp->ptr = (void*)new struct ns__PrepareStart[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__PrepareStart);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__PrepareStart*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__PrepareStart(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__PrepareStart %p -> %p\n", q, p));
	*(struct ns__PrepareStart*)p = *(struct ns__PrepareStart*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__PrepareStartResponse(struct soap *soap, struct ns__PrepareStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->delayTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__PrepareStartResponse(struct soap *soap, const struct ns__PrepareStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &a->delayTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__PrepareStartResponse(struct soap *soap, const struct ns__PrepareStartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__PrepareStartResponse);
	if (soap_out_ns__PrepareStartResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PrepareStartResponse(struct soap *soap, const char *tag, int id, const struct ns__PrepareStartResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__PrepareStartResponse), type))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "delayTime", -1, &a->delayTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__PrepareStartResponse * SOAP_FMAC4 soap_get_ns__PrepareStartResponse(struct soap *soap, struct ns__PrepareStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__PrepareStartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__PrepareStartResponse * SOAP_FMAC4 soap_in_ns__PrepareStartResponse(struct soap *soap, const char *tag, struct ns__PrepareStartResponse *a, const char *type)
{
	size_t soap_flag_delayTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__PrepareStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__PrepareStartResponse, sizeof(struct ns__PrepareStartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__PrepareStartResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delayTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "delayTime", &a->delayTime, "xsd:double"))
				{	soap_flag_delayTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__PrepareStartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__PrepareStartResponse, 0, sizeof(struct ns__PrepareStartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__PrepareStartResponse * SOAP_FMAC6 soap_new_ns__PrepareStartResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__PrepareStartResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__PrepareStartResponse(struct soap *soap, struct ns__PrepareStartResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__PrepareStartResponse * SOAP_FMAC4 soap_instantiate_ns__PrepareStartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__PrepareStartResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__PrepareStartResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__PrepareStartResponse;
		if (size)
			*size = sizeof(struct ns__PrepareStartResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__PrepareStartResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__PrepareStartResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__PrepareStartResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__PrepareStartResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__PrepareStartResponse %p -> %p\n", q, p));
	*(struct ns__PrepareStartResponse*)p = *(struct ns__PrepareStartResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ReadWriteTwi(struct soap *soap, struct ns__ReadWriteTwi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_unsignedInt(soap, &a->amplifier);
	a->data.ns__DeviceData::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ReadWriteTwi(struct soap *soap, const struct ns__ReadWriteTwi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->data.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ReadWriteTwi(struct soap *soap, const struct ns__ReadWriteTwi *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ReadWriteTwi);
	if (soap_out_ns__ReadWriteTwi(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReadWriteTwi(struct soap *soap, const char *tag, int id, const struct ns__ReadWriteTwi *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ReadWriteTwi), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "amplifier", -1, &a->amplifier, ""))
		return soap->error;
	if (a->data.soap_out(soap, "data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ReadWriteTwi * SOAP_FMAC4 soap_get_ns__ReadWriteTwi(struct soap *soap, struct ns__ReadWriteTwi *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ReadWriteTwi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ReadWriteTwi * SOAP_FMAC4 soap_in_ns__ReadWriteTwi(struct soap *soap, const char *tag, struct ns__ReadWriteTwi *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_amplifier = 1;
	size_t soap_flag_data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ReadWriteTwi *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ReadWriteTwi, sizeof(struct ns__ReadWriteTwi), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__ReadWriteTwi(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_amplifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "amplifier", &a->amplifier, "xsd:unsignedInt"))
				{	soap_flag_amplifier--;
					continue;
				}
			if (soap_flag_data && soap->error == SOAP_TAG_MISMATCH)
				if (a->data.soap_in(soap, "data", "ns:DeviceData"))
				{	soap_flag_data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ReadWriteTwi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ReadWriteTwi, 0, sizeof(struct ns__ReadWriteTwi), 0, soap_copy_ns__ReadWriteTwi);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_amplifier > 0 || soap_flag_data > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ReadWriteTwi * SOAP_FMAC6 soap_new_ns__ReadWriteTwi(struct soap *soap, int n)
{	return soap_instantiate_ns__ReadWriteTwi(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ReadWriteTwi(struct soap *soap, struct ns__ReadWriteTwi *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ReadWriteTwi * SOAP_FMAC4 soap_instantiate_ns__ReadWriteTwi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ReadWriteTwi(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ReadWriteTwi, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ReadWriteTwi;
		if (size)
			*size = sizeof(struct ns__ReadWriteTwi);
	}
	else
	{	cp->ptr = (void*)new struct ns__ReadWriteTwi[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ReadWriteTwi);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ReadWriteTwi*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ReadWriteTwi(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ReadWriteTwi %p -> %p\n", q, p));
	*(struct ns__ReadWriteTwi*)p = *(struct ns__ReadWriteTwi*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ReadWriteTwiResponse(struct soap *soap, struct ns__ReadWriteTwiResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.ns__DeviceData::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ReadWriteTwiResponse(struct soap *soap, const struct ns__ReadWriteTwiResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ReadWriteTwiResponse(struct soap *soap, const struct ns__ReadWriteTwiResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ReadWriteTwiResponse);
	if (soap_out_ns__ReadWriteTwiResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReadWriteTwiResponse(struct soap *soap, const char *tag, int id, const struct ns__ReadWriteTwiResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ReadWriteTwiResponse), type))
		return soap->error;
	if (a->result.soap_out(soap, "result", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ReadWriteTwiResponse * SOAP_FMAC4 soap_get_ns__ReadWriteTwiResponse(struct soap *soap, struct ns__ReadWriteTwiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ReadWriteTwiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ReadWriteTwiResponse * SOAP_FMAC4 soap_in_ns__ReadWriteTwiResponse(struct soap *soap, const char *tag, struct ns__ReadWriteTwiResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ReadWriteTwiResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ReadWriteTwiResponse, sizeof(struct ns__ReadWriteTwiResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__ReadWriteTwiResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (a->result.soap_in(soap, "result", "ns:DeviceData"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ReadWriteTwiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ReadWriteTwiResponse, 0, sizeof(struct ns__ReadWriteTwiResponse), 0, soap_copy_ns__ReadWriteTwiResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ReadWriteTwiResponse * SOAP_FMAC6 soap_new_ns__ReadWriteTwiResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__ReadWriteTwiResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ReadWriteTwiResponse(struct soap *soap, struct ns__ReadWriteTwiResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ReadWriteTwiResponse * SOAP_FMAC4 soap_instantiate_ns__ReadWriteTwiResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ReadWriteTwiResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ReadWriteTwiResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ReadWriteTwiResponse;
		if (size)
			*size = sizeof(struct ns__ReadWriteTwiResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__ReadWriteTwiResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ReadWriteTwiResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ReadWriteTwiResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ReadWriteTwiResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ReadWriteTwiResponse %p -> %p\n", q, p));
	*(struct ns__ReadWriteTwiResponse*)p = *(struct ns__ReadWriteTwiResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ReadDev(struct soap *soap, struct ns__ReadDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->type);
	soap_default_unsignedInt(soap, &a->count);
	soap_default_unsignedInt(soap, &a->aux1);
	soap_default_unsignedInt(soap, &a->aux2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ReadDev(struct soap *soap, const struct ns__ReadDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ReadDev(struct soap *soap, const struct ns__ReadDev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ReadDev);
	if (soap_out_ns__ReadDev(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReadDev(struct soap *soap, const char *tag, int id, const struct ns__ReadDev *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ReadDev), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "count", -1, &a->count, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "aux1", -1, &a->aux1, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "aux2", -1, &a->aux2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ReadDev * SOAP_FMAC4 soap_get_ns__ReadDev(struct soap *soap, struct ns__ReadDev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ReadDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ReadDev * SOAP_FMAC4 soap_in_ns__ReadDev(struct soap *soap, const char *tag, struct ns__ReadDev *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_count = 1;
	size_t soap_flag_aux1 = 1;
	size_t soap_flag_aux2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ReadDev *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ReadDev, sizeof(struct ns__ReadDev), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ReadDev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "count", &a->count, "xsd:unsignedInt"))
				{	soap_flag_count--;
					continue;
				}
			if (soap_flag_aux1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "aux1", &a->aux1, "xsd:unsignedInt"))
				{	soap_flag_aux1--;
					continue;
				}
			if (soap_flag_aux2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "aux2", &a->aux2, "xsd:unsignedInt"))
				{	soap_flag_aux2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ReadDev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ReadDev, 0, sizeof(struct ns__ReadDev), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_type > 0 || soap_flag_count > 0 || soap_flag_aux1 > 0 || soap_flag_aux2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ReadDev * SOAP_FMAC6 soap_new_ns__ReadDev(struct soap *soap, int n)
{	return soap_instantiate_ns__ReadDev(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ReadDev(struct soap *soap, struct ns__ReadDev *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ReadDev * SOAP_FMAC4 soap_instantiate_ns__ReadDev(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ReadDev(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ReadDev, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ReadDev;
		if (size)
			*size = sizeof(struct ns__ReadDev);
	}
	else
	{	cp->ptr = (void*)new struct ns__ReadDev[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ReadDev);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ReadDev*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ReadDev(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ReadDev %p -> %p\n", q, p));
	*(struct ns__ReadDev*)p = *(struct ns__ReadDev*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ReadDevResponse(struct soap *soap, struct ns__ReadDevResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.ns__DeviceData::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ReadDevResponse(struct soap *soap, const struct ns__ReadDevResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ReadDevResponse(struct soap *soap, const struct ns__ReadDevResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ReadDevResponse);
	if (soap_out_ns__ReadDevResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReadDevResponse(struct soap *soap, const char *tag, int id, const struct ns__ReadDevResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ReadDevResponse), type))
		return soap->error;
	if (a->result.soap_out(soap, "result", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ReadDevResponse * SOAP_FMAC4 soap_get_ns__ReadDevResponse(struct soap *soap, struct ns__ReadDevResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ReadDevResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ReadDevResponse * SOAP_FMAC4 soap_in_ns__ReadDevResponse(struct soap *soap, const char *tag, struct ns__ReadDevResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ReadDevResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ReadDevResponse, sizeof(struct ns__ReadDevResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__ReadDevResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (a->result.soap_in(soap, "result", "ns:DeviceData"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ReadDevResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ReadDevResponse, 0, sizeof(struct ns__ReadDevResponse), 0, soap_copy_ns__ReadDevResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ReadDevResponse * SOAP_FMAC6 soap_new_ns__ReadDevResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__ReadDevResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ReadDevResponse(struct soap *soap, struct ns__ReadDevResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ReadDevResponse * SOAP_FMAC4 soap_instantiate_ns__ReadDevResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ReadDevResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ReadDevResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ReadDevResponse;
		if (size)
			*size = sizeof(struct ns__ReadDevResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__ReadDevResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ReadDevResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ReadDevResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ReadDevResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ReadDevResponse %p -> %p\n", q, p));
	*(struct ns__ReadDevResponse*)p = *(struct ns__ReadDevResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__WriteDev(struct soap *soap, struct ns__WriteDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->type);
	a->data.ns__DeviceData::soap_default(soap);
	soap_default_unsignedInt(soap, &a->aux1);
	soap_default_unsignedInt(soap, &a->aux2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__WriteDev(struct soap *soap, const struct ns__WriteDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->data.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__WriteDev(struct soap *soap, const struct ns__WriteDev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__WriteDev);
	if (soap_out_ns__WriteDev(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__WriteDev(struct soap *soap, const char *tag, int id, const struct ns__WriteDev *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__WriteDev), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (a->data.soap_out(soap, "data", -1, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "aux1", -1, &a->aux1, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "aux2", -1, &a->aux2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__WriteDev * SOAP_FMAC4 soap_get_ns__WriteDev(struct soap *soap, struct ns__WriteDev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__WriteDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__WriteDev * SOAP_FMAC4 soap_in_ns__WriteDev(struct soap *soap, const char *tag, struct ns__WriteDev *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_data = 1;
	size_t soap_flag_aux1 = 1;
	size_t soap_flag_aux2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__WriteDev *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__WriteDev, sizeof(struct ns__WriteDev), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__WriteDev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_data && soap->error == SOAP_TAG_MISMATCH)
				if (a->data.soap_in(soap, "data", "ns:DeviceData"))
				{	soap_flag_data--;
					continue;
				}
			if (soap_flag_aux1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "aux1", &a->aux1, "xsd:unsignedInt"))
				{	soap_flag_aux1--;
					continue;
				}
			if (soap_flag_aux2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "aux2", &a->aux2, "xsd:unsignedInt"))
				{	soap_flag_aux2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__WriteDev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__WriteDev, 0, sizeof(struct ns__WriteDev), 0, soap_copy_ns__WriteDev);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_type > 0 || soap_flag_data > 0 || soap_flag_aux1 > 0 || soap_flag_aux2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__WriteDev * SOAP_FMAC6 soap_new_ns__WriteDev(struct soap *soap, int n)
{	return soap_instantiate_ns__WriteDev(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__WriteDev(struct soap *soap, struct ns__WriteDev *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__WriteDev * SOAP_FMAC4 soap_instantiate_ns__WriteDev(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__WriteDev(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__WriteDev, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__WriteDev;
		if (size)
			*size = sizeof(struct ns__WriteDev);
	}
	else
	{	cp->ptr = (void*)new struct ns__WriteDev[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__WriteDev);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__WriteDev*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__WriteDev(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__WriteDev %p -> %p\n", q, p));
	*(struct ns__WriteDev*)p = *(struct ns__WriteDev*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetGPSLogList(struct soap *soap, struct ns__GetGPSLogList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->from);
	soap_default_int(soap, &a->to);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetGPSLogList(struct soap *soap, const struct ns__GetGPSLogList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetGPSLogList(struct soap *soap, const struct ns__GetGPSLogList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetGPSLogList);
	if (soap_out_ns__GetGPSLogList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetGPSLogList(struct soap *soap, const char *tag, int id, const struct ns__GetGPSLogList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetGPSLogList), type))
		return soap->error;
	if (soap_out_int(soap, "from", -1, &a->from, ""))
		return soap->error;
	if (soap_out_int(soap, "to", -1, &a->to, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetGPSLogList * SOAP_FMAC4 soap_get_ns__GetGPSLogList(struct soap *soap, struct ns__GetGPSLogList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetGPSLogList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetGPSLogList * SOAP_FMAC4 soap_in_ns__GetGPSLogList(struct soap *soap, const char *tag, struct ns__GetGPSLogList *a, const char *type)
{
	size_t soap_flag_from = 1;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetGPSLogList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetGPSLogList, sizeof(struct ns__GetGPSLogList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetGPSLogList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "from", &a->from, "xsd:int"))
				{	soap_flag_from--;
					continue;
				}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "to", &a->to, "xsd:int"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetGPSLogList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetGPSLogList, 0, sizeof(struct ns__GetGPSLogList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || soap_flag_to > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetGPSLogList * SOAP_FMAC6 soap_new_ns__GetGPSLogList(struct soap *soap, int n)
{	return soap_instantiate_ns__GetGPSLogList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetGPSLogList(struct soap *soap, struct ns__GetGPSLogList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetGPSLogList * SOAP_FMAC4 soap_instantiate_ns__GetGPSLogList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetGPSLogList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetGPSLogList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetGPSLogList;
		if (size)
			*size = sizeof(struct ns__GetGPSLogList);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetGPSLogList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetGPSLogList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetGPSLogList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetGPSLogList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetGPSLogList %p -> %p\n", q, p));
	*(struct ns__GetGPSLogList*)p = *(struct ns__GetGPSLogList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetGPSLogListResponse(struct soap *soap, struct ns__GetGPSLogListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns__GPSLogList(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetGPSLogListResponse(struct soap *soap, const struct ns__GetGPSLogListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__GPSLogList(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetGPSLogListResponse(struct soap *soap, const struct ns__GetGPSLogListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetGPSLogListResponse);
	if (soap_out_ns__GetGPSLogListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetGPSLogListResponse(struct soap *soap, const char *tag, int id, const struct ns__GetGPSLogListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetGPSLogListResponse), type))
		return soap->error;
	if (soap_out_ns__GPSLogList(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetGPSLogListResponse * SOAP_FMAC4 soap_get_ns__GetGPSLogListResponse(struct soap *soap, struct ns__GetGPSLogListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetGPSLogListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetGPSLogListResponse * SOAP_FMAC4 soap_in_ns__GetGPSLogListResponse(struct soap *soap, const char *tag, struct ns__GetGPSLogListResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetGPSLogListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetGPSLogListResponse, sizeof(struct ns__GetGPSLogListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetGPSLogListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__GPSLogList(soap, "result", &a->result, "ns:GPSLogList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetGPSLogListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetGPSLogListResponse, 0, sizeof(struct ns__GetGPSLogListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetGPSLogListResponse * SOAP_FMAC6 soap_new_ns__GetGPSLogListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetGPSLogListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetGPSLogListResponse(struct soap *soap, struct ns__GetGPSLogListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetGPSLogListResponse * SOAP_FMAC4 soap_instantiate_ns__GetGPSLogListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetGPSLogListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetGPSLogListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetGPSLogListResponse;
		if (size)
			*size = sizeof(struct ns__GetGPSLogListResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetGPSLogListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetGPSLogListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetGPSLogListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetGPSLogListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetGPSLogListResponse %p -> %p\n", q, p));
	*(struct ns__GetGPSLogListResponse*)p = *(struct ns__GetGPSLogListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GPSLogList(struct soap *soap, struct ns__GPSLogList *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GPSLogList(struct soap *soap, struct ns__GPSLogList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ns__GPSLogList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_ns__GPSLog);
			soap_serialize_ns__GPSLog(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GPSLogList(struct soap *soap, const struct ns__GPSLogList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns__GPSLogList);
	if (soap_out_ns__GPSLogList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GPSLogList(struct soap *soap, const char *tag, int id, const struct ns__GPSLogList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__GPSLogList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__GPSLog(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GPSLogList * SOAP_FMAC4 soap_get_ns__GPSLogList(struct soap *soap, struct ns__GPSLogList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GPSLogList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GPSLogList * SOAP_FMAC4 soap_in_ns__GPSLogList(struct soap *soap, const char *tag, struct ns__GPSLogList *a, const char *type)
{	int i, j;
	struct ns__GPSLog *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:GPSLog") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__GPSLogList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GPSLogList, sizeof(struct ns__GPSLogList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GPSLogList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__GPSLog *)soap_malloc(soap, sizeof(struct ns__GPSLog) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__GPSLog(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__GPSLog(soap, NULL, a->__ptr + i, "ns:GPSLog"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__GPSLog *)soap_push_block(soap, NULL, sizeof(struct ns__GPSLog));
				if (!p)
					return NULL;
				soap_default_ns__GPSLog(soap, p);
				if (!soap_in_ns__GPSLog(soap, NULL, p, "ns:GPSLog"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__GPSLog *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GPSLogList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GPSLogList, 0, sizeof(struct ns__GPSLogList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GPSLogList * SOAP_FMAC6 soap_new_ns__GPSLogList(struct soap *soap, int n)
{	return soap_instantiate_ns__GPSLogList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GPSLogList(struct soap *soap, struct ns__GPSLogList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GPSLogList * SOAP_FMAC4 soap_instantiate_ns__GPSLogList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GPSLogList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GPSLogList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GPSLogList;
		if (size)
			*size = sizeof(struct ns__GPSLogList);
	}
	else
	{	cp->ptr = (void*)new struct ns__GPSLogList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GPSLogList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GPSLogList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GPSLogList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GPSLogList %p -> %p\n", q, p));
	*(struct ns__GPSLogList*)p = *(struct ns__GPSLogList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GPSLog(struct soap *soap, struct ns__GPSLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_Array128Ofbyte(soap, a->GPSFrame);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GPSLog(struct soap *soap, const struct ns__GPSLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array128Ofbyte(soap, a->GPSFrame);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GPSLog(struct soap *soap, const struct ns__GPSLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GPSLog);
	if (soap_out_ns__GPSLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GPSLog(struct soap *soap, const char *tag, int id, const struct ns__GPSLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GPSLog), type))
		return soap->error;
	soap_out_Array128Ofbyte(soap, "GPSFrame", -1, a->GPSFrame, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GPSLog * SOAP_FMAC4 soap_get_ns__GPSLog(struct soap *soap, struct ns__GPSLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GPSLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GPSLog * SOAP_FMAC4 soap_in_ns__GPSLog(struct soap *soap, const char *tag, struct ns__GPSLog *a, const char *type)
{
	size_t soap_flag_GPSFrame = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GPSLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GPSLog, sizeof(struct ns__GPSLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GPSLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GPSFrame && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array128Ofbyte(soap, "GPSFrame", a->GPSFrame, "xsd:byte"))
				{	soap_flag_GPSFrame--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GPSLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GPSLog, 0, sizeof(struct ns__GPSLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GPSFrame > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GPSLog * SOAP_FMAC6 soap_new_ns__GPSLog(struct soap *soap, int n)
{	return soap_instantiate_ns__GPSLog(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GPSLog(struct soap *soap, struct ns__GPSLog *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GPSLog * SOAP_FMAC4 soap_instantiate_ns__GPSLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GPSLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GPSLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GPSLog;
		if (size)
			*size = sizeof(struct ns__GPSLog);
	}
	else
	{	cp->ptr = (void*)new struct ns__GPSLog[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GPSLog);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GPSLog*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GPSLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GPSLog %p -> %p\n", q, p));
	*(struct ns__GPSLog*)p = *(struct ns__GPSLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAssociations(struct soap *soap, struct ns__SetAssociations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns__AssociationRowList(soap, &a->associations);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAssociations(struct soap *soap, const struct ns__SetAssociations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__AssociationRowList(soap, &a->associations);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAssociations(struct soap *soap, const struct ns__SetAssociations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetAssociations);
	if (soap_out_ns__SetAssociations(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAssociations(struct soap *soap, const char *tag, int id, const struct ns__SetAssociations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetAssociations), type))
		return soap->error;
	if (soap_out_ns__AssociationRowList(soap, "associations", -1, &a->associations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetAssociations * SOAP_FMAC4 soap_get_ns__SetAssociations(struct soap *soap, struct ns__SetAssociations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetAssociations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetAssociations * SOAP_FMAC4 soap_in_ns__SetAssociations(struct soap *soap, const char *tag, struct ns__SetAssociations *a, const char *type)
{
	size_t soap_flag_associations = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetAssociations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetAssociations, sizeof(struct ns__SetAssociations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetAssociations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_associations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AssociationRowList(soap, "associations", &a->associations, "ns:AssociationRowList"))
				{	soap_flag_associations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetAssociations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetAssociations, 0, sizeof(struct ns__SetAssociations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_associations > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetAssociations * SOAP_FMAC6 soap_new_ns__SetAssociations(struct soap *soap, int n)
{	return soap_instantiate_ns__SetAssociations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetAssociations(struct soap *soap, struct ns__SetAssociations *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetAssociations * SOAP_FMAC4 soap_instantiate_ns__SetAssociations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetAssociations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetAssociations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetAssociations;
		if (size)
			*size = sizeof(struct ns__SetAssociations);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetAssociations[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetAssociations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetAssociations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetAssociations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetAssociations %p -> %p\n", q, p));
	*(struct ns__SetAssociations*)p = *(struct ns__SetAssociations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllPreviousAssociations(struct soap *soap, struct ns__GetAllPreviousAssociations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->currentMeasurementNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllPreviousAssociations(struct soap *soap, const struct ns__GetAllPreviousAssociations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllPreviousAssociations(struct soap *soap, const struct ns__GetAllPreviousAssociations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllPreviousAssociations);
	if (soap_out_ns__GetAllPreviousAssociations(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllPreviousAssociations(struct soap *soap, const char *tag, int id, const struct ns__GetAllPreviousAssociations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllPreviousAssociations), type))
		return soap->error;
	if (soap_out_int(soap, "currentMeasurementNumber", -1, &a->currentMeasurementNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllPreviousAssociations * SOAP_FMAC4 soap_get_ns__GetAllPreviousAssociations(struct soap *soap, struct ns__GetAllPreviousAssociations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllPreviousAssociations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllPreviousAssociations * SOAP_FMAC4 soap_in_ns__GetAllPreviousAssociations(struct soap *soap, const char *tag, struct ns__GetAllPreviousAssociations *a, const char *type)
{
	size_t soap_flag_currentMeasurementNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllPreviousAssociations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllPreviousAssociations, sizeof(struct ns__GetAllPreviousAssociations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllPreviousAssociations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentMeasurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentMeasurementNumber", &a->currentMeasurementNumber, "xsd:int"))
				{	soap_flag_currentMeasurementNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllPreviousAssociations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllPreviousAssociations, 0, sizeof(struct ns__GetAllPreviousAssociations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentMeasurementNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllPreviousAssociations * SOAP_FMAC6 soap_new_ns__GetAllPreviousAssociations(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllPreviousAssociations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllPreviousAssociations(struct soap *soap, struct ns__GetAllPreviousAssociations *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllPreviousAssociations * SOAP_FMAC4 soap_instantiate_ns__GetAllPreviousAssociations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllPreviousAssociations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllPreviousAssociations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAssociations;
		if (size)
			*size = sizeof(struct ns__GetAllPreviousAssociations);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAssociations[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllPreviousAssociations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllPreviousAssociations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllPreviousAssociations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllPreviousAssociations %p -> %p\n", q, p));
	*(struct ns__GetAllPreviousAssociations*)p = *(struct ns__GetAllPreviousAssociations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllPreviousAssociationsResponse(struct soap *soap, struct ns__GetAllPreviousAssociationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns__AssociationRowList(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllPreviousAssociationsResponse(struct soap *soap, const struct ns__GetAllPreviousAssociationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__AssociationRowList(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllPreviousAssociationsResponse(struct soap *soap, const struct ns__GetAllPreviousAssociationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllPreviousAssociationsResponse);
	if (soap_out_ns__GetAllPreviousAssociationsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllPreviousAssociationsResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllPreviousAssociationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllPreviousAssociationsResponse), type))
		return soap->error;
	if (soap_out_ns__AssociationRowList(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllPreviousAssociationsResponse * SOAP_FMAC4 soap_get_ns__GetAllPreviousAssociationsResponse(struct soap *soap, struct ns__GetAllPreviousAssociationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllPreviousAssociationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllPreviousAssociationsResponse * SOAP_FMAC4 soap_in_ns__GetAllPreviousAssociationsResponse(struct soap *soap, const char *tag, struct ns__GetAllPreviousAssociationsResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllPreviousAssociationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllPreviousAssociationsResponse, sizeof(struct ns__GetAllPreviousAssociationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllPreviousAssociationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AssociationRowList(soap, "result", &a->result, "ns:AssociationRowList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllPreviousAssociationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllPreviousAssociationsResponse, 0, sizeof(struct ns__GetAllPreviousAssociationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllPreviousAssociationsResponse * SOAP_FMAC6 soap_new_ns__GetAllPreviousAssociationsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllPreviousAssociationsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllPreviousAssociationsResponse(struct soap *soap, struct ns__GetAllPreviousAssociationsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllPreviousAssociationsResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllPreviousAssociationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllPreviousAssociationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllPreviousAssociationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAssociationsResponse;
		if (size)
			*size = sizeof(struct ns__GetAllPreviousAssociationsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAssociationsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllPreviousAssociationsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllPreviousAssociationsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllPreviousAssociationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllPreviousAssociationsResponse %p -> %p\n", q, p));
	*(struct ns__GetAllPreviousAssociationsResponse*)p = *(struct ns__GetAllPreviousAssociationsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllCurrentAssociations(struct soap *soap, struct ns__GetAllCurrentAssociations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllCurrentAssociations(struct soap *soap, const struct ns__GetAllCurrentAssociations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllCurrentAssociations(struct soap *soap, const struct ns__GetAllCurrentAssociations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllCurrentAssociations);
	if (soap_out_ns__GetAllCurrentAssociations(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllCurrentAssociations(struct soap *soap, const char *tag, int id, const struct ns__GetAllCurrentAssociations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllCurrentAssociations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllCurrentAssociations * SOAP_FMAC4 soap_get_ns__GetAllCurrentAssociations(struct soap *soap, struct ns__GetAllCurrentAssociations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllCurrentAssociations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllCurrentAssociations * SOAP_FMAC4 soap_in_ns__GetAllCurrentAssociations(struct soap *soap, const char *tag, struct ns__GetAllCurrentAssociations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllCurrentAssociations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllCurrentAssociations, sizeof(struct ns__GetAllCurrentAssociations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllCurrentAssociations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllCurrentAssociations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllCurrentAssociations, 0, sizeof(struct ns__GetAllCurrentAssociations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllCurrentAssociations * SOAP_FMAC6 soap_new_ns__GetAllCurrentAssociations(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllCurrentAssociations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllCurrentAssociations(struct soap *soap, struct ns__GetAllCurrentAssociations *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllCurrentAssociations * SOAP_FMAC4 soap_instantiate_ns__GetAllCurrentAssociations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllCurrentAssociations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllCurrentAssociations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAssociations;
		if (size)
			*size = sizeof(struct ns__GetAllCurrentAssociations);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAssociations[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllCurrentAssociations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllCurrentAssociations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllCurrentAssociations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllCurrentAssociations %p -> %p\n", q, p));
	*(struct ns__GetAllCurrentAssociations*)p = *(struct ns__GetAllCurrentAssociations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllCurrentAssociationsResponse(struct soap *soap, struct ns__GetAllCurrentAssociationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns__AssociationRowList(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllCurrentAssociationsResponse(struct soap *soap, const struct ns__GetAllCurrentAssociationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__AssociationRowList(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllCurrentAssociationsResponse(struct soap *soap, const struct ns__GetAllCurrentAssociationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllCurrentAssociationsResponse);
	if (soap_out_ns__GetAllCurrentAssociationsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllCurrentAssociationsResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllCurrentAssociationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllCurrentAssociationsResponse), type))
		return soap->error;
	if (soap_out_ns__AssociationRowList(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllCurrentAssociationsResponse * SOAP_FMAC4 soap_get_ns__GetAllCurrentAssociationsResponse(struct soap *soap, struct ns__GetAllCurrentAssociationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllCurrentAssociationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllCurrentAssociationsResponse * SOAP_FMAC4 soap_in_ns__GetAllCurrentAssociationsResponse(struct soap *soap, const char *tag, struct ns__GetAllCurrentAssociationsResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllCurrentAssociationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllCurrentAssociationsResponse, sizeof(struct ns__GetAllCurrentAssociationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllCurrentAssociationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AssociationRowList(soap, "result", &a->result, "ns:AssociationRowList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllCurrentAssociationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllCurrentAssociationsResponse, 0, sizeof(struct ns__GetAllCurrentAssociationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllCurrentAssociationsResponse * SOAP_FMAC6 soap_new_ns__GetAllCurrentAssociationsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllCurrentAssociationsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllCurrentAssociationsResponse(struct soap *soap, struct ns__GetAllCurrentAssociationsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllCurrentAssociationsResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllCurrentAssociationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllCurrentAssociationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllCurrentAssociationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAssociationsResponse;
		if (size)
			*size = sizeof(struct ns__GetAllCurrentAssociationsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAssociationsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllCurrentAssociationsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllCurrentAssociationsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllCurrentAssociationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllCurrentAssociationsResponse %p -> %p\n", q, p));
	*(struct ns__GetAllCurrentAssociationsResponse*)p = *(struct ns__GetAllCurrentAssociationsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssociationRowList(struct soap *soap, struct ns__AssociationRowList *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssociationRowList(struct soap *soap, struct ns__AssociationRowList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ns__AssociationRowList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_ns__AssociationRow);
			soap_serialize_ns__AssociationRow(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssociationRowList(struct soap *soap, const struct ns__AssociationRowList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns__AssociationRowList);
	if (soap_out_ns__AssociationRowList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssociationRowList(struct soap *soap, const char *tag, int id, const struct ns__AssociationRowList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__AssociationRowList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__AssociationRow(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AssociationRowList * SOAP_FMAC4 soap_get_ns__AssociationRowList(struct soap *soap, struct ns__AssociationRowList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AssociationRowList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AssociationRowList * SOAP_FMAC4 soap_in_ns__AssociationRowList(struct soap *soap, const char *tag, struct ns__AssociationRowList *a, const char *type)
{	int i, j;
	struct ns__AssociationRow *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:AssociationRow") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__AssociationRowList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AssociationRowList, sizeof(struct ns__AssociationRowList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__AssociationRowList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__AssociationRow *)soap_malloc(soap, sizeof(struct ns__AssociationRow) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__AssociationRow(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__AssociationRow(soap, NULL, a->__ptr + i, "ns:AssociationRow"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__AssociationRow *)soap_push_block(soap, NULL, sizeof(struct ns__AssociationRow));
				if (!p)
					return NULL;
				soap_default_ns__AssociationRow(soap, p);
				if (!soap_in_ns__AssociationRow(soap, NULL, p, "ns:AssociationRow"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__AssociationRow *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__AssociationRowList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AssociationRowList, 0, sizeof(struct ns__AssociationRowList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__AssociationRowList * SOAP_FMAC6 soap_new_ns__AssociationRowList(struct soap *soap, int n)
{	return soap_instantiate_ns__AssociationRowList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AssociationRowList(struct soap *soap, struct ns__AssociationRowList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__AssociationRowList * SOAP_FMAC4 soap_instantiate_ns__AssociationRowList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AssociationRowList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AssociationRowList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__AssociationRowList;
		if (size)
			*size = sizeof(struct ns__AssociationRowList);
	}
	else
	{	cp->ptr = (void*)new struct ns__AssociationRowList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__AssociationRowList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__AssociationRowList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AssociationRowList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__AssociationRowList %p -> %p\n", q, p));
	*(struct ns__AssociationRowList*)p = *(struct ns__AssociationRowList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssociationRow(struct soap *soap, struct ns__AssociationRow *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->boardAddress);
	soap_default_unsignedInt(soap, &a->inputNumber);
	soap_default_ns__AssociationChannelList(soap, &a->associatedChannels);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssociationRow(struct soap *soap, const struct ns__AssociationRow *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__AssociationChannelList(soap, &a->associatedChannels);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssociationRow(struct soap *soap, const struct ns__AssociationRow *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AssociationRow);
	if (soap_out_ns__AssociationRow(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssociationRow(struct soap *soap, const char *tag, int id, const struct ns__AssociationRow *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AssociationRow), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	if (soap_out_ns__AssociationChannelList(soap, "associatedChannels", -1, &a->associatedChannels, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AssociationRow * SOAP_FMAC4 soap_get_ns__AssociationRow(struct soap *soap, struct ns__AssociationRow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AssociationRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AssociationRow * SOAP_FMAC4 soap_in_ns__AssociationRow(struct soap *soap, const char *tag, struct ns__AssociationRow *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	size_t soap_flag_associatedChannels = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AssociationRow *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AssociationRow, sizeof(struct ns__AssociationRow), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__AssociationRow(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boardAddress", &a->boardAddress, "xsd:unsignedInt"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "inputNumber", &a->inputNumber, "xsd:unsignedInt"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap_flag_associatedChannels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AssociationChannelList(soap, "associatedChannels", &a->associatedChannels, "ns:AssociationChannelList"))
				{	soap_flag_associatedChannels--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__AssociationRow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AssociationRow, 0, sizeof(struct ns__AssociationRow), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0 || soap_flag_associatedChannels > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__AssociationRow * SOAP_FMAC6 soap_new_ns__AssociationRow(struct soap *soap, int n)
{	return soap_instantiate_ns__AssociationRow(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AssociationRow(struct soap *soap, struct ns__AssociationRow *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__AssociationRow * SOAP_FMAC4 soap_instantiate_ns__AssociationRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AssociationRow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AssociationRow, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__AssociationRow;
		if (size)
			*size = sizeof(struct ns__AssociationRow);
	}
	else
	{	cp->ptr = (void*)new struct ns__AssociationRow[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__AssociationRow);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__AssociationRow*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AssociationRow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__AssociationRow %p -> %p\n", q, p));
	*(struct ns__AssociationRow*)p = *(struct ns__AssociationRow*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssociationChannelList(struct soap *soap, struct ns__AssociationChannelList *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssociationChannelList(struct soap *soap, struct ns__AssociationChannelList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ns__AssociationChannelList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_ns__AssociationChannel);
			soap_serialize_ns__AssociationChannel(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssociationChannelList(struct soap *soap, const struct ns__AssociationChannelList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns__AssociationChannelList);
	if (soap_out_ns__AssociationChannelList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssociationChannelList(struct soap *soap, const char *tag, int id, const struct ns__AssociationChannelList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__AssociationChannelList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_ns__AssociationChannel(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AssociationChannelList * SOAP_FMAC4 soap_get_ns__AssociationChannelList(struct soap *soap, struct ns__AssociationChannelList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AssociationChannelList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AssociationChannelList * SOAP_FMAC4 soap_in_ns__AssociationChannelList(struct soap *soap, const char *tag, struct ns__AssociationChannelList *a, const char *type)
{	int i, j;
	struct ns__AssociationChannel *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:AssociationChannel") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__AssociationChannelList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AssociationChannelList, sizeof(struct ns__AssociationChannelList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__AssociationChannelList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__AssociationChannel *)soap_malloc(soap, sizeof(struct ns__AssociationChannel) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__AssociationChannel(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__AssociationChannel(soap, NULL, a->__ptr + i, "ns:AssociationChannel"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__AssociationChannel *)soap_push_block(soap, NULL, sizeof(struct ns__AssociationChannel));
				if (!p)
					return NULL;
				soap_default_ns__AssociationChannel(soap, p);
				if (!soap_in_ns__AssociationChannel(soap, NULL, p, "ns:AssociationChannel"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns__AssociationChannel *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__AssociationChannelList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AssociationChannelList, 0, sizeof(struct ns__AssociationChannelList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__AssociationChannelList * SOAP_FMAC6 soap_new_ns__AssociationChannelList(struct soap *soap, int n)
{	return soap_instantiate_ns__AssociationChannelList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AssociationChannelList(struct soap *soap, struct ns__AssociationChannelList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__AssociationChannelList * SOAP_FMAC4 soap_instantiate_ns__AssociationChannelList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AssociationChannelList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AssociationChannelList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__AssociationChannelList;
		if (size)
			*size = sizeof(struct ns__AssociationChannelList);
	}
	else
	{	cp->ptr = (void*)new struct ns__AssociationChannelList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__AssociationChannelList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__AssociationChannelList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AssociationChannelList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__AssociationChannelList %p -> %p\n", q, p));
	*(struct ns__AssociationChannelList*)p = *(struct ns__AssociationChannelList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssociationChannel(struct soap *soap, struct ns__AssociationChannel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->boardAddress);
	soap_default_unsignedInt(soap, &a->inputNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssociationChannel(struct soap *soap, const struct ns__AssociationChannel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssociationChannel(struct soap *soap, const struct ns__AssociationChannel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AssociationChannel);
	if (soap_out_ns__AssociationChannel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssociationChannel(struct soap *soap, const char *tag, int id, const struct ns__AssociationChannel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AssociationChannel), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AssociationChannel * SOAP_FMAC4 soap_get_ns__AssociationChannel(struct soap *soap, struct ns__AssociationChannel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AssociationChannel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AssociationChannel * SOAP_FMAC4 soap_in_ns__AssociationChannel(struct soap *soap, const char *tag, struct ns__AssociationChannel *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AssociationChannel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AssociationChannel, sizeof(struct ns__AssociationChannel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__AssociationChannel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boardAddress", &a->boardAddress, "xsd:unsignedInt"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "inputNumber", &a->inputNumber, "xsd:unsignedInt"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__AssociationChannel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AssociationChannel, 0, sizeof(struct ns__AssociationChannel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__AssociationChannel * SOAP_FMAC6 soap_new_ns__AssociationChannel(struct soap *soap, int n)
{	return soap_instantiate_ns__AssociationChannel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AssociationChannel(struct soap *soap, struct ns__AssociationChannel *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__AssociationChannel * SOAP_FMAC4 soap_instantiate_ns__AssociationChannel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AssociationChannel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AssociationChannel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__AssociationChannel;
		if (size)
			*size = sizeof(struct ns__AssociationChannel);
	}
	else
	{	cp->ptr = (void*)new struct ns__AssociationChannel[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__AssociationChannel);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__AssociationChannel*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AssociationChannel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__AssociationChannel %p -> %p\n", q, p));
	*(struct ns__AssociationChannel*)p = *(struct ns__AssociationChannel*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetCANTrigger(struct soap *soap, struct ns__GetCANTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetCANTrigger(struct soap *soap, const struct ns__GetCANTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetCANTrigger(struct soap *soap, const struct ns__GetCANTrigger *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetCANTrigger);
	if (soap_out_ns__GetCANTrigger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetCANTrigger(struct soap *soap, const char *tag, int id, const struct ns__GetCANTrigger *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetCANTrigger), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetCANTrigger * SOAP_FMAC4 soap_get_ns__GetCANTrigger(struct soap *soap, struct ns__GetCANTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetCANTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetCANTrigger * SOAP_FMAC4 soap_in_ns__GetCANTrigger(struct soap *soap, const char *tag, struct ns__GetCANTrigger *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetCANTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetCANTrigger, sizeof(struct ns__GetCANTrigger), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetCANTrigger(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetCANTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetCANTrigger, 0, sizeof(struct ns__GetCANTrigger), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetCANTrigger * SOAP_FMAC6 soap_new_ns__GetCANTrigger(struct soap *soap, int n)
{	return soap_instantiate_ns__GetCANTrigger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetCANTrigger(struct soap *soap, struct ns__GetCANTrigger *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetCANTrigger * SOAP_FMAC4 soap_instantiate_ns__GetCANTrigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetCANTrigger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetCANTrigger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetCANTrigger;
		if (size)
			*size = sizeof(struct ns__GetCANTrigger);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetCANTrigger[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetCANTrigger);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetCANTrigger*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetCANTrigger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetCANTrigger %p -> %p\n", q, p));
	*(struct ns__GetCANTrigger*)p = *(struct ns__GetCANTrigger*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetCANTrigger(struct soap *soap, struct ns__SetCANTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_ns__CANTriggerSettings(soap, &a->settings);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetCANTrigger(struct soap *soap, const struct ns__SetCANTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__CANTriggerSettings(soap, &a->settings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetCANTrigger(struct soap *soap, const struct ns__SetCANTrigger *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetCANTrigger);
	if (soap_out_ns__SetCANTrigger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetCANTrigger(struct soap *soap, const char *tag, int id, const struct ns__SetCANTrigger *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetCANTrigger), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_ns__CANTriggerSettings(soap, "settings", -1, &a->settings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetCANTrigger * SOAP_FMAC4 soap_get_ns__SetCANTrigger(struct soap *soap, struct ns__SetCANTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetCANTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetCANTrigger * SOAP_FMAC4 soap_in_ns__SetCANTrigger(struct soap *soap, const char *tag, struct ns__SetCANTrigger *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_settings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetCANTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetCANTrigger, sizeof(struct ns__SetCANTrigger), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetCANTrigger(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_settings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__CANTriggerSettings(soap, "settings", &a->settings, "ns:CANTriggerSettings"))
				{	soap_flag_settings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetCANTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetCANTrigger, 0, sizeof(struct ns__SetCANTrigger), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_settings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetCANTrigger * SOAP_FMAC6 soap_new_ns__SetCANTrigger(struct soap *soap, int n)
{	return soap_instantiate_ns__SetCANTrigger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetCANTrigger(struct soap *soap, struct ns__SetCANTrigger *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetCANTrigger * SOAP_FMAC4 soap_instantiate_ns__SetCANTrigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetCANTrigger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetCANTrigger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetCANTrigger;
		if (size)
			*size = sizeof(struct ns__SetCANTrigger);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetCANTrigger[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetCANTrigger);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetCANTrigger*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetCANTrigger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetCANTrigger %p -> %p\n", q, p));
	*(struct ns__SetCANTrigger*)p = *(struct ns__SetCANTrigger*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetI2CTrigger(struct soap *soap, struct ns__GetI2CTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetI2CTrigger(struct soap *soap, const struct ns__GetI2CTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetI2CTrigger(struct soap *soap, const struct ns__GetI2CTrigger *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetI2CTrigger);
	if (soap_out_ns__GetI2CTrigger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetI2CTrigger(struct soap *soap, const char *tag, int id, const struct ns__GetI2CTrigger *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetI2CTrigger), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetI2CTrigger * SOAP_FMAC4 soap_get_ns__GetI2CTrigger(struct soap *soap, struct ns__GetI2CTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetI2CTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetI2CTrigger * SOAP_FMAC4 soap_in_ns__GetI2CTrigger(struct soap *soap, const char *tag, struct ns__GetI2CTrigger *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetI2CTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetI2CTrigger, sizeof(struct ns__GetI2CTrigger), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetI2CTrigger(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetI2CTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetI2CTrigger, 0, sizeof(struct ns__GetI2CTrigger), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetI2CTrigger * SOAP_FMAC6 soap_new_ns__GetI2CTrigger(struct soap *soap, int n)
{	return soap_instantiate_ns__GetI2CTrigger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetI2CTrigger(struct soap *soap, struct ns__GetI2CTrigger *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetI2CTrigger * SOAP_FMAC4 soap_instantiate_ns__GetI2CTrigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetI2CTrigger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetI2CTrigger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetI2CTrigger;
		if (size)
			*size = sizeof(struct ns__GetI2CTrigger);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetI2CTrigger[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetI2CTrigger);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetI2CTrigger*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetI2CTrigger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetI2CTrigger %p -> %p\n", q, p));
	*(struct ns__GetI2CTrigger*)p = *(struct ns__GetI2CTrigger*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetI2CTrigger(struct soap *soap, struct ns__SetI2CTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_ns__I2CTriggerSettings(soap, &a->settings);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetI2CTrigger(struct soap *soap, const struct ns__SetI2CTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__I2CTriggerSettings(soap, &a->settings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetI2CTrigger(struct soap *soap, const struct ns__SetI2CTrigger *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetI2CTrigger);
	if (soap_out_ns__SetI2CTrigger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetI2CTrigger(struct soap *soap, const char *tag, int id, const struct ns__SetI2CTrigger *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetI2CTrigger), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_ns__I2CTriggerSettings(soap, "settings", -1, &a->settings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetI2CTrigger * SOAP_FMAC4 soap_get_ns__SetI2CTrigger(struct soap *soap, struct ns__SetI2CTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetI2CTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetI2CTrigger * SOAP_FMAC4 soap_in_ns__SetI2CTrigger(struct soap *soap, const char *tag, struct ns__SetI2CTrigger *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_settings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetI2CTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetI2CTrigger, sizeof(struct ns__SetI2CTrigger), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetI2CTrigger(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_settings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__I2CTriggerSettings(soap, "settings", &a->settings, "ns:I2CTriggerSettings"))
				{	soap_flag_settings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetI2CTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetI2CTrigger, 0, sizeof(struct ns__SetI2CTrigger), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_settings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetI2CTrigger * SOAP_FMAC6 soap_new_ns__SetI2CTrigger(struct soap *soap, int n)
{	return soap_instantiate_ns__SetI2CTrigger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetI2CTrigger(struct soap *soap, struct ns__SetI2CTrigger *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetI2CTrigger * SOAP_FMAC4 soap_instantiate_ns__SetI2CTrigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetI2CTrigger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetI2CTrigger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetI2CTrigger;
		if (size)
			*size = sizeof(struct ns__SetI2CTrigger);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetI2CTrigger[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetI2CTrigger);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetI2CTrigger*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetI2CTrigger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetI2CTrigger %p -> %p\n", q, p));
	*(struct ns__SetI2CTrigger*)p = *(struct ns__SetI2CTrigger*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ResetSerTrg(struct soap *soap, struct ns__ResetSerTrg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ResetSerTrg(struct soap *soap, const struct ns__ResetSerTrg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ResetSerTrg(struct soap *soap, const struct ns__ResetSerTrg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ResetSerTrg);
	if (soap_out_ns__ResetSerTrg(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ResetSerTrg(struct soap *soap, const char *tag, int id, const struct ns__ResetSerTrg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ResetSerTrg), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ResetSerTrg * SOAP_FMAC4 soap_get_ns__ResetSerTrg(struct soap *soap, struct ns__ResetSerTrg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ResetSerTrg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ResetSerTrg * SOAP_FMAC4 soap_in_ns__ResetSerTrg(struct soap *soap, const char *tag, struct ns__ResetSerTrg *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ResetSerTrg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ResetSerTrg, sizeof(struct ns__ResetSerTrg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ResetSerTrg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ResetSerTrg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ResetSerTrg, 0, sizeof(struct ns__ResetSerTrg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ResetSerTrg * SOAP_FMAC6 soap_new_ns__ResetSerTrg(struct soap *soap, int n)
{	return soap_instantiate_ns__ResetSerTrg(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ResetSerTrg(struct soap *soap, struct ns__ResetSerTrg *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ResetSerTrg * SOAP_FMAC4 soap_instantiate_ns__ResetSerTrg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ResetSerTrg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ResetSerTrg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ResetSerTrg;
		if (size)
			*size = sizeof(struct ns__ResetSerTrg);
	}
	else
	{	cp->ptr = (void*)new struct ns__ResetSerTrg[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ResetSerTrg);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ResetSerTrg*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ResetSerTrg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ResetSerTrg %p -> %p\n", q, p));
	*(struct ns__ResetSerTrg*)p = *(struct ns__ResetSerTrg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetSerTrgProtocol(struct soap *soap, struct ns__GetSerTrgProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetSerTrgProtocol(struct soap *soap, const struct ns__GetSerTrgProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetSerTrgProtocol(struct soap *soap, const struct ns__GetSerTrgProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetSerTrgProtocol);
	if (soap_out_ns__GetSerTrgProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetSerTrgProtocol(struct soap *soap, const char *tag, int id, const struct ns__GetSerTrgProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetSerTrgProtocol), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetSerTrgProtocol * SOAP_FMAC4 soap_get_ns__GetSerTrgProtocol(struct soap *soap, struct ns__GetSerTrgProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetSerTrgProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetSerTrgProtocol * SOAP_FMAC4 soap_in_ns__GetSerTrgProtocol(struct soap *soap, const char *tag, struct ns__GetSerTrgProtocol *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetSerTrgProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetSerTrgProtocol, sizeof(struct ns__GetSerTrgProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetSerTrgProtocol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetSerTrgProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetSerTrgProtocol, 0, sizeof(struct ns__GetSerTrgProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetSerTrgProtocol * SOAP_FMAC6 soap_new_ns__GetSerTrgProtocol(struct soap *soap, int n)
{	return soap_instantiate_ns__GetSerTrgProtocol(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetSerTrgProtocol(struct soap *soap, struct ns__GetSerTrgProtocol *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetSerTrgProtocol * SOAP_FMAC4 soap_instantiate_ns__GetSerTrgProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetSerTrgProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetSerTrgProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetSerTrgProtocol;
		if (size)
			*size = sizeof(struct ns__GetSerTrgProtocol);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetSerTrgProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetSerTrgProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetSerTrgProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetSerTrgProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetSerTrgProtocol %p -> %p\n", q, p));
	*(struct ns__GetSerTrgProtocol*)p = *(struct ns__GetSerTrgProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetSerTrgProtocolResponse(struct soap *soap, struct ns__GetSerTrgProtocolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->prot);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetSerTrgProtocolResponse(struct soap *soap, const struct ns__GetSerTrgProtocolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetSerTrgProtocolResponse(struct soap *soap, const struct ns__GetSerTrgProtocolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetSerTrgProtocolResponse);
	if (soap_out_ns__GetSerTrgProtocolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetSerTrgProtocolResponse(struct soap *soap, const char *tag, int id, const struct ns__GetSerTrgProtocolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetSerTrgProtocolResponse), type))
		return soap->error;
	if (soap_out_int(soap, "prot", -1, &a->prot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetSerTrgProtocolResponse * SOAP_FMAC4 soap_get_ns__GetSerTrgProtocolResponse(struct soap *soap, struct ns__GetSerTrgProtocolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetSerTrgProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetSerTrgProtocolResponse * SOAP_FMAC4 soap_in_ns__GetSerTrgProtocolResponse(struct soap *soap, const char *tag, struct ns__GetSerTrgProtocolResponse *a, const char *type)
{
	size_t soap_flag_prot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetSerTrgProtocolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetSerTrgProtocolResponse, sizeof(struct ns__GetSerTrgProtocolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetSerTrgProtocolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_prot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "prot", &a->prot, "xsd:int"))
				{	soap_flag_prot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetSerTrgProtocolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetSerTrgProtocolResponse, 0, sizeof(struct ns__GetSerTrgProtocolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_prot > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetSerTrgProtocolResponse * SOAP_FMAC6 soap_new_ns__GetSerTrgProtocolResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetSerTrgProtocolResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetSerTrgProtocolResponse(struct soap *soap, struct ns__GetSerTrgProtocolResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetSerTrgProtocolResponse * SOAP_FMAC4 soap_instantiate_ns__GetSerTrgProtocolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetSerTrgProtocolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetSerTrgProtocolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetSerTrgProtocolResponse;
		if (size)
			*size = sizeof(struct ns__GetSerTrgProtocolResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetSerTrgProtocolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetSerTrgProtocolResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetSerTrgProtocolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetSerTrgProtocolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetSerTrgProtocolResponse %p -> %p\n", q, p));
	*(struct ns__GetSerTrgProtocolResponse*)p = *(struct ns__GetSerTrgProtocolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__CANTriggerSettings(struct soap *soap, struct ns__CANTriggerSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mode);
	soap_default_int(soap, &a->chDataInputNumber);
	soap_default_int(soap, &a->chDataInputSignal);
	soap_default_double(soap, &a->chDataLevelL);
	soap_default_double(soap, &a->chDataLevelH);
	soap_default_int(soap, &a->bitRate);
	soap_default_double(soap, &a->bitSamplePoint);
	soap_default_int(soap, &a->idFormat);
	soap_default_bool(soap, &a->idInRange);
	soap_default_int(soap, &a->idLow);
	soap_default_int(soap, &a->idHigh);
	soap_default_int(soap, &a->idMask);
	soap_default_int(soap, &a->dataLength);
	soap_default_bool(soap, &a->dataInRange);
	soap_default_Array8Ofbyte(soap, a->dataLow);
	soap_default_Array8Ofbyte(soap, a->dataHigh);
	soap_default_Array8Ofbyte(soap, a->dataMask);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__CANTriggerSettings(struct soap *soap, const struct ns__CANTriggerSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chDataLevelL, SOAP_TYPE_double);
	soap_embedded(soap, &a->chDataLevelH, SOAP_TYPE_double);
	soap_embedded(soap, &a->bitSamplePoint, SOAP_TYPE_double);
	soap_serialize_Array8Ofbyte(soap, a->dataLow);
	soap_serialize_Array8Ofbyte(soap, a->dataHigh);
	soap_serialize_Array8Ofbyte(soap, a->dataMask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__CANTriggerSettings(struct soap *soap, const struct ns__CANTriggerSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__CANTriggerSettings);
	if (soap_out_ns__CANTriggerSettings(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__CANTriggerSettings(struct soap *soap, const char *tag, int id, const struct ns__CANTriggerSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__CANTriggerSettings), type))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_int(soap, "chDataInputNumber", -1, &a->chDataInputNumber, ""))
		return soap->error;
	if (soap_out_int(soap, "chDataInputSignal", -1, &a->chDataInputSignal, ""))
		return soap->error;
	if (soap_out_double(soap, "chDataLevelL", -1, &a->chDataLevelL, ""))
		return soap->error;
	if (soap_out_double(soap, "chDataLevelH", -1, &a->chDataLevelH, ""))
		return soap->error;
	if (soap_out_int(soap, "bitRate", -1, &a->bitRate, ""))
		return soap->error;
	if (soap_out_double(soap, "bitSamplePoint", -1, &a->bitSamplePoint, ""))
		return soap->error;
	if (soap_out_int(soap, "idFormat", -1, &a->idFormat, ""))
		return soap->error;
	if (soap_out_bool(soap, "idInRange", -1, &a->idInRange, ""))
		return soap->error;
	if (soap_out_int(soap, "idLow", -1, &a->idLow, ""))
		return soap->error;
	if (soap_out_int(soap, "idHigh", -1, &a->idHigh, ""))
		return soap->error;
	if (soap_out_int(soap, "idMask", -1, &a->idMask, ""))
		return soap->error;
	if (soap_out_int(soap, "dataLength", -1, &a->dataLength, ""))
		return soap->error;
	if (soap_out_bool(soap, "dataInRange", -1, &a->dataInRange, ""))
		return soap->error;
	soap_out_Array8Ofbyte(soap, "dataLow", -1, a->dataLow, "");
	soap_out_Array8Ofbyte(soap, "dataHigh", -1, a->dataHigh, "");
	soap_out_Array8Ofbyte(soap, "dataMask", -1, a->dataMask, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__CANTriggerSettings * SOAP_FMAC4 soap_get_ns__CANTriggerSettings(struct soap *soap, struct ns__CANTriggerSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__CANTriggerSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__CANTriggerSettings * SOAP_FMAC4 soap_in_ns__CANTriggerSettings(struct soap *soap, const char *tag, struct ns__CANTriggerSettings *a, const char *type)
{
	size_t soap_flag_mode = 1;
	size_t soap_flag_chDataInputNumber = 1;
	size_t soap_flag_chDataInputSignal = 1;
	size_t soap_flag_chDataLevelL = 1;
	size_t soap_flag_chDataLevelH = 1;
	size_t soap_flag_bitRate = 1;
	size_t soap_flag_bitSamplePoint = 1;
	size_t soap_flag_idFormat = 1;
	size_t soap_flag_idInRange = 1;
	size_t soap_flag_idLow = 1;
	size_t soap_flag_idHigh = 1;
	size_t soap_flag_idMask = 1;
	size_t soap_flag_dataLength = 1;
	size_t soap_flag_dataInRange = 1;
	size_t soap_flag_dataLow = 1;
	size_t soap_flag_dataHigh = 1;
	size_t soap_flag_dataMask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__CANTriggerSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__CANTriggerSettings, sizeof(struct ns__CANTriggerSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__CANTriggerSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mode", &a->mode, "xsd:int"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap_flag_chDataInputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chDataInputNumber", &a->chDataInputNumber, "xsd:int"))
				{	soap_flag_chDataInputNumber--;
					continue;
				}
			if (soap_flag_chDataInputSignal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chDataInputSignal", &a->chDataInputSignal, "xsd:int"))
				{	soap_flag_chDataInputSignal--;
					continue;
				}
			if (soap_flag_chDataLevelL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chDataLevelL", &a->chDataLevelL, "xsd:double"))
				{	soap_flag_chDataLevelL--;
					continue;
				}
			if (soap_flag_chDataLevelH && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chDataLevelH", &a->chDataLevelH, "xsd:double"))
				{	soap_flag_chDataLevelH--;
					continue;
				}
			if (soap_flag_bitRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "bitRate", &a->bitRate, "xsd:int"))
				{	soap_flag_bitRate--;
					continue;
				}
			if (soap_flag_bitSamplePoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bitSamplePoint", &a->bitSamplePoint, "xsd:double"))
				{	soap_flag_bitSamplePoint--;
					continue;
				}
			if (soap_flag_idFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idFormat", &a->idFormat, "xsd:int"))
				{	soap_flag_idFormat--;
					continue;
				}
			if (soap_flag_idInRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "idInRange", &a->idInRange, "xsd:boolean"))
				{	soap_flag_idInRange--;
					continue;
				}
			if (soap_flag_idLow && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idLow", &a->idLow, "xsd:int"))
				{	soap_flag_idLow--;
					continue;
				}
			if (soap_flag_idHigh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idHigh", &a->idHigh, "xsd:int"))
				{	soap_flag_idHigh--;
					continue;
				}
			if (soap_flag_idMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idMask", &a->idMask, "xsd:int"))
				{	soap_flag_idMask--;
					continue;
				}
			if (soap_flag_dataLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dataLength", &a->dataLength, "xsd:int"))
				{	soap_flag_dataLength--;
					continue;
				}
			if (soap_flag_dataInRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "dataInRange", &a->dataInRange, "xsd:boolean"))
				{	soap_flag_dataInRange--;
					continue;
				}
			if (soap_flag_dataLow && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array8Ofbyte(soap, "dataLow", a->dataLow, "xsd:byte"))
				{	soap_flag_dataLow--;
					continue;
				}
			if (soap_flag_dataHigh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array8Ofbyte(soap, "dataHigh", a->dataHigh, "xsd:byte"))
				{	soap_flag_dataHigh--;
					continue;
				}
			if (soap_flag_dataMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array8Ofbyte(soap, "dataMask", a->dataMask, "xsd:byte"))
				{	soap_flag_dataMask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__CANTriggerSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__CANTriggerSettings, 0, sizeof(struct ns__CANTriggerSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mode > 0 || soap_flag_chDataInputNumber > 0 || soap_flag_chDataInputSignal > 0 || soap_flag_chDataLevelL > 0 || soap_flag_chDataLevelH > 0 || soap_flag_bitRate > 0 || soap_flag_bitSamplePoint > 0 || soap_flag_idFormat > 0 || soap_flag_idInRange > 0 || soap_flag_idLow > 0 || soap_flag_idHigh > 0 || soap_flag_idMask > 0 || soap_flag_dataLength > 0 || soap_flag_dataInRange > 0 || soap_flag_dataLow > 0 || soap_flag_dataHigh > 0 || soap_flag_dataMask > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__CANTriggerSettings * SOAP_FMAC6 soap_new_ns__CANTriggerSettings(struct soap *soap, int n)
{	return soap_instantiate_ns__CANTriggerSettings(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__CANTriggerSettings(struct soap *soap, struct ns__CANTriggerSettings *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__CANTriggerSettings * SOAP_FMAC4 soap_instantiate_ns__CANTriggerSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__CANTriggerSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__CANTriggerSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__CANTriggerSettings;
		if (size)
			*size = sizeof(struct ns__CANTriggerSettings);
	}
	else
	{	cp->ptr = (void*)new struct ns__CANTriggerSettings[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__CANTriggerSettings);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__CANTriggerSettings*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__CANTriggerSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__CANTriggerSettings %p -> %p\n", q, p));
	*(struct ns__CANTriggerSettings*)p = *(struct ns__CANTriggerSettings*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__I2CTriggerSettings(struct soap *soap, struct ns__I2CTriggerSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mode);
	soap_default_int(soap, &a->chDataInputNumber);
	soap_default_int(soap, &a->chDataInputSignal);
	soap_default_double(soap, &a->chDataLevelL);
	soap_default_double(soap, &a->chDataLevelH);
	soap_default_int(soap, &a->chClockInputNumber);
	soap_default_int(soap, &a->chClockInputSignal);
	soap_default_double(soap, &a->chClockLevelL);
	soap_default_double(soap, &a->chClockLevelH);
	soap_default_int(soap, &a->ack);
	soap_default_int(soap, &a->adrRWBit);
	soap_default_int(soap, &a->adrType);
	soap_default_bool(soap, &a->adrInRange);
	soap_default_int(soap, &a->adrLow);
	soap_default_int(soap, &a->adrHigh);
	soap_default_int(soap, &a->adrMask);
	soap_default_int(soap, &a->dataStartByte);
	soap_default_int(soap, &a->dataLength);
	soap_default_bool(soap, &a->dataInRange);
	soap_default_Array16Ofbyte(soap, a->dataLow);
	soap_default_Array16Ofbyte(soap, a->dataHigh);
	soap_default_Array16Ofbyte(soap, a->dataMask);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__I2CTriggerSettings(struct soap *soap, const struct ns__I2CTriggerSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chDataLevelL, SOAP_TYPE_double);
	soap_embedded(soap, &a->chDataLevelH, SOAP_TYPE_double);
	soap_embedded(soap, &a->chClockLevelL, SOAP_TYPE_double);
	soap_embedded(soap, &a->chClockLevelH, SOAP_TYPE_double);
	soap_serialize_Array16Ofbyte(soap, a->dataLow);
	soap_serialize_Array16Ofbyte(soap, a->dataHigh);
	soap_serialize_Array16Ofbyte(soap, a->dataMask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__I2CTriggerSettings(struct soap *soap, const struct ns__I2CTriggerSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__I2CTriggerSettings);
	if (soap_out_ns__I2CTriggerSettings(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__I2CTriggerSettings(struct soap *soap, const char *tag, int id, const struct ns__I2CTriggerSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__I2CTriggerSettings), type))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_int(soap, "chDataInputNumber", -1, &a->chDataInputNumber, ""))
		return soap->error;
	if (soap_out_int(soap, "chDataInputSignal", -1, &a->chDataInputSignal, ""))
		return soap->error;
	if (soap_out_double(soap, "chDataLevelL", -1, &a->chDataLevelL, ""))
		return soap->error;
	if (soap_out_double(soap, "chDataLevelH", -1, &a->chDataLevelH, ""))
		return soap->error;
	if (soap_out_int(soap, "chClockInputNumber", -1, &a->chClockInputNumber, ""))
		return soap->error;
	if (soap_out_int(soap, "chClockInputSignal", -1, &a->chClockInputSignal, ""))
		return soap->error;
	if (soap_out_double(soap, "chClockLevelL", -1, &a->chClockLevelL, ""))
		return soap->error;
	if (soap_out_double(soap, "chClockLevelH", -1, &a->chClockLevelH, ""))
		return soap->error;
	if (soap_out_int(soap, "ack", -1, &a->ack, ""))
		return soap->error;
	if (soap_out_int(soap, "adrRWBit", -1, &a->adrRWBit, ""))
		return soap->error;
	if (soap_out_int(soap, "adrType", -1, &a->adrType, ""))
		return soap->error;
	if (soap_out_bool(soap, "adrInRange", -1, &a->adrInRange, ""))
		return soap->error;
	if (soap_out_int(soap, "adrLow", -1, &a->adrLow, ""))
		return soap->error;
	if (soap_out_int(soap, "adrHigh", -1, &a->adrHigh, ""))
		return soap->error;
	if (soap_out_int(soap, "adrMask", -1, &a->adrMask, ""))
		return soap->error;
	if (soap_out_int(soap, "dataStartByte", -1, &a->dataStartByte, ""))
		return soap->error;
	if (soap_out_int(soap, "dataLength", -1, &a->dataLength, ""))
		return soap->error;
	if (soap_out_bool(soap, "dataInRange", -1, &a->dataInRange, ""))
		return soap->error;
	soap_out_Array16Ofbyte(soap, "dataLow", -1, a->dataLow, "");
	soap_out_Array16Ofbyte(soap, "dataHigh", -1, a->dataHigh, "");
	soap_out_Array16Ofbyte(soap, "dataMask", -1, a->dataMask, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__I2CTriggerSettings * SOAP_FMAC4 soap_get_ns__I2CTriggerSettings(struct soap *soap, struct ns__I2CTriggerSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__I2CTriggerSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__I2CTriggerSettings * SOAP_FMAC4 soap_in_ns__I2CTriggerSettings(struct soap *soap, const char *tag, struct ns__I2CTriggerSettings *a, const char *type)
{
	size_t soap_flag_mode = 1;
	size_t soap_flag_chDataInputNumber = 1;
	size_t soap_flag_chDataInputSignal = 1;
	size_t soap_flag_chDataLevelL = 1;
	size_t soap_flag_chDataLevelH = 1;
	size_t soap_flag_chClockInputNumber = 1;
	size_t soap_flag_chClockInputSignal = 1;
	size_t soap_flag_chClockLevelL = 1;
	size_t soap_flag_chClockLevelH = 1;
	size_t soap_flag_ack = 1;
	size_t soap_flag_adrRWBit = 1;
	size_t soap_flag_adrType = 1;
	size_t soap_flag_adrInRange = 1;
	size_t soap_flag_adrLow = 1;
	size_t soap_flag_adrHigh = 1;
	size_t soap_flag_adrMask = 1;
	size_t soap_flag_dataStartByte = 1;
	size_t soap_flag_dataLength = 1;
	size_t soap_flag_dataInRange = 1;
	size_t soap_flag_dataLow = 1;
	size_t soap_flag_dataHigh = 1;
	size_t soap_flag_dataMask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__I2CTriggerSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__I2CTriggerSettings, sizeof(struct ns__I2CTriggerSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__I2CTriggerSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mode", &a->mode, "xsd:int"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap_flag_chDataInputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chDataInputNumber", &a->chDataInputNumber, "xsd:int"))
				{	soap_flag_chDataInputNumber--;
					continue;
				}
			if (soap_flag_chDataInputSignal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chDataInputSignal", &a->chDataInputSignal, "xsd:int"))
				{	soap_flag_chDataInputSignal--;
					continue;
				}
			if (soap_flag_chDataLevelL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chDataLevelL", &a->chDataLevelL, "xsd:double"))
				{	soap_flag_chDataLevelL--;
					continue;
				}
			if (soap_flag_chDataLevelH && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chDataLevelH", &a->chDataLevelH, "xsd:double"))
				{	soap_flag_chDataLevelH--;
					continue;
				}
			if (soap_flag_chClockInputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chClockInputNumber", &a->chClockInputNumber, "xsd:int"))
				{	soap_flag_chClockInputNumber--;
					continue;
				}
			if (soap_flag_chClockInputSignal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chClockInputSignal", &a->chClockInputSignal, "xsd:int"))
				{	soap_flag_chClockInputSignal--;
					continue;
				}
			if (soap_flag_chClockLevelL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chClockLevelL", &a->chClockLevelL, "xsd:double"))
				{	soap_flag_chClockLevelL--;
					continue;
				}
			if (soap_flag_chClockLevelH && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chClockLevelH", &a->chClockLevelH, "xsd:double"))
				{	soap_flag_chClockLevelH--;
					continue;
				}
			if (soap_flag_ack && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ack", &a->ack, "xsd:int"))
				{	soap_flag_ack--;
					continue;
				}
			if (soap_flag_adrRWBit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "adrRWBit", &a->adrRWBit, "xsd:int"))
				{	soap_flag_adrRWBit--;
					continue;
				}
			if (soap_flag_adrType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "adrType", &a->adrType, "xsd:int"))
				{	soap_flag_adrType--;
					continue;
				}
			if (soap_flag_adrInRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "adrInRange", &a->adrInRange, "xsd:boolean"))
				{	soap_flag_adrInRange--;
					continue;
				}
			if (soap_flag_adrLow && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "adrLow", &a->adrLow, "xsd:int"))
				{	soap_flag_adrLow--;
					continue;
				}
			if (soap_flag_adrHigh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "adrHigh", &a->adrHigh, "xsd:int"))
				{	soap_flag_adrHigh--;
					continue;
				}
			if (soap_flag_adrMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "adrMask", &a->adrMask, "xsd:int"))
				{	soap_flag_adrMask--;
					continue;
				}
			if (soap_flag_dataStartByte && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dataStartByte", &a->dataStartByte, "xsd:int"))
				{	soap_flag_dataStartByte--;
					continue;
				}
			if (soap_flag_dataLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dataLength", &a->dataLength, "xsd:int"))
				{	soap_flag_dataLength--;
					continue;
				}
			if (soap_flag_dataInRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "dataInRange", &a->dataInRange, "xsd:boolean"))
				{	soap_flag_dataInRange--;
					continue;
				}
			if (soap_flag_dataLow && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array16Ofbyte(soap, "dataLow", a->dataLow, "xsd:byte"))
				{	soap_flag_dataLow--;
					continue;
				}
			if (soap_flag_dataHigh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array16Ofbyte(soap, "dataHigh", a->dataHigh, "xsd:byte"))
				{	soap_flag_dataHigh--;
					continue;
				}
			if (soap_flag_dataMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array16Ofbyte(soap, "dataMask", a->dataMask, "xsd:byte"))
				{	soap_flag_dataMask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__I2CTriggerSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__I2CTriggerSettings, 0, sizeof(struct ns__I2CTriggerSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mode > 0 || soap_flag_chDataInputNumber > 0 || soap_flag_chDataInputSignal > 0 || soap_flag_chDataLevelL > 0 || soap_flag_chDataLevelH > 0 || soap_flag_chClockInputNumber > 0 || soap_flag_chClockInputSignal > 0 || soap_flag_chClockLevelL > 0 || soap_flag_chClockLevelH > 0 || soap_flag_ack > 0 || soap_flag_adrRWBit > 0 || soap_flag_adrType > 0 || soap_flag_adrInRange > 0 || soap_flag_adrLow > 0 || soap_flag_adrHigh > 0 || soap_flag_adrMask > 0 || soap_flag_dataStartByte > 0 || soap_flag_dataLength > 0 || soap_flag_dataInRange > 0 || soap_flag_dataLow > 0 || soap_flag_dataHigh > 0 || soap_flag_dataMask > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__I2CTriggerSettings * SOAP_FMAC6 soap_new_ns__I2CTriggerSettings(struct soap *soap, int n)
{	return soap_instantiate_ns__I2CTriggerSettings(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__I2CTriggerSettings(struct soap *soap, struct ns__I2CTriggerSettings *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__I2CTriggerSettings * SOAP_FMAC4 soap_instantiate_ns__I2CTriggerSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__I2CTriggerSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__I2CTriggerSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__I2CTriggerSettings;
		if (size)
			*size = sizeof(struct ns__I2CTriggerSettings);
	}
	else
	{	cp->ptr = (void*)new struct ns__I2CTriggerSettings[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__I2CTriggerSettings);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__I2CTriggerSettings*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__I2CTriggerSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__I2CTriggerSettings %p -> %p\n", q, p));
	*(struct ns__I2CTriggerSettings*)p = *(struct ns__I2CTriggerSettings*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllPreviousAttributes(struct soap *soap, struct ns__GetAllPreviousAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->currentMeasurementNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllPreviousAttributes(struct soap *soap, const struct ns__GetAllPreviousAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllPreviousAttributes(struct soap *soap, const struct ns__GetAllPreviousAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllPreviousAttributes);
	if (soap_out_ns__GetAllPreviousAttributes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllPreviousAttributes(struct soap *soap, const char *tag, int id, const struct ns__GetAllPreviousAttributes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllPreviousAttributes), type))
		return soap->error;
	if (soap_out_int(soap, "currentMeasurementNumber", -1, &a->currentMeasurementNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllPreviousAttributes * SOAP_FMAC4 soap_get_ns__GetAllPreviousAttributes(struct soap *soap, struct ns__GetAllPreviousAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllPreviousAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllPreviousAttributes * SOAP_FMAC4 soap_in_ns__GetAllPreviousAttributes(struct soap *soap, const char *tag, struct ns__GetAllPreviousAttributes *a, const char *type)
{
	size_t soap_flag_currentMeasurementNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllPreviousAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllPreviousAttributes, sizeof(struct ns__GetAllPreviousAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllPreviousAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentMeasurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentMeasurementNumber", &a->currentMeasurementNumber, "xsd:int"))
				{	soap_flag_currentMeasurementNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllPreviousAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllPreviousAttributes, 0, sizeof(struct ns__GetAllPreviousAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentMeasurementNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllPreviousAttributes * SOAP_FMAC6 soap_new_ns__GetAllPreviousAttributes(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllPreviousAttributes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllPreviousAttributes(struct soap *soap, struct ns__GetAllPreviousAttributes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllPreviousAttributes * SOAP_FMAC4 soap_instantiate_ns__GetAllPreviousAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllPreviousAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllPreviousAttributes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAttributes;
		if (size)
			*size = sizeof(struct ns__GetAllPreviousAttributes);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAttributes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllPreviousAttributes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllPreviousAttributes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllPreviousAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllPreviousAttributes %p -> %p\n", q, p));
	*(struct ns__GetAllPreviousAttributes*)p = *(struct ns__GetAllPreviousAttributes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllPreviousAttributesResponse(struct soap *soap, struct ns__GetAllPreviousAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.ns__AttributeList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllPreviousAttributesResponse(struct soap *soap, const struct ns__GetAllPreviousAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllPreviousAttributesResponse(struct soap *soap, const struct ns__GetAllPreviousAttributesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllPreviousAttributesResponse);
	if (soap_out_ns__GetAllPreviousAttributesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllPreviousAttributesResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllPreviousAttributesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllPreviousAttributesResponse), type))
		return soap->error;
	if (a->result.soap_out(soap, "result", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllPreviousAttributesResponse * SOAP_FMAC4 soap_get_ns__GetAllPreviousAttributesResponse(struct soap *soap, struct ns__GetAllPreviousAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllPreviousAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllPreviousAttributesResponse * SOAP_FMAC4 soap_in_ns__GetAllPreviousAttributesResponse(struct soap *soap, const char *tag, struct ns__GetAllPreviousAttributesResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllPreviousAttributesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllPreviousAttributesResponse, sizeof(struct ns__GetAllPreviousAttributesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetAllPreviousAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (a->result.soap_in(soap, "result", "ns:AttributeList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllPreviousAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllPreviousAttributesResponse, 0, sizeof(struct ns__GetAllPreviousAttributesResponse), 0, soap_copy_ns__GetAllPreviousAttributesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllPreviousAttributesResponse * SOAP_FMAC6 soap_new_ns__GetAllPreviousAttributesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllPreviousAttributesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllPreviousAttributesResponse(struct soap *soap, struct ns__GetAllPreviousAttributesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllPreviousAttributesResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllPreviousAttributesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllPreviousAttributesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllPreviousAttributesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAttributesResponse;
		if (size)
			*size = sizeof(struct ns__GetAllPreviousAttributesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllPreviousAttributesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllPreviousAttributesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllPreviousAttributesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllPreviousAttributesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllPreviousAttributesResponse %p -> %p\n", q, p));
	*(struct ns__GetAllPreviousAttributesResponse*)p = *(struct ns__GetAllPreviousAttributesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllCurrentAttributes(struct soap *soap, struct ns__GetAllCurrentAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllCurrentAttributes(struct soap *soap, const struct ns__GetAllCurrentAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllCurrentAttributes(struct soap *soap, const struct ns__GetAllCurrentAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllCurrentAttributes);
	if (soap_out_ns__GetAllCurrentAttributes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllCurrentAttributes(struct soap *soap, const char *tag, int id, const struct ns__GetAllCurrentAttributes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllCurrentAttributes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllCurrentAttributes * SOAP_FMAC4 soap_get_ns__GetAllCurrentAttributes(struct soap *soap, struct ns__GetAllCurrentAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllCurrentAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllCurrentAttributes * SOAP_FMAC4 soap_in_ns__GetAllCurrentAttributes(struct soap *soap, const char *tag, struct ns__GetAllCurrentAttributes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllCurrentAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllCurrentAttributes, sizeof(struct ns__GetAllCurrentAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllCurrentAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllCurrentAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllCurrentAttributes, 0, sizeof(struct ns__GetAllCurrentAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllCurrentAttributes * SOAP_FMAC6 soap_new_ns__GetAllCurrentAttributes(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllCurrentAttributes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllCurrentAttributes(struct soap *soap, struct ns__GetAllCurrentAttributes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllCurrentAttributes * SOAP_FMAC4 soap_instantiate_ns__GetAllCurrentAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllCurrentAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllCurrentAttributes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAttributes;
		if (size)
			*size = sizeof(struct ns__GetAllCurrentAttributes);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAttributes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllCurrentAttributes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllCurrentAttributes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllCurrentAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllCurrentAttributes %p -> %p\n", q, p));
	*(struct ns__GetAllCurrentAttributes*)p = *(struct ns__GetAllCurrentAttributes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllCurrentAttributesResponse(struct soap *soap, struct ns__GetAllCurrentAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.ns__AttributeList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllCurrentAttributesResponse(struct soap *soap, const struct ns__GetAllCurrentAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllCurrentAttributesResponse(struct soap *soap, const struct ns__GetAllCurrentAttributesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllCurrentAttributesResponse);
	if (soap_out_ns__GetAllCurrentAttributesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllCurrentAttributesResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllCurrentAttributesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllCurrentAttributesResponse), type))
		return soap->error;
	if (a->result.soap_out(soap, "result", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllCurrentAttributesResponse * SOAP_FMAC4 soap_get_ns__GetAllCurrentAttributesResponse(struct soap *soap, struct ns__GetAllCurrentAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllCurrentAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllCurrentAttributesResponse * SOAP_FMAC4 soap_in_ns__GetAllCurrentAttributesResponse(struct soap *soap, const char *tag, struct ns__GetAllCurrentAttributesResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllCurrentAttributesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllCurrentAttributesResponse, sizeof(struct ns__GetAllCurrentAttributesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetAllCurrentAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (a->result.soap_in(soap, "result", "ns:AttributeList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllCurrentAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllCurrentAttributesResponse, 0, sizeof(struct ns__GetAllCurrentAttributesResponse), 0, soap_copy_ns__GetAllCurrentAttributesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllCurrentAttributesResponse * SOAP_FMAC6 soap_new_ns__GetAllCurrentAttributesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllCurrentAttributesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllCurrentAttributesResponse(struct soap *soap, struct ns__GetAllCurrentAttributesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllCurrentAttributesResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllCurrentAttributesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllCurrentAttributesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllCurrentAttributesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAttributesResponse;
		if (size)
			*size = sizeof(struct ns__GetAllCurrentAttributesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllCurrentAttributesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllCurrentAttributesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllCurrentAttributesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllCurrentAttributesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllCurrentAttributesResponse %p -> %p\n", q, p));
	*(struct ns__GetAllCurrentAttributesResponse*)p = *(struct ns__GetAllCurrentAttributesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAttributes(struct soap *soap, struct ns__SetAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->values.ns__AttributeList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAttributes(struct soap *soap, const struct ns__SetAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->values.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAttributes(struct soap *soap, const struct ns__SetAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetAttributes);
	if (soap_out_ns__SetAttributes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAttributes(struct soap *soap, const char *tag, int id, const struct ns__SetAttributes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetAttributes), type))
		return soap->error;
	if (a->values.soap_out(soap, "values", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetAttributes * SOAP_FMAC4 soap_get_ns__SetAttributes(struct soap *soap, struct ns__SetAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetAttributes * SOAP_FMAC4 soap_in_ns__SetAttributes(struct soap *soap, const char *tag, struct ns__SetAttributes *a, const char *type)
{
	size_t soap_flag_values = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetAttributes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetAttributes, sizeof(struct ns__SetAttributes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__SetAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_values && soap->error == SOAP_TAG_MISMATCH)
				if (a->values.soap_in(soap, "values", "ns:AttributeList"))
				{	soap_flag_values--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetAttributes, 0, sizeof(struct ns__SetAttributes), 0, soap_copy_ns__SetAttributes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_values > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetAttributes * SOAP_FMAC6 soap_new_ns__SetAttributes(struct soap *soap, int n)
{	return soap_instantiate_ns__SetAttributes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetAttributes(struct soap *soap, struct ns__SetAttributes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetAttributes * SOAP_FMAC4 soap_instantiate_ns__SetAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetAttributes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetAttributes;
		if (size)
			*size = sizeof(struct ns__SetAttributes);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetAttributes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetAttributes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetAttributes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetAttributes %p -> %p\n", q, p));
	*(struct ns__SetAttributes*)p = *(struct ns__SetAttributes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Attribute(struct soap *soap, struct ns__Attribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->boardAddress);
	soap_default_unsignedInt(soap, &a->inputNumber);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Attribute(struct soap *soap, const struct ns__Attribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Attribute(struct soap *soap, const struct ns__Attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Attribute);
	if (soap_out_ns__Attribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Attribute(struct soap *soap, const char *tag, int id, const struct ns__Attribute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Attribute), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Attribute * SOAP_FMAC4 soap_get_ns__Attribute(struct soap *soap, struct ns__Attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Attribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Attribute * SOAP_FMAC4 soap_in_ns__Attribute(struct soap *soap, const char *tag, struct ns__Attribute *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Attribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Attribute, sizeof(struct ns__Attribute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Attribute(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boardAddress", &a->boardAddress, "xsd:unsignedInt"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "inputNumber", &a->inputNumber, "xsd:unsignedInt"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Attribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Attribute, 0, sizeof(struct ns__Attribute), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__Attribute * SOAP_FMAC6 soap_new_ns__Attribute(struct soap *soap, int n)
{	return soap_instantiate_ns__Attribute(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__Attribute(struct soap *soap, struct ns__Attribute *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__Attribute * SOAP_FMAC4 soap_instantiate_ns__Attribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Attribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Attribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__Attribute;
		if (size)
			*size = sizeof(struct ns__Attribute);
	}
	else
	{	cp->ptr = (void*)new struct ns__Attribute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__Attribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__Attribute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Attribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Attribute %p -> %p\n", q, p));
	*(struct ns__Attribute*)p = *(struct ns__Attribute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllPreviousParameters(struct soap *soap, struct ns__GetAllPreviousParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->currentMeasurementNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllPreviousParameters(struct soap *soap, const struct ns__GetAllPreviousParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllPreviousParameters(struct soap *soap, const struct ns__GetAllPreviousParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllPreviousParameters);
	if (soap_out_ns__GetAllPreviousParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllPreviousParameters(struct soap *soap, const char *tag, int id, const struct ns__GetAllPreviousParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllPreviousParameters), type))
		return soap->error;
	if (soap_out_int(soap, "currentMeasurementNumber", -1, &a->currentMeasurementNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllPreviousParameters * SOAP_FMAC4 soap_get_ns__GetAllPreviousParameters(struct soap *soap, struct ns__GetAllPreviousParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllPreviousParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllPreviousParameters * SOAP_FMAC4 soap_in_ns__GetAllPreviousParameters(struct soap *soap, const char *tag, struct ns__GetAllPreviousParameters *a, const char *type)
{
	size_t soap_flag_currentMeasurementNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllPreviousParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllPreviousParameters, sizeof(struct ns__GetAllPreviousParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllPreviousParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentMeasurementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "currentMeasurementNumber", &a->currentMeasurementNumber, "xsd:int"))
				{	soap_flag_currentMeasurementNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllPreviousParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllPreviousParameters, 0, sizeof(struct ns__GetAllPreviousParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentMeasurementNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllPreviousParameters * SOAP_FMAC6 soap_new_ns__GetAllPreviousParameters(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllPreviousParameters(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllPreviousParameters(struct soap *soap, struct ns__GetAllPreviousParameters *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllPreviousParameters * SOAP_FMAC4 soap_instantiate_ns__GetAllPreviousParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllPreviousParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllPreviousParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllPreviousParameters;
		if (size)
			*size = sizeof(struct ns__GetAllPreviousParameters);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllPreviousParameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllPreviousParameters);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllPreviousParameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllPreviousParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllPreviousParameters %p -> %p\n", q, p));
	*(struct ns__GetAllPreviousParameters*)p = *(struct ns__GetAllPreviousParameters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllPreviousParametersResponse(struct soap *soap, struct ns__GetAllPreviousParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->parameters.ns__ParameterList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllPreviousParametersResponse(struct soap *soap, const struct ns__GetAllPreviousParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->parameters.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllPreviousParametersResponse(struct soap *soap, const struct ns__GetAllPreviousParametersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllPreviousParametersResponse);
	if (soap_out_ns__GetAllPreviousParametersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllPreviousParametersResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllPreviousParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllPreviousParametersResponse), type))
		return soap->error;
	if (a->parameters.soap_out(soap, "parameters", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllPreviousParametersResponse * SOAP_FMAC4 soap_get_ns__GetAllPreviousParametersResponse(struct soap *soap, struct ns__GetAllPreviousParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllPreviousParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllPreviousParametersResponse * SOAP_FMAC4 soap_in_ns__GetAllPreviousParametersResponse(struct soap *soap, const char *tag, struct ns__GetAllPreviousParametersResponse *a, const char *type)
{
	size_t soap_flag_parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllPreviousParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllPreviousParametersResponse, sizeof(struct ns__GetAllPreviousParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetAllPreviousParametersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameters && soap->error == SOAP_TAG_MISMATCH)
				if (a->parameters.soap_in(soap, "parameters", "ns:ParameterList"))
				{	soap_flag_parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllPreviousParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllPreviousParametersResponse, 0, sizeof(struct ns__GetAllPreviousParametersResponse), 0, soap_copy_ns__GetAllPreviousParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllPreviousParametersResponse * SOAP_FMAC6 soap_new_ns__GetAllPreviousParametersResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllPreviousParametersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllPreviousParametersResponse(struct soap *soap, struct ns__GetAllPreviousParametersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllPreviousParametersResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllPreviousParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllPreviousParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllPreviousParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllPreviousParametersResponse;
		if (size)
			*size = sizeof(struct ns__GetAllPreviousParametersResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllPreviousParametersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllPreviousParametersResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllPreviousParametersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllPreviousParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllPreviousParametersResponse %p -> %p\n", q, p));
	*(struct ns__GetAllPreviousParametersResponse*)p = *(struct ns__GetAllPreviousParametersResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllCurrentParameters(struct soap *soap, struct ns__GetAllCurrentParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllCurrentParameters(struct soap *soap, const struct ns__GetAllCurrentParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllCurrentParameters(struct soap *soap, const struct ns__GetAllCurrentParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllCurrentParameters);
	if (soap_out_ns__GetAllCurrentParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllCurrentParameters(struct soap *soap, const char *tag, int id, const struct ns__GetAllCurrentParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllCurrentParameters), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllCurrentParameters * SOAP_FMAC4 soap_get_ns__GetAllCurrentParameters(struct soap *soap, struct ns__GetAllCurrentParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllCurrentParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllCurrentParameters * SOAP_FMAC4 soap_in_ns__GetAllCurrentParameters(struct soap *soap, const char *tag, struct ns__GetAllCurrentParameters *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllCurrentParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllCurrentParameters, sizeof(struct ns__GetAllCurrentParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetAllCurrentParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllCurrentParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllCurrentParameters, 0, sizeof(struct ns__GetAllCurrentParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllCurrentParameters * SOAP_FMAC6 soap_new_ns__GetAllCurrentParameters(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllCurrentParameters(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllCurrentParameters(struct soap *soap, struct ns__GetAllCurrentParameters *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllCurrentParameters * SOAP_FMAC4 soap_instantiate_ns__GetAllCurrentParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllCurrentParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllCurrentParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllCurrentParameters;
		if (size)
			*size = sizeof(struct ns__GetAllCurrentParameters);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllCurrentParameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllCurrentParameters);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllCurrentParameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllCurrentParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllCurrentParameters %p -> %p\n", q, p));
	*(struct ns__GetAllCurrentParameters*)p = *(struct ns__GetAllCurrentParameters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllCurrentParametersResponse(struct soap *soap, struct ns__GetAllCurrentParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->parameters.ns__ParameterList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllCurrentParametersResponse(struct soap *soap, const struct ns__GetAllCurrentParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->parameters.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllCurrentParametersResponse(struct soap *soap, const struct ns__GetAllCurrentParametersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetAllCurrentParametersResponse);
	if (soap_out_ns__GetAllCurrentParametersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllCurrentParametersResponse(struct soap *soap, const char *tag, int id, const struct ns__GetAllCurrentParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllCurrentParametersResponse), type))
		return soap->error;
	if (a->parameters.soap_out(soap, "parameters", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllCurrentParametersResponse * SOAP_FMAC4 soap_get_ns__GetAllCurrentParametersResponse(struct soap *soap, struct ns__GetAllCurrentParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllCurrentParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetAllCurrentParametersResponse * SOAP_FMAC4 soap_in_ns__GetAllCurrentParametersResponse(struct soap *soap, const char *tag, struct ns__GetAllCurrentParametersResponse *a, const char *type)
{
	size_t soap_flag_parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllCurrentParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllCurrentParametersResponse, sizeof(struct ns__GetAllCurrentParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__GetAllCurrentParametersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameters && soap->error == SOAP_TAG_MISMATCH)
				if (a->parameters.soap_in(soap, "parameters", "ns:ParameterList"))
				{	soap_flag_parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetAllCurrentParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllCurrentParametersResponse, 0, sizeof(struct ns__GetAllCurrentParametersResponse), 0, soap_copy_ns__GetAllCurrentParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetAllCurrentParametersResponse * SOAP_FMAC6 soap_new_ns__GetAllCurrentParametersResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetAllCurrentParametersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetAllCurrentParametersResponse(struct soap *soap, struct ns__GetAllCurrentParametersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetAllCurrentParametersResponse * SOAP_FMAC4 soap_instantiate_ns__GetAllCurrentParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllCurrentParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetAllCurrentParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetAllCurrentParametersResponse;
		if (size)
			*size = sizeof(struct ns__GetAllCurrentParametersResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetAllCurrentParametersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetAllCurrentParametersResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetAllCurrentParametersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetAllCurrentParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetAllCurrentParametersResponse %p -> %p\n", q, p));
	*(struct ns__GetAllCurrentParametersResponse*)p = *(struct ns__GetAllCurrentParametersResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetMultipleParameters(struct soap *soap, struct ns__SetMultipleParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->parameters.ns__ParameterList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetMultipleParameters(struct soap *soap, const struct ns__SetMultipleParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->parameters.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetMultipleParameters(struct soap *soap, const struct ns__SetMultipleParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetMultipleParameters);
	if (soap_out_ns__SetMultipleParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetMultipleParameters(struct soap *soap, const char *tag, int id, const struct ns__SetMultipleParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetMultipleParameters), type))
		return soap->error;
	if (a->parameters.soap_out(soap, "parameters", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetMultipleParameters * SOAP_FMAC4 soap_get_ns__SetMultipleParameters(struct soap *soap, struct ns__SetMultipleParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetMultipleParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetMultipleParameters * SOAP_FMAC4 soap_in_ns__SetMultipleParameters(struct soap *soap, const char *tag, struct ns__SetMultipleParameters *a, const char *type)
{
	size_t soap_flag_parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetMultipleParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetMultipleParameters, sizeof(struct ns__SetMultipleParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__SetMultipleParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameters && soap->error == SOAP_TAG_MISMATCH)
				if (a->parameters.soap_in(soap, "parameters", "ns:ParameterList"))
				{	soap_flag_parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetMultipleParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetMultipleParameters, 0, sizeof(struct ns__SetMultipleParameters), 0, soap_copy_ns__SetMultipleParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetMultipleParameters * SOAP_FMAC6 soap_new_ns__SetMultipleParameters(struct soap *soap, int n)
{	return soap_instantiate_ns__SetMultipleParameters(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetMultipleParameters(struct soap *soap, struct ns__SetMultipleParameters *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetMultipleParameters * SOAP_FMAC4 soap_instantiate_ns__SetMultipleParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetMultipleParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetMultipleParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetMultipleParameters;
		if (size)
			*size = sizeof(struct ns__SetMultipleParameters);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetMultipleParameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetMultipleParameters);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetMultipleParameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetMultipleParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetMultipleParameters %p -> %p\n", q, p));
	*(struct ns__SetMultipleParameters*)p = *(struct ns__SetMultipleParameters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetMultipleParametersResponse(struct soap *soap, struct ns__SetMultipleParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.ns__SetParameterResultList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetMultipleParametersResponse(struct soap *soap, const struct ns__SetMultipleParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetMultipleParametersResponse(struct soap *soap, const struct ns__SetMultipleParametersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetMultipleParametersResponse);
	if (soap_out_ns__SetMultipleParametersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetMultipleParametersResponse(struct soap *soap, const char *tag, int id, const struct ns__SetMultipleParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetMultipleParametersResponse), type))
		return soap->error;
	if (a->result.soap_out(soap, "result", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetMultipleParametersResponse * SOAP_FMAC4 soap_get_ns__SetMultipleParametersResponse(struct soap *soap, struct ns__SetMultipleParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetMultipleParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetMultipleParametersResponse * SOAP_FMAC4 soap_in_ns__SetMultipleParametersResponse(struct soap *soap, const char *tag, struct ns__SetMultipleParametersResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetMultipleParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetMultipleParametersResponse, sizeof(struct ns__SetMultipleParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__SetMultipleParametersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (a->result.soap_in(soap, "result", "ns:SetParameterResultList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetMultipleParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetMultipleParametersResponse, 0, sizeof(struct ns__SetMultipleParametersResponse), 0, soap_copy_ns__SetMultipleParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetMultipleParametersResponse * SOAP_FMAC6 soap_new_ns__SetMultipleParametersResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__SetMultipleParametersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetMultipleParametersResponse(struct soap *soap, struct ns__SetMultipleParametersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetMultipleParametersResponse * SOAP_FMAC4 soap_instantiate_ns__SetMultipleParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetMultipleParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetMultipleParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetMultipleParametersResponse;
		if (size)
			*size = sizeof(struct ns__SetMultipleParametersResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetMultipleParametersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetMultipleParametersResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetMultipleParametersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetMultipleParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetMultipleParametersResponse %p -> %p\n", q, p));
	*(struct ns__SetMultipleParametersResponse*)p = *(struct ns__SetMultipleParametersResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetOneParameter(struct soap *soap, struct ns__SetOneParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->inputNumber);
	soap_default_int(soap, &a->parameterIndex);
	soap_default_double(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetOneParameter(struct soap *soap, const struct ns__SetOneParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->value, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetOneParameter(struct soap *soap, const struct ns__SetOneParameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetOneParameter);
	if (soap_out_ns__SetOneParameter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetOneParameter(struct soap *soap, const char *tag, int id, const struct ns__SetOneParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetOneParameter), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	if (soap_out_int(soap, "parameterIndex", -1, &a->parameterIndex, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetOneParameter * SOAP_FMAC4 soap_get_ns__SetOneParameter(struct soap *soap, struct ns__SetOneParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetOneParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetOneParameter * SOAP_FMAC4 soap_in_ns__SetOneParameter(struct soap *soap, const char *tag, struct ns__SetOneParameter *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	size_t soap_flag_parameterIndex = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetOneParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetOneParameter, sizeof(struct ns__SetOneParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetOneParameter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputNumber", &a->inputNumber, "xsd:int"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap_flag_parameterIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "parameterIndex", &a->parameterIndex, "xsd:int"))
				{	soap_flag_parameterIndex--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetOneParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetOneParameter, 0, sizeof(struct ns__SetOneParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0 || soap_flag_parameterIndex > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetOneParameter * SOAP_FMAC6 soap_new_ns__SetOneParameter(struct soap *soap, int n)
{	return soap_instantiate_ns__SetOneParameter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetOneParameter(struct soap *soap, struct ns__SetOneParameter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetOneParameter * SOAP_FMAC4 soap_instantiate_ns__SetOneParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetOneParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetOneParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetOneParameter;
		if (size)
			*size = sizeof(struct ns__SetOneParameter);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetOneParameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetOneParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetOneParameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetOneParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetOneParameter %p -> %p\n", q, p));
	*(struct ns__SetOneParameter*)p = *(struct ns__SetOneParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetOneParameterResult(struct soap *soap, struct ns__SetOneParameterResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->roundedValue);
	soap_default_int(soap, &a->error);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetOneParameterResult(struct soap *soap, const struct ns__SetOneParameterResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->roundedValue, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetOneParameterResult(struct soap *soap, const struct ns__SetOneParameterResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetOneParameterResult);
	if (soap_out_ns__SetOneParameterResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetOneParameterResult(struct soap *soap, const char *tag, int id, const struct ns__SetOneParameterResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetOneParameterResult), type))
		return soap->error;
	if (soap_out_double(soap, "roundedValue", -1, &a->roundedValue, ""))
		return soap->error;
	if (soap_out_int(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetOneParameterResult * SOAP_FMAC4 soap_get_ns__SetOneParameterResult(struct soap *soap, struct ns__SetOneParameterResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetOneParameterResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetOneParameterResult * SOAP_FMAC4 soap_in_ns__SetOneParameterResult(struct soap *soap, const char *tag, struct ns__SetOneParameterResult *a, const char *type)
{
	size_t soap_flag_roundedValue = 1;
	size_t soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetOneParameterResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetOneParameterResult, sizeof(struct ns__SetOneParameterResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetOneParameterResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roundedValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "roundedValue", &a->roundedValue, "xsd:double"))
				{	soap_flag_roundedValue--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "error", &a->error, "xsd:int"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetOneParameterResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetOneParameterResult, 0, sizeof(struct ns__SetOneParameterResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roundedValue > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetOneParameterResult * SOAP_FMAC6 soap_new_ns__SetOneParameterResult(struct soap *soap, int n)
{	return soap_instantiate_ns__SetOneParameterResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetOneParameterResult(struct soap *soap, struct ns__SetOneParameterResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetOneParameterResult * SOAP_FMAC4 soap_instantiate_ns__SetOneParameterResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetOneParameterResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetOneParameterResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetOneParameterResult;
		if (size)
			*size = sizeof(struct ns__SetOneParameterResult);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetOneParameterResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetOneParameterResult);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetOneParameterResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetOneParameterResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetOneParameterResult %p -> %p\n", q, p));
	*(struct ns__SetOneParameterResult*)p = *(struct ns__SetOneParameterResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Parameter(struct soap *soap, struct ns__Parameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->inputNumber);
	soap_default_int(soap, &a->parameterIndex);
	soap_default_double(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Parameter(struct soap *soap, const struct ns__Parameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->value, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Parameter(struct soap *soap, const struct ns__Parameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Parameter);
	if (soap_out_ns__Parameter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Parameter(struct soap *soap, const char *tag, int id, const struct ns__Parameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Parameter), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	if (soap_out_int(soap, "parameterIndex", -1, &a->parameterIndex, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Parameter * SOAP_FMAC4 soap_get_ns__Parameter(struct soap *soap, struct ns__Parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Parameter * SOAP_FMAC4 soap_in_ns__Parameter(struct soap *soap, const char *tag, struct ns__Parameter *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	size_t soap_flag_parameterIndex = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Parameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Parameter, sizeof(struct ns__Parameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Parameter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputNumber", &a->inputNumber, "xsd:int"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap_flag_parameterIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "parameterIndex", &a->parameterIndex, "xsd:int"))
				{	soap_flag_parameterIndex--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Parameter, 0, sizeof(struct ns__Parameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0 || soap_flag_parameterIndex > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__Parameter * SOAP_FMAC6 soap_new_ns__Parameter(struct soap *soap, int n)
{	return soap_instantiate_ns__Parameter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__Parameter(struct soap *soap, struct ns__Parameter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__Parameter * SOAP_FMAC4 soap_instantiate_ns__Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Parameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__Parameter;
		if (size)
			*size = sizeof(struct ns__Parameter);
	}
	else
	{	cp->ptr = (void*)new struct ns__Parameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__Parameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__Parameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Parameter %p -> %p\n", q, p));
	*(struct ns__Parameter*)p = *(struct ns__Parameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetHardwareInfo(struct soap *soap, struct ns__GetHardwareInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetHardwareInfo(struct soap *soap, const struct ns__GetHardwareInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetHardwareInfo(struct soap *soap, const struct ns__GetHardwareInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetHardwareInfo);
	if (soap_out_ns__GetHardwareInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetHardwareInfo(struct soap *soap, const char *tag, int id, const struct ns__GetHardwareInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetHardwareInfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetHardwareInfo * SOAP_FMAC4 soap_get_ns__GetHardwareInfo(struct soap *soap, struct ns__GetHardwareInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetHardwareInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetHardwareInfo * SOAP_FMAC4 soap_in_ns__GetHardwareInfo(struct soap *soap, const char *tag, struct ns__GetHardwareInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetHardwareInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetHardwareInfo, sizeof(struct ns__GetHardwareInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetHardwareInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetHardwareInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetHardwareInfo, 0, sizeof(struct ns__GetHardwareInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetHardwareInfo * SOAP_FMAC6 soap_new_ns__GetHardwareInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__GetHardwareInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetHardwareInfo(struct soap *soap, struct ns__GetHardwareInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetHardwareInfo * SOAP_FMAC4 soap_instantiate_ns__GetHardwareInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetHardwareInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetHardwareInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetHardwareInfo;
		if (size)
			*size = sizeof(struct ns__GetHardwareInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetHardwareInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetHardwareInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetHardwareInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetHardwareInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetHardwareInfo %p -> %p\n", q, p));
	*(struct ns__GetHardwareInfo*)p = *(struct ns__GetHardwareInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HardwareInfo(struct soap *soap, struct ns__HardwareInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->device.ns__DeviceInfo::soap_default(soap);
	a->boards.ns__BoardInfoArray::soap_default(soap);
	a->inputs.ns__InputInfoArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HardwareInfo(struct soap *soap, const struct ns__HardwareInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->device.soap_serialize(soap);
	a->boards.soap_serialize(soap);
	a->inputs.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HardwareInfo(struct soap *soap, const struct ns__HardwareInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__HardwareInfo);
	if (soap_out_ns__HardwareInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HardwareInfo(struct soap *soap, const char *tag, int id, const struct ns__HardwareInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__HardwareInfo), type))
		return soap->error;
	if (a->device.soap_out(soap, "device", -1, ""))
		return soap->error;
	if (a->boards.soap_out(soap, "boards", -1, ""))
		return soap->error;
	if (a->inputs.soap_out(soap, "inputs", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__HardwareInfo * SOAP_FMAC4 soap_get_ns__HardwareInfo(struct soap *soap, struct ns__HardwareInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__HardwareInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__HardwareInfo * SOAP_FMAC4 soap_in_ns__HardwareInfo(struct soap *soap, const char *tag, struct ns__HardwareInfo *a, const char *type)
{
	size_t soap_flag_device = 1;
	size_t soap_flag_boards = 1;
	size_t soap_flag_inputs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__HardwareInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__HardwareInfo, sizeof(struct ns__HardwareInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__HardwareInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_device && soap->error == SOAP_TAG_MISMATCH)
				if (a->device.soap_in(soap, "device", "ns:DeviceInfo"))
				{	soap_flag_device--;
					continue;
				}
			if (soap_flag_boards && soap->error == SOAP_TAG_MISMATCH)
				if (a->boards.soap_in(soap, "boards", "ns:BoardInfoArray"))
				{	soap_flag_boards--;
					continue;
				}
			if (soap_flag_inputs && soap->error == SOAP_TAG_MISMATCH)
				if (a->inputs.soap_in(soap, "inputs", "ns:InputInfoArray"))
				{	soap_flag_inputs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__HardwareInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__HardwareInfo, 0, sizeof(struct ns__HardwareInfo), 0, soap_copy_ns__HardwareInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_device > 0 || soap_flag_boards > 0 || soap_flag_inputs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__HardwareInfo * SOAP_FMAC6 soap_new_ns__HardwareInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__HardwareInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__HardwareInfo(struct soap *soap, struct ns__HardwareInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__HardwareInfo * SOAP_FMAC4 soap_instantiate_ns__HardwareInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__HardwareInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__HardwareInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__HardwareInfo;
		if (size)
			*size = sizeof(struct ns__HardwareInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__HardwareInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__HardwareInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__HardwareInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__HardwareInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__HardwareInfo %p -> %p\n", q, p));
	*(struct ns__HardwareInfo*)p = *(struct ns__HardwareInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TaggedInputInfo(struct soap *soap, struct ns__TaggedInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_int(soap, &a->inputNumber);
	soap_default_ns__InputInfo(soap, &a->info);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__TaggedInputInfo(struct soap *soap, const struct ns__TaggedInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__InputInfo(soap, &a->info);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TaggedInputInfo(struct soap *soap, const struct ns__TaggedInputInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__TaggedInputInfo);
	if (soap_out_ns__TaggedInputInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TaggedInputInfo(struct soap *soap, const char *tag, int id, const struct ns__TaggedInputInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TaggedInputInfo), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "inputNumber", -1, &a->inputNumber, ""))
		return soap->error;
	if (soap_out_ns__InputInfo(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__TaggedInputInfo * SOAP_FMAC4 soap_get_ns__TaggedInputInfo(struct soap *soap, struct ns__TaggedInputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TaggedInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__TaggedInputInfo * SOAP_FMAC4 soap_in_ns__TaggedInputInfo(struct soap *soap, const char *tag, struct ns__TaggedInputInfo *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_inputNumber = 1;
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__TaggedInputInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TaggedInputInfo, sizeof(struct ns__TaggedInputInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__TaggedInputInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_inputNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputNumber", &a->inputNumber, "xsd:int"))
				{	soap_flag_inputNumber--;
					continue;
				}
			if (soap_flag_info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__InputInfo(soap, "info", &a->info, "ns:InputInfo"))
				{	soap_flag_info--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__TaggedInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TaggedInputInfo, 0, sizeof(struct ns__TaggedInputInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_inputNumber > 0 || soap_flag_info > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__TaggedInputInfo * SOAP_FMAC6 soap_new_ns__TaggedInputInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__TaggedInputInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__TaggedInputInfo(struct soap *soap, struct ns__TaggedInputInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__TaggedInputInfo * SOAP_FMAC4 soap_instantiate_ns__TaggedInputInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__TaggedInputInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__TaggedInputInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__TaggedInputInfo;
		if (size)
			*size = sizeof(struct ns__TaggedInputInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__TaggedInputInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__TaggedInputInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__TaggedInputInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__TaggedInputInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__TaggedInputInfo %p -> %p\n", q, p));
	*(struct ns__TaggedInputInfo*)p = *(struct ns__TaggedInputInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TaggedBoardInfo(struct soap *soap, struct ns__TaggedBoardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardAddress);
	soap_default_ns__BoardInfo(soap, &a->info);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__TaggedBoardInfo(struct soap *soap, const struct ns__TaggedBoardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__BoardInfo(soap, &a->info);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TaggedBoardInfo(struct soap *soap, const struct ns__TaggedBoardInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__TaggedBoardInfo);
	if (soap_out_ns__TaggedBoardInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TaggedBoardInfo(struct soap *soap, const char *tag, int id, const struct ns__TaggedBoardInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TaggedBoardInfo), type))
		return soap->error;
	if (soap_out_int(soap, "boardAddress", -1, &a->boardAddress, ""))
		return soap->error;
	if (soap_out_ns__BoardInfo(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__TaggedBoardInfo * SOAP_FMAC4 soap_get_ns__TaggedBoardInfo(struct soap *soap, struct ns__TaggedBoardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TaggedBoardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__TaggedBoardInfo * SOAP_FMAC4 soap_in_ns__TaggedBoardInfo(struct soap *soap, const char *tag, struct ns__TaggedBoardInfo *a, const char *type)
{
	size_t soap_flag_boardAddress = 1;
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__TaggedBoardInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TaggedBoardInfo, sizeof(struct ns__TaggedBoardInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__TaggedBoardInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardAddress", &a->boardAddress, "xsd:int"))
				{	soap_flag_boardAddress--;
					continue;
				}
			if (soap_flag_info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__BoardInfo(soap, "info", &a->info, "ns:BoardInfo"))
				{	soap_flag_info--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__TaggedBoardInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TaggedBoardInfo, 0, sizeof(struct ns__TaggedBoardInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardAddress > 0 || soap_flag_info > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__TaggedBoardInfo * SOAP_FMAC6 soap_new_ns__TaggedBoardInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__TaggedBoardInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__TaggedBoardInfo(struct soap *soap, struct ns__TaggedBoardInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__TaggedBoardInfo * SOAP_FMAC4 soap_instantiate_ns__TaggedBoardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__TaggedBoardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__TaggedBoardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__TaggedBoardInfo;
		if (size)
			*size = sizeof(struct ns__TaggedBoardInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__TaggedBoardInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__TaggedBoardInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__TaggedBoardInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__TaggedBoardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__TaggedBoardInfo %p -> %p\n", q, p));
	*(struct ns__TaggedBoardInfo*)p = *(struct ns__TaggedBoardInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__InputInfo(struct soap *soap, struct ns__InputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->inputClass);
	soap_default_int(soap, &a->hardwareVersion);
	soap_default_int(soap, &a->maxAdcSpeed);
	soap_default_int(soap, &a->adcResolution);
	soap_default_int(soap, &a->offsetOptions);
	soap_default_int(soap, &a->filterOptions);
	soap_default_int(soap, &a->diffOptions);
	soap_default_int(soap, &a->inputCouplingOptions);
	soap_default_Array11Ofdouble(soap, a->inputRanges);
	soap_default_int(soap, &a->maxMarkerMask);
	soap_default_Array12Ofint(soap, a->chargeInputRanges);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__InputInfo(struct soap *soap, const struct ns__InputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array11Ofdouble(soap, a->inputRanges);
	soap_serialize_Array12Ofint(soap, a->chargeInputRanges);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__InputInfo(struct soap *soap, const struct ns__InputInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__InputInfo);
	if (soap_out_ns__InputInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__InputInfo(struct soap *soap, const char *tag, int id, const struct ns__InputInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__InputInfo), type))
		return soap->error;
	if (soap_out_int(soap, "inputClass", -1, &a->inputClass, ""))
		return soap->error;
	if (soap_out_int(soap, "hardwareVersion", -1, &a->hardwareVersion, ""))
		return soap->error;
	if (soap_out_int(soap, "maxAdcSpeed", -1, &a->maxAdcSpeed, ""))
		return soap->error;
	if (soap_out_int(soap, "adcResolution", -1, &a->adcResolution, ""))
		return soap->error;
	if (soap_out_int(soap, "offsetOptions", -1, &a->offsetOptions, ""))
		return soap->error;
	if (soap_out_int(soap, "filterOptions", -1, &a->filterOptions, ""))
		return soap->error;
	if (soap_out_int(soap, "diffOptions", -1, &a->diffOptions, ""))
		return soap->error;
	if (soap_out_int(soap, "inputCouplingOptions", -1, &a->inputCouplingOptions, ""))
		return soap->error;
	soap_out_Array11Ofdouble(soap, "inputRanges", -1, a->inputRanges, "");
	if (soap_out_int(soap, "maxMarkerMask", -1, &a->maxMarkerMask, ""))
		return soap->error;
	soap_out_Array12Ofint(soap, "chargeInputRanges", -1, a->chargeInputRanges, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__InputInfo * SOAP_FMAC4 soap_get_ns__InputInfo(struct soap *soap, struct ns__InputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__InputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__InputInfo * SOAP_FMAC4 soap_in_ns__InputInfo(struct soap *soap, const char *tag, struct ns__InputInfo *a, const char *type)
{
	size_t soap_flag_inputClass = 1;
	size_t soap_flag_hardwareVersion = 1;
	size_t soap_flag_maxAdcSpeed = 1;
	size_t soap_flag_adcResolution = 1;
	size_t soap_flag_offsetOptions = 1;
	size_t soap_flag_filterOptions = 1;
	size_t soap_flag_diffOptions = 1;
	size_t soap_flag_inputCouplingOptions = 1;
	size_t soap_flag_inputRanges = 1;
	size_t soap_flag_maxMarkerMask = 1;
	size_t soap_flag_chargeInputRanges = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__InputInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__InputInfo, sizeof(struct ns__InputInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__InputInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inputClass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputClass", &a->inputClass, "xsd:int"))
				{	soap_flag_inputClass--;
					continue;
				}
			if (soap_flag_hardwareVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hardwareVersion", &a->hardwareVersion, "xsd:int"))
				{	soap_flag_hardwareVersion--;
					continue;
				}
			if (soap_flag_maxAdcSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxAdcSpeed", &a->maxAdcSpeed, "xsd:int"))
				{	soap_flag_maxAdcSpeed--;
					continue;
				}
			if (soap_flag_adcResolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "adcResolution", &a->adcResolution, "xsd:int"))
				{	soap_flag_adcResolution--;
					continue;
				}
			if (soap_flag_offsetOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offsetOptions", &a->offsetOptions, "xsd:int"))
				{	soap_flag_offsetOptions--;
					continue;
				}
			if (soap_flag_filterOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "filterOptions", &a->filterOptions, "xsd:int"))
				{	soap_flag_filterOptions--;
					continue;
				}
			if (soap_flag_diffOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "diffOptions", &a->diffOptions, "xsd:int"))
				{	soap_flag_diffOptions--;
					continue;
				}
			if (soap_flag_inputCouplingOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inputCouplingOptions", &a->inputCouplingOptions, "xsd:int"))
				{	soap_flag_inputCouplingOptions--;
					continue;
				}
			if (soap_flag_inputRanges && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array11Ofdouble(soap, "inputRanges", a->inputRanges, "xsd:double"))
				{	soap_flag_inputRanges--;
					continue;
				}
			if (soap_flag_maxMarkerMask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxMarkerMask", &a->maxMarkerMask, "xsd:int"))
				{	soap_flag_maxMarkerMask--;
					continue;
				}
			if (soap_flag_chargeInputRanges && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array12Ofint(soap, "chargeInputRanges", a->chargeInputRanges, "xsd:int"))
				{	soap_flag_chargeInputRanges--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__InputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__InputInfo, 0, sizeof(struct ns__InputInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inputClass > 0 || soap_flag_hardwareVersion > 0 || soap_flag_maxAdcSpeed > 0 || soap_flag_adcResolution > 0 || soap_flag_offsetOptions > 0 || soap_flag_filterOptions > 0 || soap_flag_diffOptions > 0 || soap_flag_inputCouplingOptions > 0 || soap_flag_inputRanges > 0 || soap_flag_maxMarkerMask > 0 || soap_flag_chargeInputRanges > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__InputInfo * SOAP_FMAC6 soap_new_ns__InputInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__InputInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__InputInfo(struct soap *soap, struct ns__InputInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__InputInfo * SOAP_FMAC4 soap_instantiate_ns__InputInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__InputInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__InputInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__InputInfo;
		if (size)
			*size = sizeof(struct ns__InputInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__InputInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__InputInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__InputInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__InputInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__InputInfo %p -> %p\n", q, p));
	*(struct ns__InputInfo*)p = *(struct ns__InputInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__BoardInfo(struct soap *soap, struct ns__BoardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->boardClass);
	soap_default_int(soap, &a->hardwareVersion);
	soap_default_int(soap, &a->serialNr);
	soap_default_int(soap, &a->driverVersion);
	soap_default_int(soap, &a->firmwareVersion);
	soap_default_int(soap, &a->numberOfInputs);
	soap_default_int(soap, &a->maxMemory);
	soap_default_int(soap, &a->maxSpeed);
	soap_default_int(soap, &a->operationModeOptions);
	soap_default_int(soap, &a->averageOptions);
	soap_default_int(soap, &a->triggerOptions);
	soap_default_ns__DateTime(soap, &a->lastFactoryCalibration);
	soap_default_ns__DateTime(soap, &a->lastUserCalibration);
	soap_default_int(soap, &a->maxAdcSpeed);
	soap_default_int(soap, &a->boardClock);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__BoardInfo(struct soap *soap, const struct ns__BoardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__DateTime(soap, &a->lastFactoryCalibration);
	soap_serialize_ns__DateTime(soap, &a->lastUserCalibration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__BoardInfo(struct soap *soap, const struct ns__BoardInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__BoardInfo);
	if (soap_out_ns__BoardInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__BoardInfo(struct soap *soap, const char *tag, int id, const struct ns__BoardInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__BoardInfo), type))
		return soap->error;
	if (soap_out_int(soap, "boardClass", -1, &a->boardClass, ""))
		return soap->error;
	if (soap_out_int(soap, "hardwareVersion", -1, &a->hardwareVersion, ""))
		return soap->error;
	if (soap_out_int(soap, "serialNr", -1, &a->serialNr, ""))
		return soap->error;
	if (soap_out_int(soap, "driverVersion", -1, &a->driverVersion, ""))
		return soap->error;
	if (soap_out_int(soap, "firmwareVersion", -1, &a->firmwareVersion, ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfInputs", -1, &a->numberOfInputs, ""))
		return soap->error;
	if (soap_out_int(soap, "maxMemory", -1, &a->maxMemory, ""))
		return soap->error;
	if (soap_out_int(soap, "maxSpeed", -1, &a->maxSpeed, ""))
		return soap->error;
	if (soap_out_int(soap, "operationModeOptions", -1, &a->operationModeOptions, ""))
		return soap->error;
	if (soap_out_int(soap, "averageOptions", -1, &a->averageOptions, ""))
		return soap->error;
	if (soap_out_int(soap, "triggerOptions", -1, &a->triggerOptions, ""))
		return soap->error;
	if (soap_out_ns__DateTime(soap, "lastFactoryCalibration", -1, &a->lastFactoryCalibration, ""))
		return soap->error;
	if (soap_out_ns__DateTime(soap, "lastUserCalibration", -1, &a->lastUserCalibration, ""))
		return soap->error;
	if (soap_out_int(soap, "maxAdcSpeed", -1, &a->maxAdcSpeed, ""))
		return soap->error;
	if (soap_out_int(soap, "boardClock", -1, &a->boardClock, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__BoardInfo * SOAP_FMAC4 soap_get_ns__BoardInfo(struct soap *soap, struct ns__BoardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__BoardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__BoardInfo * SOAP_FMAC4 soap_in_ns__BoardInfo(struct soap *soap, const char *tag, struct ns__BoardInfo *a, const char *type)
{
	size_t soap_flag_boardClass = 1;
	size_t soap_flag_hardwareVersion = 1;
	size_t soap_flag_serialNr = 1;
	size_t soap_flag_driverVersion = 1;
	size_t soap_flag_firmwareVersion = 1;
	size_t soap_flag_numberOfInputs = 1;
	size_t soap_flag_maxMemory = 1;
	size_t soap_flag_maxSpeed = 1;
	size_t soap_flag_operationModeOptions = 1;
	size_t soap_flag_averageOptions = 1;
	size_t soap_flag_triggerOptions = 1;
	size_t soap_flag_lastFactoryCalibration = 1;
	size_t soap_flag_lastUserCalibration = 1;
	size_t soap_flag_maxAdcSpeed = 1;
	size_t soap_flag_boardClock = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__BoardInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__BoardInfo, sizeof(struct ns__BoardInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__BoardInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boardClass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardClass", &a->boardClass, "xsd:int"))
				{	soap_flag_boardClass--;
					continue;
				}
			if (soap_flag_hardwareVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hardwareVersion", &a->hardwareVersion, "xsd:int"))
				{	soap_flag_hardwareVersion--;
					continue;
				}
			if (soap_flag_serialNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "serialNr", &a->serialNr, "xsd:int"))
				{	soap_flag_serialNr--;
					continue;
				}
			if (soap_flag_driverVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "driverVersion", &a->driverVersion, "xsd:int"))
				{	soap_flag_driverVersion--;
					continue;
				}
			if (soap_flag_firmwareVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "firmwareVersion", &a->firmwareVersion, "xsd:int"))
				{	soap_flag_firmwareVersion--;
					continue;
				}
			if (soap_flag_numberOfInputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfInputs", &a->numberOfInputs, "xsd:int"))
				{	soap_flag_numberOfInputs--;
					continue;
				}
			if (soap_flag_maxMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxMemory", &a->maxMemory, "xsd:int"))
				{	soap_flag_maxMemory--;
					continue;
				}
			if (soap_flag_maxSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxSpeed", &a->maxSpeed, "xsd:int"))
				{	soap_flag_maxSpeed--;
					continue;
				}
			if (soap_flag_operationModeOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "operationModeOptions", &a->operationModeOptions, "xsd:int"))
				{	soap_flag_operationModeOptions--;
					continue;
				}
			if (soap_flag_averageOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "averageOptions", &a->averageOptions, "xsd:int"))
				{	soap_flag_averageOptions--;
					continue;
				}
			if (soap_flag_triggerOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "triggerOptions", &a->triggerOptions, "xsd:int"))
				{	soap_flag_triggerOptions--;
					continue;
				}
			if (soap_flag_lastFactoryCalibration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__DateTime(soap, "lastFactoryCalibration", &a->lastFactoryCalibration, "ns:DateTime"))
				{	soap_flag_lastFactoryCalibration--;
					continue;
				}
			if (soap_flag_lastUserCalibration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__DateTime(soap, "lastUserCalibration", &a->lastUserCalibration, "ns:DateTime"))
				{	soap_flag_lastUserCalibration--;
					continue;
				}
			if (soap_flag_maxAdcSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxAdcSpeed", &a->maxAdcSpeed, "xsd:int"))
				{	soap_flag_maxAdcSpeed--;
					continue;
				}
			if (soap_flag_boardClock && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boardClock", &a->boardClock, "xsd:int"))
				{	soap_flag_boardClock--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__BoardInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__BoardInfo, 0, sizeof(struct ns__BoardInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boardClass > 0 || soap_flag_hardwareVersion > 0 || soap_flag_serialNr > 0 || soap_flag_driverVersion > 0 || soap_flag_firmwareVersion > 0 || soap_flag_numberOfInputs > 0 || soap_flag_maxMemory > 0 || soap_flag_maxSpeed > 0 || soap_flag_operationModeOptions > 0 || soap_flag_averageOptions > 0 || soap_flag_triggerOptions > 0 || soap_flag_lastFactoryCalibration > 0 || soap_flag_lastUserCalibration > 0 || soap_flag_maxAdcSpeed > 0 || soap_flag_boardClock > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__BoardInfo * SOAP_FMAC6 soap_new_ns__BoardInfo(struct soap *soap, int n)
{	return soap_instantiate_ns__BoardInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__BoardInfo(struct soap *soap, struct ns__BoardInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__BoardInfo * SOAP_FMAC4 soap_instantiate_ns__BoardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__BoardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__BoardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__BoardInfo;
		if (size)
			*size = sizeof(struct ns__BoardInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns__BoardInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__BoardInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__BoardInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__BoardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__BoardInfo %p -> %p\n", q, p));
	*(struct ns__BoardInfo*)p = *(struct ns__BoardInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetClusterConfiguration(struct soap *soap, struct ns__SetClusterConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns__ClusterConfiguration(soap, &a->clusters);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetClusterConfiguration(struct soap *soap, const struct ns__SetClusterConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns__ClusterConfiguration(soap, &a->clusters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetClusterConfiguration(struct soap *soap, const struct ns__SetClusterConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SetClusterConfiguration);
	if (soap_out_ns__SetClusterConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetClusterConfiguration(struct soap *soap, const char *tag, int id, const struct ns__SetClusterConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetClusterConfiguration), type))
		return soap->error;
	if (soap_out_ns__ClusterConfiguration(soap, "clusters", -1, &a->clusters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetClusterConfiguration * SOAP_FMAC4 soap_get_ns__SetClusterConfiguration(struct soap *soap, struct ns__SetClusterConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetClusterConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetClusterConfiguration * SOAP_FMAC4 soap_in_ns__SetClusterConfiguration(struct soap *soap, const char *tag, struct ns__SetClusterConfiguration *a, const char *type)
{
	size_t soap_flag_clusters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetClusterConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetClusterConfiguration, sizeof(struct ns__SetClusterConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SetClusterConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clusters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__ClusterConfiguration(soap, "clusters", &a->clusters, "ns:ClusterConfiguration"))
				{	soap_flag_clusters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SetClusterConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetClusterConfiguration, 0, sizeof(struct ns__SetClusterConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clusters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__SetClusterConfiguration * SOAP_FMAC6 soap_new_ns__SetClusterConfiguration(struct soap *soap, int n)
{	return soap_instantiate_ns__SetClusterConfiguration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__SetClusterConfiguration(struct soap *soap, struct ns__SetClusterConfiguration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__SetClusterConfiguration * SOAP_FMAC4 soap_instantiate_ns__SetClusterConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetClusterConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__SetClusterConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__SetClusterConfiguration;
		if (size)
			*size = sizeof(struct ns__SetClusterConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct ns__SetClusterConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__SetClusterConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__SetClusterConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__SetClusterConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__SetClusterConfiguration %p -> %p\n", q, p));
	*(struct ns__SetClusterConfiguration*)p = *(struct ns__SetClusterConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetClusterConfiguration(struct soap *soap, struct ns__GetClusterConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetClusterConfiguration(struct soap *soap, const struct ns__GetClusterConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetClusterConfiguration(struct soap *soap, const struct ns__GetClusterConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetClusterConfiguration);
	if (soap_out_ns__GetClusterConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetClusterConfiguration(struct soap *soap, const char *tag, int id, const struct ns__GetClusterConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetClusterConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetClusterConfiguration * SOAP_FMAC4 soap_get_ns__GetClusterConfiguration(struct soap *soap, struct ns__GetClusterConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetClusterConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetClusterConfiguration * SOAP_FMAC4 soap_in_ns__GetClusterConfiguration(struct soap *soap, const char *tag, struct ns__GetClusterConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetClusterConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetClusterConfiguration, sizeof(struct ns__GetClusterConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetClusterConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetClusterConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetClusterConfiguration, 0, sizeof(struct ns__GetClusterConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetClusterConfiguration * SOAP_FMAC6 soap_new_ns__GetClusterConfiguration(struct soap *soap, int n)
{	return soap_instantiate_ns__GetClusterConfiguration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetClusterConfiguration(struct soap *soap, struct ns__GetClusterConfiguration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetClusterConfiguration * SOAP_FMAC4 soap_instantiate_ns__GetClusterConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetClusterConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetClusterConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetClusterConfiguration;
		if (size)
			*size = sizeof(struct ns__GetClusterConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetClusterConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetClusterConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetClusterConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetClusterConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetClusterConfiguration %p -> %p\n", q, p));
	*(struct ns__GetClusterConfiguration*)p = *(struct ns__GetClusterConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ClusterConfiguration(struct soap *soap, struct ns__ClusterConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_Array16Ofint(soap, a->clusterNumbers);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ClusterConfiguration(struct soap *soap, const struct ns__ClusterConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array16Ofint(soap, a->clusterNumbers);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ClusterConfiguration(struct soap *soap, const struct ns__ClusterConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ClusterConfiguration);
	if (soap_out_ns__ClusterConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ClusterConfiguration(struct soap *soap, const char *tag, int id, const struct ns__ClusterConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ClusterConfiguration), type))
		return soap->error;
	soap_out_Array16Ofint(soap, "clusterNumbers", -1, a->clusterNumbers, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ClusterConfiguration * SOAP_FMAC4 soap_get_ns__ClusterConfiguration(struct soap *soap, struct ns__ClusterConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ClusterConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ClusterConfiguration * SOAP_FMAC4 soap_in_ns__ClusterConfiguration(struct soap *soap, const char *tag, struct ns__ClusterConfiguration *a, const char *type)
{
	size_t soap_flag_clusterNumbers = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ClusterConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ClusterConfiguration, sizeof(struct ns__ClusterConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ClusterConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clusterNumbers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array16Ofint(soap, "clusterNumbers", a->clusterNumbers, "xsd:int"))
				{	soap_flag_clusterNumbers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ClusterConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ClusterConfiguration, 0, sizeof(struct ns__ClusterConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clusterNumbers > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ClusterConfiguration * SOAP_FMAC6 soap_new_ns__ClusterConfiguration(struct soap *soap, int n)
{	return soap_instantiate_ns__ClusterConfiguration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ClusterConfiguration(struct soap *soap, struct ns__ClusterConfiguration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ClusterConfiguration * SOAP_FMAC4 soap_instantiate_ns__ClusterConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ClusterConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ClusterConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ClusterConfiguration;
		if (size)
			*size = sizeof(struct ns__ClusterConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct ns__ClusterConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ClusterConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ClusterConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ClusterConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ClusterConfiguration %p -> %p\n", q, p));
	*(struct ns__ClusterConfiguration*)p = *(struct ns__ClusterConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ReleaseDeviceLock(struct soap *soap, struct ns__ReleaseDeviceLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ReleaseDeviceLock(struct soap *soap, const struct ns__ReleaseDeviceLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ReleaseDeviceLock(struct soap *soap, const struct ns__ReleaseDeviceLock *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ReleaseDeviceLock);
	if (soap_out_ns__ReleaseDeviceLock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReleaseDeviceLock(struct soap *soap, const char *tag, int id, const struct ns__ReleaseDeviceLock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ReleaseDeviceLock), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ReleaseDeviceLock * SOAP_FMAC4 soap_get_ns__ReleaseDeviceLock(struct soap *soap, struct ns__ReleaseDeviceLock *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ReleaseDeviceLock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ReleaseDeviceLock * SOAP_FMAC4 soap_in_ns__ReleaseDeviceLock(struct soap *soap, const char *tag, struct ns__ReleaseDeviceLock *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ReleaseDeviceLock *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ReleaseDeviceLock, sizeof(struct ns__ReleaseDeviceLock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ReleaseDeviceLock(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ReleaseDeviceLock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ReleaseDeviceLock, 0, sizeof(struct ns__ReleaseDeviceLock), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ReleaseDeviceLock * SOAP_FMAC6 soap_new_ns__ReleaseDeviceLock(struct soap *soap, int n)
{	return soap_instantiate_ns__ReleaseDeviceLock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ReleaseDeviceLock(struct soap *soap, struct ns__ReleaseDeviceLock *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ReleaseDeviceLock * SOAP_FMAC4 soap_instantiate_ns__ReleaseDeviceLock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ReleaseDeviceLock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ReleaseDeviceLock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ReleaseDeviceLock;
		if (size)
			*size = sizeof(struct ns__ReleaseDeviceLock);
	}
	else
	{	cp->ptr = (void*)new struct ns__ReleaseDeviceLock[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ReleaseDeviceLock);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ReleaseDeviceLock*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ReleaseDeviceLock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ReleaseDeviceLock %p -> %p\n", q, p));
	*(struct ns__ReleaseDeviceLock*)p = *(struct ns__ReleaseDeviceLock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AcquireDeviceLock(struct soap *soap, struct ns__AcquireDeviceLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AcquireDeviceLock(struct soap *soap, const struct ns__AcquireDeviceLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AcquireDeviceLock(struct soap *soap, const struct ns__AcquireDeviceLock *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AcquireDeviceLock);
	if (soap_out_ns__AcquireDeviceLock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AcquireDeviceLock(struct soap *soap, const char *tag, int id, const struct ns__AcquireDeviceLock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AcquireDeviceLock), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AcquireDeviceLock * SOAP_FMAC4 soap_get_ns__AcquireDeviceLock(struct soap *soap, struct ns__AcquireDeviceLock *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AcquireDeviceLock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AcquireDeviceLock * SOAP_FMAC4 soap_in_ns__AcquireDeviceLock(struct soap *soap, const char *tag, struct ns__AcquireDeviceLock *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AcquireDeviceLock *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AcquireDeviceLock, sizeof(struct ns__AcquireDeviceLock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__AcquireDeviceLock(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__AcquireDeviceLock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AcquireDeviceLock, 0, sizeof(struct ns__AcquireDeviceLock), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__AcquireDeviceLock * SOAP_FMAC6 soap_new_ns__AcquireDeviceLock(struct soap *soap, int n)
{	return soap_instantiate_ns__AcquireDeviceLock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__AcquireDeviceLock(struct soap *soap, struct ns__AcquireDeviceLock *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__AcquireDeviceLock * SOAP_FMAC4 soap_instantiate_ns__AcquireDeviceLock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AcquireDeviceLock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__AcquireDeviceLock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__AcquireDeviceLock;
		if (size)
			*size = sizeof(struct ns__AcquireDeviceLock);
	}
	else
	{	cp->ptr = (void*)new struct ns__AcquireDeviceLock[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__AcquireDeviceLock);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__AcquireDeviceLock*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__AcquireDeviceLock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__AcquireDeviceLock %p -> %p\n", q, p));
	*(struct ns__AcquireDeviceLock*)p = *(struct ns__AcquireDeviceLock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ResetConfiguration(struct soap *soap, struct ns__ResetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ResetConfiguration(struct soap *soap, const struct ns__ResetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ResetConfiguration(struct soap *soap, const struct ns__ResetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ResetConfiguration);
	if (soap_out_ns__ResetConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ResetConfiguration(struct soap *soap, const char *tag, int id, const struct ns__ResetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ResetConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ResetConfiguration * SOAP_FMAC4 soap_get_ns__ResetConfiguration(struct soap *soap, struct ns__ResetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ResetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__ResetConfiguration * SOAP_FMAC4 soap_in_ns__ResetConfiguration(struct soap *soap, const char *tag, struct ns__ResetConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ResetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ResetConfiguration, sizeof(struct ns__ResetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ResetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ResetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ResetConfiguration, 0, sizeof(struct ns__ResetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__ResetConfiguration * SOAP_FMAC6 soap_new_ns__ResetConfiguration(struct soap *soap, int n)
{	return soap_instantiate_ns__ResetConfiguration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__ResetConfiguration(struct soap *soap, struct ns__ResetConfiguration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__ResetConfiguration * SOAP_FMAC4 soap_instantiate_ns__ResetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ResetConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ResetConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__ResetConfiguration;
		if (size)
			*size = sizeof(struct ns__ResetConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct ns__ResetConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ResetConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ResetConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ResetConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ResetConfiguration %p -> %p\n", q, p));
	*(struct ns__ResetConfiguration*)p = *(struct ns__ResetConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetInterfaceVersion(struct soap *soap, struct ns__GetInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetInterfaceVersion(struct soap *soap, const struct ns__GetInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetInterfaceVersion(struct soap *soap, const struct ns__GetInterfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetInterfaceVersion);
	if (soap_out_ns__GetInterfaceVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetInterfaceVersion(struct soap *soap, const char *tag, int id, const struct ns__GetInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetInterfaceVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetInterfaceVersion * SOAP_FMAC4 soap_get_ns__GetInterfaceVersion(struct soap *soap, struct ns__GetInterfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetInterfaceVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetInterfaceVersion * SOAP_FMAC4 soap_in_ns__GetInterfaceVersion(struct soap *soap, const char *tag, struct ns__GetInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetInterfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetInterfaceVersion, sizeof(struct ns__GetInterfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetInterfaceVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetInterfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetInterfaceVersion, 0, sizeof(struct ns__GetInterfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetInterfaceVersion * SOAP_FMAC6 soap_new_ns__GetInterfaceVersion(struct soap *soap, int n)
{	return soap_instantiate_ns__GetInterfaceVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetInterfaceVersion(struct soap *soap, struct ns__GetInterfaceVersion *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetInterfaceVersion * SOAP_FMAC4 soap_instantiate_ns__GetInterfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetInterfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetInterfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetInterfaceVersion;
		if (size)
			*size = sizeof(struct ns__GetInterfaceVersion);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetInterfaceVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetInterfaceVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetInterfaceVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetInterfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetInterfaceVersion %p -> %p\n", q, p));
	*(struct ns__GetInterfaceVersion*)p = *(struct ns__GetInterfaceVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetInterfaceVersionResponse(struct soap *soap, struct ns__GetInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->version);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetInterfaceVersionResponse(struct soap *soap, const struct ns__GetInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetInterfaceVersionResponse(struct soap *soap, const struct ns__GetInterfaceVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GetInterfaceVersionResponse);
	if (soap_out_ns__GetInterfaceVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetInterfaceVersionResponse(struct soap *soap, const char *tag, int id, const struct ns__GetInterfaceVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetInterfaceVersionResponse), type))
		return soap->error;
	if (soap_out_int(soap, "version", -1, &a->version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetInterfaceVersionResponse * SOAP_FMAC4 soap_get_ns__GetInterfaceVersionResponse(struct soap *soap, struct ns__GetInterfaceVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetInterfaceVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GetInterfaceVersionResponse * SOAP_FMAC4 soap_in_ns__GetInterfaceVersionResponse(struct soap *soap, const char *tag, struct ns__GetInterfaceVersionResponse *a, const char *type)
{
	size_t soap_flag_version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetInterfaceVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetInterfaceVersionResponse, sizeof(struct ns__GetInterfaceVersionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__GetInterfaceVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "version", &a->version, "xsd:int"))
				{	soap_flag_version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__GetInterfaceVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetInterfaceVersionResponse, 0, sizeof(struct ns__GetInterfaceVersionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_version > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__GetInterfaceVersionResponse * SOAP_FMAC6 soap_new_ns__GetInterfaceVersionResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__GetInterfaceVersionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__GetInterfaceVersionResponse(struct soap *soap, struct ns__GetInterfaceVersionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__GetInterfaceVersionResponse * SOAP_FMAC4 soap_instantiate_ns__GetInterfaceVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetInterfaceVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__GetInterfaceVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__GetInterfaceVersionResponse;
		if (size)
			*size = sizeof(struct ns__GetInterfaceVersionResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__GetInterfaceVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__GetInterfaceVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__GetInterfaceVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__GetInterfaceVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__GetInterfaceVersionResponse %p -> %p\n", q, p));
	*(struct ns__GetInterfaceVersionResponse*)p = *(struct ns__GetInterfaceVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DateTime(struct soap *soap, struct ns__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->year);
	soap_default_int(soap, &a->month);
	soap_default_int(soap, &a->day);
	soap_default_int(soap, &a->hour);
	soap_default_int(soap, &a->minute);
	soap_default_int(soap, &a->second);
	soap_default_int(soap, &a->milliSecond);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DateTime(struct soap *soap, const struct ns__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DateTime(struct soap *soap, const struct ns__DateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__DateTime);
	if (soap_out_ns__DateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DateTime(struct soap *soap, const char *tag, int id, const struct ns__DateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DateTime), type))
		return soap->error;
	if (soap_out_int(soap, "year", -1, &a->year, ""))
		return soap->error;
	if (soap_out_int(soap, "month", -1, &a->month, ""))
		return soap->error;
	if (soap_out_int(soap, "day", -1, &a->day, ""))
		return soap->error;
	if (soap_out_int(soap, "hour", -1, &a->hour, ""))
		return soap->error;
	if (soap_out_int(soap, "minute", -1, &a->minute, ""))
		return soap->error;
	if (soap_out_int(soap, "second", -1, &a->second, ""))
		return soap->error;
	if (soap_out_int(soap, "milliSecond", -1, &a->milliSecond, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DateTime * SOAP_FMAC4 soap_get_ns__DateTime(struct soap *soap, struct ns__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__DateTime * SOAP_FMAC4 soap_in_ns__DateTime(struct soap *soap, const char *tag, struct ns__DateTime *a, const char *type)
{
	size_t soap_flag_year = 1;
	size_t soap_flag_month = 1;
	size_t soap_flag_day = 1;
	size_t soap_flag_hour = 1;
	size_t soap_flag_minute = 1;
	size_t soap_flag_second = 1;
	size_t soap_flag_milliSecond = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DateTime, sizeof(struct ns__DateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__DateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "year", &a->year, "xsd:int"))
				{	soap_flag_year--;
					continue;
				}
			if (soap_flag_month && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "month", &a->month, "xsd:int"))
				{	soap_flag_month--;
					continue;
				}
			if (soap_flag_day && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "day", &a->day, "xsd:int"))
				{	soap_flag_day--;
					continue;
				}
			if (soap_flag_hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hour", &a->hour, "xsd:int"))
				{	soap_flag_hour--;
					continue;
				}
			if (soap_flag_minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "minute", &a->minute, "xsd:int"))
				{	soap_flag_minute--;
					continue;
				}
			if (soap_flag_second && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "second", &a->second, "xsd:int"))
				{	soap_flag_second--;
					continue;
				}
			if (soap_flag_milliSecond && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "milliSecond", &a->milliSecond, "xsd:int"))
				{	soap_flag_milliSecond--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DateTime, 0, sizeof(struct ns__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_year > 0 || soap_flag_month > 0 || soap_flag_day > 0 || soap_flag_hour > 0 || soap_flag_minute > 0 || soap_flag_second > 0 || soap_flag_milliSecond > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__DateTime * SOAP_FMAC6 soap_new_ns__DateTime(struct soap *soap, int n)
{	return soap_instantiate_ns__DateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DateTime(struct soap *soap, struct ns__DateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__DateTime * SOAP_FMAC4 soap_instantiate_ns__DateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__DateTime;
		if (size)
			*size = sizeof(struct ns__DateTime);
	}
	else
	{	cp->ptr = (void*)new struct ns__DateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__DateTime);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__DateTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__DateTime %p -> %p\n", q, p));
	*(struct ns__DateTime*)p = *(struct ns__DateTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DummyResponse(struct soap *soap, struct ns__DummyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DummyResponse(struct soap *soap, const struct ns__DummyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DummyResponse(struct soap *soap, const struct ns__DummyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__DummyResponse);
	if (soap_out_ns__DummyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DummyResponse(struct soap *soap, const char *tag, int id, const struct ns__DummyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DummyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DummyResponse * SOAP_FMAC4 soap_get_ns__DummyResponse(struct soap *soap, struct ns__DummyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__DummyResponse * SOAP_FMAC4 soap_in_ns__DummyResponse(struct soap *soap, const char *tag, struct ns__DummyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DummyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DummyResponse, sizeof(struct ns__DummyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__DummyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__DummyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DummyResponse, 0, sizeof(struct ns__DummyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__DummyResponse * SOAP_FMAC6 soap_new_ns__DummyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__DummyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__DummyResponse(struct soap *soap, struct ns__DummyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__DummyResponse * SOAP_FMAC4 soap_instantiate_ns__DummyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DummyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__DummyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__DummyResponse;
		if (size)
			*size = sizeof(struct ns__DummyResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__DummyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__DummyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__DummyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__DummyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__DummyResponse %p -> %p\n", q, p));
	*(struct ns__DummyResponse*)p = *(struct ns__DummyResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons__DataSpecification(struct soap *soap, ns__DataSpecification **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons__DataSpecification))
		soap_serialize_PointerTons__DataSpecification(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons__DataSpecification(struct soap *soap, ns__DataSpecification **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons__DataSpecification);
	if (soap_out_PointerToPointerTons__DataSpecification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons__DataSpecification(struct soap *soap, const char *tag, int id, ns__DataSpecification **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons__DataSpecification);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons__DataSpecification(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns__DataSpecification *** SOAP_FMAC4 soap_get_PointerToPointerTons__DataSpecification(struct soap *soap, ns__DataSpecification ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons__DataSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns__DataSpecification *** SOAP_FMAC4 soap_in_PointerToPointerTons__DataSpecification(struct soap *soap, const char *tag, ns__DataSpecification ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns__DataSpecification ***)soap_malloc(soap, sizeof(ns__DataSpecification **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons__DataSpecification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns__DataSpecification ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons__DataSpecification, sizeof(ns__DataSpecification *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__DataSpecification(struct soap *soap, ns__DataSpecification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__DataSpecification))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__DataSpecification(struct soap *soap, ns__DataSpecification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__DataSpecification);
	if (soap_out_PointerTons__DataSpecification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__DataSpecification(struct soap *soap, const char *tag, int id, ns__DataSpecification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__DataSpecification);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__DataSpecification ** SOAP_FMAC4 soap_get_PointerTons__DataSpecification(struct soap *soap, ns__DataSpecification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__DataSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns__DataSpecification ** SOAP_FMAC4 soap_in_PointerTons__DataSpecification(struct soap *soap, const char *tag, ns__DataSpecification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns__DataSpecification **)soap_malloc(soap, sizeof(ns__DataSpecification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__DataSpecification *)soap_instantiate_ns__DataSpecification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns__DataSpecification ** p = (ns__DataSpecification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__DataSpecification, sizeof(ns__DataSpecification), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns__DataSpecification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__RangeDataSpecification, sizeof(ns__RangeDataSpecification), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns__DataSpecification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__EnvelopeDataSpecification, sizeof(ns__EnvelopeDataSpecification), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__YMetadata(struct soap *soap, struct ns__YMetadata *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__YMetadata))
		soap_serialize_ns__YMetadata(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__YMetadata(struct soap *soap, struct ns__YMetadata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__YMetadata);
	if (soap_out_PointerTons__YMetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__YMetadata(struct soap *soap, const char *tag, int id, struct ns__YMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__YMetadata);
	if (id < 0)
		return soap->error;
	return soap_out_ns__YMetadata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__YMetadata ** SOAP_FMAC4 soap_get_PointerTons__YMetadata(struct soap *soap, struct ns__YMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__YMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__YMetadata ** SOAP_FMAC4 soap_in_PointerTons__YMetadata(struct soap *soap, const char *tag, struct ns__YMetadata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__YMetadata **)soap_malloc(soap, sizeof(struct ns__YMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__YMetadata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__YMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__YMetadata, sizeof(struct ns__YMetadata), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Metadata(struct soap *soap, struct ns__Metadata *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Metadata))
		soap_serialize_ns__Metadata(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Metadata(struct soap *soap, struct ns__Metadata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Metadata);
	if (soap_out_PointerTons__Metadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Metadata(struct soap *soap, const char *tag, int id, struct ns__Metadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Metadata);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Metadata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Metadata ** SOAP_FMAC4 soap_get_PointerTons__Metadata(struct soap *soap, struct ns__Metadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Metadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Metadata ** SOAP_FMAC4 soap_in_PointerTons__Metadata(struct soap *soap, const char *tag, struct ns__Metadata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Metadata **)soap_malloc(soap, sizeof(struct ns__Metadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Metadata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Metadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Metadata, sizeof(struct ns__Metadata), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__GPSLog(struct soap *soap, struct ns__GPSLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__GPSLog))
		soap_serialize_ns__GPSLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__GPSLog(struct soap *soap, struct ns__GPSLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__GPSLog);
	if (soap_out_PointerTons__GPSLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__GPSLog(struct soap *soap, const char *tag, int id, struct ns__GPSLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__GPSLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns__GPSLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__GPSLog ** SOAP_FMAC4 soap_get_PointerTons__GPSLog(struct soap *soap, struct ns__GPSLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__GPSLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__GPSLog ** SOAP_FMAC4 soap_in_PointerTons__GPSLog(struct soap *soap, const char *tag, struct ns__GPSLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__GPSLog **)soap_malloc(soap, sizeof(struct ns__GPSLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__GPSLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__GPSLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__GPSLog, sizeof(struct ns__GPSLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__AssociationRow(struct soap *soap, struct ns__AssociationRow *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__AssociationRow))
		soap_serialize_ns__AssociationRow(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__AssociationRow(struct soap *soap, struct ns__AssociationRow *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__AssociationRow);
	if (soap_out_PointerTons__AssociationRow(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__AssociationRow(struct soap *soap, const char *tag, int id, struct ns__AssociationRow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__AssociationRow);
	if (id < 0)
		return soap->error;
	return soap_out_ns__AssociationRow(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__AssociationRow ** SOAP_FMAC4 soap_get_PointerTons__AssociationRow(struct soap *soap, struct ns__AssociationRow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__AssociationRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AssociationRow ** SOAP_FMAC4 soap_in_PointerTons__AssociationRow(struct soap *soap, const char *tag, struct ns__AssociationRow **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__AssociationRow **)soap_malloc(soap, sizeof(struct ns__AssociationRow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__AssociationRow(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__AssociationRow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__AssociationRow, sizeof(struct ns__AssociationRow), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__AssociationChannel(struct soap *soap, struct ns__AssociationChannel *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__AssociationChannel))
		soap_serialize_ns__AssociationChannel(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__AssociationChannel(struct soap *soap, struct ns__AssociationChannel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__AssociationChannel);
	if (soap_out_PointerTons__AssociationChannel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__AssociationChannel(struct soap *soap, const char *tag, int id, struct ns__AssociationChannel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__AssociationChannel);
	if (id < 0)
		return soap->error;
	return soap_out_ns__AssociationChannel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__AssociationChannel ** SOAP_FMAC4 soap_get_PointerTons__AssociationChannel(struct soap *soap, struct ns__AssociationChannel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__AssociationChannel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__AssociationChannel ** SOAP_FMAC4 soap_in_PointerTons__AssociationChannel(struct soap *soap, const char *tag, struct ns__AssociationChannel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__AssociationChannel **)soap_malloc(soap, sizeof(struct ns__AssociationChannel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__AssociationChannel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__AssociationChannel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__AssociationChannel, sizeof(struct ns__AssociationChannel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Attribute(struct soap *soap, struct ns__Attribute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Attribute))
		soap_serialize_ns__Attribute(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Attribute(struct soap *soap, struct ns__Attribute *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Attribute);
	if (soap_out_PointerTons__Attribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Attribute(struct soap *soap, const char *tag, int id, struct ns__Attribute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Attribute);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Attribute(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Attribute ** SOAP_FMAC4 soap_get_PointerTons__Attribute(struct soap *soap, struct ns__Attribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Attribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Attribute ** SOAP_FMAC4 soap_in_PointerTons__Attribute(struct soap *soap, const char *tag, struct ns__Attribute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Attribute **)soap_malloc(soap, sizeof(struct ns__Attribute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Attribute(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Attribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Attribute, sizeof(struct ns__Attribute), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__SetOneParameterResult(struct soap *soap, struct ns__SetOneParameterResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__SetOneParameterResult))
		soap_serialize_ns__SetOneParameterResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__SetOneParameterResult(struct soap *soap, struct ns__SetOneParameterResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__SetOneParameterResult);
	if (soap_out_PointerTons__SetOneParameterResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__SetOneParameterResult(struct soap *soap, const char *tag, int id, struct ns__SetOneParameterResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__SetOneParameterResult);
	if (id < 0)
		return soap->error;
	return soap_out_ns__SetOneParameterResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__SetOneParameterResult ** SOAP_FMAC4 soap_get_PointerTons__SetOneParameterResult(struct soap *soap, struct ns__SetOneParameterResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__SetOneParameterResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__SetOneParameterResult ** SOAP_FMAC4 soap_in_PointerTons__SetOneParameterResult(struct soap *soap, const char *tag, struct ns__SetOneParameterResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__SetOneParameterResult **)soap_malloc(soap, sizeof(struct ns__SetOneParameterResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__SetOneParameterResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__SetOneParameterResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__SetOneParameterResult, sizeof(struct ns__SetOneParameterResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Parameter(struct soap *soap, struct ns__Parameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Parameter))
		soap_serialize_ns__Parameter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Parameter(struct soap *soap, struct ns__Parameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Parameter);
	if (soap_out_PointerTons__Parameter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Parameter(struct soap *soap, const char *tag, int id, struct ns__Parameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Parameter);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Parameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Parameter ** SOAP_FMAC4 soap_get_PointerTons__Parameter(struct soap *soap, struct ns__Parameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__Parameter ** SOAP_FMAC4 soap_in_PointerTons__Parameter(struct soap *soap, const char *tag, struct ns__Parameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Parameter **)soap_malloc(soap, sizeof(struct ns__Parameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Parameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Parameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Parameter, sizeof(struct ns__Parameter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__TaggedInputInfo(struct soap *soap, struct ns__TaggedInputInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__TaggedInputInfo))
		soap_serialize_ns__TaggedInputInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__TaggedInputInfo(struct soap *soap, struct ns__TaggedInputInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__TaggedInputInfo);
	if (soap_out_PointerTons__TaggedInputInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__TaggedInputInfo(struct soap *soap, const char *tag, int id, struct ns__TaggedInputInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__TaggedInputInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns__TaggedInputInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__TaggedInputInfo ** SOAP_FMAC4 soap_get_PointerTons__TaggedInputInfo(struct soap *soap, struct ns__TaggedInputInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__TaggedInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__TaggedInputInfo ** SOAP_FMAC4 soap_in_PointerTons__TaggedInputInfo(struct soap *soap, const char *tag, struct ns__TaggedInputInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__TaggedInputInfo **)soap_malloc(soap, sizeof(struct ns__TaggedInputInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__TaggedInputInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__TaggedInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__TaggedInputInfo, sizeof(struct ns__TaggedInputInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__TaggedBoardInfo(struct soap *soap, struct ns__TaggedBoardInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__TaggedBoardInfo))
		soap_serialize_ns__TaggedBoardInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__TaggedBoardInfo(struct soap *soap, struct ns__TaggedBoardInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__TaggedBoardInfo);
	if (soap_out_PointerTons__TaggedBoardInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__TaggedBoardInfo(struct soap *soap, const char *tag, int id, struct ns__TaggedBoardInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__TaggedBoardInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns__TaggedBoardInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__TaggedBoardInfo ** SOAP_FMAC4 soap_get_PointerTons__TaggedBoardInfo(struct soap *soap, struct ns__TaggedBoardInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__TaggedBoardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__TaggedBoardInfo ** SOAP_FMAC4 soap_in_PointerTons__TaggedBoardInfo(struct soap *soap, const char *tag, struct ns__TaggedBoardInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__TaggedBoardInfo **)soap_malloc(soap, sizeof(struct ns__TaggedBoardInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__TaggedBoardInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__TaggedBoardInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__TaggedBoardInfo, sizeof(struct ns__TaggedBoardInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__DummyResponse(struct soap *soap, struct ns__DummyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__DummyResponse))
		soap_serialize_ns__DummyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__DummyResponse(struct soap *soap, struct ns__DummyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__DummyResponse);
	if (soap_out_PointerTons__DummyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__DummyResponse(struct soap *soap, const char *tag, int id, struct ns__DummyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__DummyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns__DummyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__DummyResponse ** SOAP_FMAC4 soap_get_PointerTons__DummyResponse(struct soap *soap, struct ns__DummyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__DummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__DummyResponse ** SOAP_FMAC4 soap_in_PointerTons__DummyResponse(struct soap *soap, const char *tag, struct ns__DummyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__DummyResponse **)soap_malloc(soap, sizeof(struct ns__DummyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__DummyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__DummyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__DummyResponse, sizeof(struct ns__DummyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array16Ofns__BoardStatus(struct soap *soap, struct ns__BoardStatus a[16])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 16; i++)
	soap_default_ns__BoardStatus(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array16Ofns__BoardStatus(struct soap *soap, struct ns__BoardStatus const a[16])
{	int i;
	for(i = 0; i < 16; i++)
	{
	soap_serialize_ns__BoardStatus(soap, a+i);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array16Ofns__BoardStatus(struct soap *soap, struct ns__BoardStatus const a[16], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array16Ofns__BoardStatus);
	if (soap_out_Array16Ofns__BoardStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array16Ofns__BoardStatus(struct soap *soap, const char *tag, int id, struct ns__BoardStatus const a[16], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array16Ofns__BoardStatus), "ns:BoardStatus[16]", 0);
	for (i = 0; i < 16; i++)
	{
		soap_out_ns__BoardStatus(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__BoardStatus * SOAP_FMAC4 soap_get_Array16Ofns__BoardStatus(struct soap *soap, struct ns__BoardStatus a[16], const char *tag, const char *type)
{	struct ns__BoardStatus (*p);
	if ((p = soap_in_Array16Ofns__BoardStatus(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__BoardStatus * SOAP_FMAC4 soap_in_Array16Ofns__BoardStatus(struct soap *soap, const char *tag, struct ns__BoardStatus a[16], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__BoardStatus (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array16Ofns__BoardStatus, sizeof(struct ns__BoardStatus[16]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array16Ofns__BoardStatus(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 16; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 16)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_ns__BoardStatus(soap, NULL, a+i, "ns:BoardStatus"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (struct ns__BoardStatus (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array16Ofns__BoardStatus, sizeof(struct ns__BoardStatus[16]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array16Ofns__BoardStatus, 0, sizeof(struct ns__BoardStatus[16]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (struct ns__BoardStatus *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array8Ofns__InputStatus(struct soap *soap, struct ns__InputStatus a[8])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 8; i++)
	soap_default_ns__InputStatus(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array8Ofns__InputStatus(struct soap *soap, struct ns__InputStatus const a[8])
{	int i;
	for(i = 0; i < 8; i++)
	{
	soap_serialize_ns__InputStatus(soap, a+i);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array8Ofns__InputStatus(struct soap *soap, struct ns__InputStatus const a[8], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array8Ofns__InputStatus);
	if (soap_out_Array8Ofns__InputStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array8Ofns__InputStatus(struct soap *soap, const char *tag, int id, struct ns__InputStatus const a[8], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array8Ofns__InputStatus), "ns:InputStatus[8]", 0);
	for (i = 0; i < 8; i++)
	{
		soap_out_ns__InputStatus(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__InputStatus * SOAP_FMAC4 soap_get_Array8Ofns__InputStatus(struct soap *soap, struct ns__InputStatus a[8], const char *tag, const char *type)
{	struct ns__InputStatus (*p);
	if ((p = soap_in_Array8Ofns__InputStatus(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns__InputStatus * SOAP_FMAC4 soap_in_Array8Ofns__InputStatus(struct soap *soap, const char *tag, struct ns__InputStatus a[8], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__InputStatus (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array8Ofns__InputStatus, sizeof(struct ns__InputStatus[8]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array8Ofns__InputStatus(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 8; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 8)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_ns__InputStatus(soap, NULL, a+i, "ns:InputStatus"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (struct ns__InputStatus (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array8Ofns__InputStatus, sizeof(struct ns__InputStatus[8]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array8Ofns__InputStatus, 0, sizeof(struct ns__InputStatus[8]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (struct ns__InputStatus *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array128Ofbyte(struct soap *soap, char a[128])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 128; i++)
	soap_default_byte(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array128Ofbyte(struct soap *soap, char const a[128])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array128Ofbyte(struct soap *soap, char const a[128], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array128Ofbyte);
	if (soap_out_Array128Ofbyte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array128Ofbyte(struct soap *soap, const char *tag, int id, char const a[128], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array128Ofbyte), "xsd:byte[128]", 0);
	for (i = 0; i < 128; i++)
	{
		soap_out_byte(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_Array128Ofbyte(struct soap *soap, char a[128], const char *tag, const char *type)
{	char (*p);
	if ((p = soap_in_Array128Ofbyte(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_Array128Ofbyte(struct soap *soap, const char *tag, char a[128], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (char (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array128Ofbyte, sizeof(char[128]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array128Ofbyte(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 128; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 128)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_byte(soap, NULL, a+i, "xsd:byte"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (char (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array128Ofbyte, sizeof(char[128]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array128Ofbyte, 0, sizeof(char[128]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (char *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array8Ofbyte(struct soap *soap, char a[8])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 8; i++)
	soap_default_byte(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array8Ofbyte(struct soap *soap, char const a[8])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array8Ofbyte(struct soap *soap, char const a[8], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array8Ofbyte);
	if (soap_out_Array8Ofbyte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array8Ofbyte(struct soap *soap, const char *tag, int id, char const a[8], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array8Ofbyte), "xsd:byte[8]", 0);
	for (i = 0; i < 8; i++)
	{
		soap_out_byte(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_Array8Ofbyte(struct soap *soap, char a[8], const char *tag, const char *type)
{	char (*p);
	if ((p = soap_in_Array8Ofbyte(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_Array8Ofbyte(struct soap *soap, const char *tag, char a[8], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (char (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array8Ofbyte, sizeof(char[8]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array8Ofbyte(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 8; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 8)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_byte(soap, NULL, a+i, "xsd:byte"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (char (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array8Ofbyte, sizeof(char[8]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array8Ofbyte, 0, sizeof(char[8]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (char *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array16Ofbyte(struct soap *soap, char a[16])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 16; i++)
	soap_default_byte(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array16Ofbyte(struct soap *soap, char const a[16])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array16Ofbyte(struct soap *soap, char const a[16], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array16Ofbyte);
	if (soap_out_Array16Ofbyte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array16Ofbyte(struct soap *soap, const char *tag, int id, char const a[16], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array16Ofbyte), "xsd:byte[16]", 0);
	for (i = 0; i < 16; i++)
	{
		soap_out_byte(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_Array16Ofbyte(struct soap *soap, char a[16], const char *tag, const char *type)
{	char (*p);
	if ((p = soap_in_Array16Ofbyte(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_Array16Ofbyte(struct soap *soap, const char *tag, char a[16], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (char (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array16Ofbyte, sizeof(char[16]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array16Ofbyte(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 16; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 16)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_byte(soap, NULL, a+i, "xsd:byte"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (char (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array16Ofbyte, sizeof(char[16]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array16Ofbyte, 0, sizeof(char[16]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (char *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array12Ofint(struct soap *soap, int a[12])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 12; i++)
	soap_default_int(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array12Ofint(struct soap *soap, int const a[12])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array12Ofint(struct soap *soap, int const a[12], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array12Ofint);
	if (soap_out_Array12Ofint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array12Ofint(struct soap *soap, const char *tag, int id, int const a[12], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array12Ofint), "xsd:int[12]", 0);
	for (i = 0; i < 12; i++)
	{
		soap_out_int(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_Array12Ofint(struct soap *soap, int a[12], const char *tag, const char *type)
{	int (*p);
	if ((p = soap_in_Array12Ofint(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_Array12Ofint(struct soap *soap, const char *tag, int a[12], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (int (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array12Ofint, sizeof(int[12]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array12Ofint(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 12; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 12)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_int(soap, NULL, a+i, "xsd:int"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (int (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array12Ofint, sizeof(int[12]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array12Ofint, 0, sizeof(int[12]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (int *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array11Ofdouble(struct soap *soap, double a[11])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 11; i++)
	soap_default_double(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array11Ofdouble(struct soap *soap, double const a[11])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array11Ofdouble(struct soap *soap, double const a[11], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array11Ofdouble);
	if (soap_out_Array11Ofdouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array11Ofdouble(struct soap *soap, const char *tag, int id, double const a[11], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array11Ofdouble), "xsd:double[11]", 0);
	for (i = 0; i < 11; i++)
	{
		soap_out_double(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_Array11Ofdouble(struct soap *soap, double a[11], const char *tag, const char *type)
{	double (*p);
	if ((p = soap_in_Array11Ofdouble(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_Array11Ofdouble(struct soap *soap, const char *tag, double a[11], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (double (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array11Ofdouble, sizeof(double[11]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array11Ofdouble(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 11; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 11)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_double(soap, NULL, a+i, "xsd:double"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (double (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array11Ofdouble, sizeof(double[11]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array11Ofdouble, 0, sizeof(double[11]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (double *)a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array16Ofint(struct soap *soap, int a[16])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 16; i++)
	soap_default_int(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array16Ofint(struct soap *soap, int const a[16])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array16Ofint(struct soap *soap, int const a[16], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array16Ofint);
	if (soap_out_Array16Ofint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array16Ofint(struct soap *soap, const char *tag, int id, int const a[16], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array16Ofint), "xsd:int[16]", 0);
	for (i = 0; i < 16; i++)
	{
		soap_out_int(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_Array16Ofint(struct soap *soap, int a[16], const char *tag, const char *type)
{	int (*p);
	if ((p = soap_in_Array16Ofint(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_Array16Ofint(struct soap *soap, const char *tag, int a[16], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (int (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array16Ofint, sizeof(int[16]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array16Ofint(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 16; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 16)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_int(soap, NULL, a+i, "xsd:int"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (int (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array16Ofint, sizeof(int[16]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array16Ofint, 0, sizeof(int[16]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (int *)a;
}

/* End of soapC.cpp */
