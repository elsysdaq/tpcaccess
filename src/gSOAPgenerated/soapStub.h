/* soapStub.h
   Generated by gSOAP 2.7.12 from ..\gSoapInput\TpcServerSoap.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns__TpcConstants
#define SOAP_TYPE_ns__TpcConstants (8)
/* ns:TpcConstants */
enum ns__TpcConstants {ns__maxBoards = 16, ns__maxInputs = 8, ns__maxInputRanges = 11, ns__maxChargeInputRanges = 12};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns__DummyResponse
#define SOAP_TYPE_ns__DummyResponse (7)
/* ns:DummyResponse */
struct ns__DummyResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__DateTime
#define SOAP_TYPE_ns__DateTime (9)
/* ns:DateTime */
struct ns__DateTime
{
public:
	int year;	/* required element of type xsd:int */
	int month;	/* required element of type xsd:int */
	int day;	/* required element of type xsd:int */
	int hour;	/* required element of type xsd:int */
	int minute;	/* required element of type xsd:int */
	int second;	/* required element of type xsd:int */
	int milliSecond;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__GetInterfaceVersionResponse
#define SOAP_TYPE_ns__GetInterfaceVersionResponse (12)
/* ns:GetInterfaceVersionResponse */
struct ns__GetInterfaceVersionResponse
{
public:
	int version;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__GetInterfaceVersion
#define SOAP_TYPE_ns__GetInterfaceVersion (13)
/* ns:GetInterfaceVersion */
struct ns__GetInterfaceVersion
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__ResetConfiguration
#define SOAP_TYPE_ns__ResetConfiguration (16)
/* ns:ResetConfiguration */
struct ns__ResetConfiguration
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__AcquireDeviceLock
#define SOAP_TYPE_ns__AcquireDeviceLock (18)
/* ns:AcquireDeviceLock */
struct ns__AcquireDeviceLock
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__ReleaseDeviceLock
#define SOAP_TYPE_ns__ReleaseDeviceLock (20)
/* ns:ReleaseDeviceLock */
struct ns__ReleaseDeviceLock
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__ClusterConfiguration
#define SOAP_TYPE_ns__ClusterConfiguration (21)
/* ns:ClusterConfiguration */
struct ns__ClusterConfiguration
{
public:
	int clusterNumbers[16];	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type Array16Ofint */
};
#endif

#ifndef SOAP_TYPE_ns__GetClusterConfiguration
#define SOAP_TYPE_ns__GetClusterConfiguration (25)
/* ns:GetClusterConfiguration */
struct ns__GetClusterConfiguration
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__SetClusterConfiguration
#define SOAP_TYPE_ns__SetClusterConfiguration (27)
/* ns:SetClusterConfiguration */
struct ns__SetClusterConfiguration
{
public:
	struct ns__ClusterConfiguration clusters;	/* required element of type ns:ClusterConfiguration */
};
#endif

#ifndef SOAP_TYPE_ns__DeviceInfo
#define SOAP_TYPE_ns__DeviceInfo (28)
/* ns:DeviceInfo */
class SOAP_CMAC ns__DeviceInfo
{
public:
	ULONG64 deviceID;	/* required element of type xsd:unsignedLong */
	int serverSoftwareVersion;	/* required element of type xsd:int */
	bool simulatedHardware;	/* required element of type xsd:boolean */
	char *deviceName;	/* optional element of type xsd:string */
	char *DeviceDescription;	/* optional element of type xsd:string */
	bool UseLocalTime;	/* required element of type xsd:boolean */
	bool AutoStartMeasurement;	/* required element of type xsd:boolean */
	bool AutoStartAutosequence;	/* required element of type xsd:boolean */
	int ServerPort;	/* required element of type xsd:int */
	int ServerPortTwoinOne;	/* required element of type xsd:int */
	int TargetPort;	/* required element of type xsd:int */
	bool TwoInOne;	/* required element of type xsd:boolean */
	char *TwoInOnepassword;	/* optional element of type xsd:string */
	char *DataFileName;	/* optional element of type xsd:string */
	int NumberOfBackupFiles;	/* required element of type xsd:int */
	int HdFlushInterval;	/* required element of type xsd:int */
	bool WriteTroughCache;	/* required element of type xsd:boolean */
	int ModelType;	/* required element of type xsd:int */
	int SyncLinkDetected;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns__DeviceInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__DeviceInfo() : deviceID(0), serverSoftwareVersion(0), simulatedHardware((bool)0), deviceName(NULL), DeviceDescription(NULL), UseLocalTime((bool)0), AutoStartMeasurement((bool)0), AutoStartAutosequence((bool)0), ServerPort(0), ServerPortTwoinOne(0), TargetPort(0), TwoInOne((bool)0), TwoInOnepassword(NULL), DataFileName(NULL), NumberOfBackupFiles(0), HdFlushInterval(0), WriteTroughCache((bool)0), ModelType(0), SyncLinkDetected(0) { }
	virtual ~ns__DeviceInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns__BoardInfo
#define SOAP_TYPE_ns__BoardInfo (34)
/* ns:BoardInfo */
struct ns__BoardInfo
{
public:
	int boardClass;	/* required element of type xsd:int */
	int hardwareVersion;	/* required element of type xsd:int */
	int serialNr;	/* required element of type xsd:int */
	int driverVersion;	/* required element of type xsd:int */
	int firmwareVersion;	/* required element of type xsd:int */
	int numberOfInputs;	/* required element of type xsd:int */
	int maxMemory;	/* required element of type xsd:int */
	int maxSpeed;	/* required element of type xsd:int */
	int operationModeOptions;	/* required element of type xsd:int */
	int averageOptions;	/* required element of type xsd:int */
	int triggerOptions;	/* required element of type xsd:int */
	struct ns__DateTime lastFactoryCalibration;	/* required element of type ns:DateTime */
	struct ns__DateTime lastUserCalibration;	/* required element of type ns:DateTime */
	int maxAdcSpeed;	/* required element of type xsd:int */
	int boardClock;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__InputInfo
#define SOAP_TYPE_ns__InputInfo (35)
/* ns:InputInfo */
struct ns__InputInfo
{
public:
	int inputClass;	/* required element of type xsd:int */
	int hardwareVersion;	/* required element of type xsd:int */
	int maxAdcSpeed;	/* required element of type xsd:int */
	int adcResolution;	/* required element of type xsd:int */
	int offsetOptions;	/* required element of type xsd:int */
	int filterOptions;	/* required element of type xsd:int */
	int diffOptions;	/* required element of type xsd:int */
	int inputCouplingOptions;	/* required element of type xsd:int */
	double inputRanges[11];	/* required element of type Array11Ofdouble */
	int maxMarkerMask;	/* required element of type xsd:int */
	int chargeInputRanges[12];	/* required element of type Array12Ofint */
};
#endif

#ifndef SOAP_TYPE_ns__TaggedBoardInfo
#define SOAP_TYPE_ns__TaggedBoardInfo (39)
/* ns:TaggedBoardInfo */
struct ns__TaggedBoardInfo
{
public:
	int boardAddress;	/* required element of type xsd:int */
	struct ns__BoardInfo info;	/* required element of type ns:BoardInfo */
};
#endif

#ifndef SOAP_TYPE_ns__TaggedInputInfo
#define SOAP_TYPE_ns__TaggedInputInfo (40)
/* ns:TaggedInputInfo */
struct ns__TaggedInputInfo
{
public:
	int boardAddress;	/* required element of type xsd:int */
	int inputNumber;	/* required element of type xsd:int */
	struct ns__InputInfo info;	/* required element of type ns:InputInfo */
};
#endif

#ifndef SOAP_TYPE_ns__BoardInfoArray
#define SOAP_TYPE_ns__BoardInfoArray (41)
/* Sequence of ns:BoardInfoArray schema type: */
class SOAP_CMAC ns__BoardInfoArray
{
public:
	struct ns__TaggedBoardInfo *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns__BoardInfoArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__BoardInfoArray() : __ptr(NULL), __size(0) { }
	virtual ~ns__BoardInfoArray() { }
};
#endif

#ifndef SOAP_TYPE_ns__InputInfoArray
#define SOAP_TYPE_ns__InputInfoArray (43)
/* Sequence of ns:InputInfoArray schema type: */
class SOAP_CMAC ns__InputInfoArray
{
public:
	struct ns__TaggedInputInfo *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns__InputInfoArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__InputInfoArray() : __ptr(NULL), __size(0) { }
	virtual ~ns__InputInfoArray() { }
};
#endif

#ifndef SOAP_TYPE_ns__HardwareInfo
#define SOAP_TYPE_ns__HardwareInfo (45)
/* ns:HardwareInfo */
struct ns__HardwareInfo
{
public:
	ns__DeviceInfo device;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:DeviceInfo */
	ns__BoardInfoArray boards;	/* required element of type ns:BoardInfoArray */
	ns__InputInfoArray inputs;	/* required element of type ns:InputInfoArray */
};
#endif

#ifndef SOAP_TYPE_ns__GetHardwareInfo
#define SOAP_TYPE_ns__GetHardwareInfo (48)
/* ns:GetHardwareInfo */
struct ns__GetHardwareInfo
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__Parameter
#define SOAP_TYPE_ns__Parameter (49)
/* ns:Parameter */
struct ns__Parameter
{
public:
	int boardAddress;	/* required element of type xsd:int */
	int inputNumber;	/* required element of type xsd:int */
	int parameterIndex;	/* required element of type xsd:int */
	double value;	/* required element of type xsd:double */
};
#endif

#ifndef SOAP_TYPE_ns__ParameterList
#define SOAP_TYPE_ns__ParameterList (50)
/* Sequence of ns:ParameterList schema type: */
class SOAP_CMAC ns__ParameterList
{
public:
	struct ns__Parameter *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns__ParameterList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__ParameterList() : __ptr(NULL), __size(0) { }
	virtual ~ns__ParameterList() { }
};
#endif

#ifndef SOAP_TYPE_ns__SetOneParameterResult
#define SOAP_TYPE_ns__SetOneParameterResult (52)
/* ns:SetOneParameterResult */
struct ns__SetOneParameterResult
{
public:
	double roundedValue;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:double */
	int error;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__SetParameterResultList
#define SOAP_TYPE_ns__SetParameterResultList (53)
/* Sequence of ns:SetParameterResultList schema type: */
class SOAP_CMAC ns__SetParameterResultList
{
public:
	struct ns__SetOneParameterResult *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns__SetParameterResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__SetParameterResultList() : __ptr(NULL), __size(0) { }
	virtual ~ns__SetParameterResultList() { }
};
#endif

#ifndef SOAP_TYPE_ns__SetOneParameter
#define SOAP_TYPE_ns__SetOneParameter (57)
/* ns:SetOneParameter */
struct ns__SetOneParameter
{
public:
	int boardAddress;	/* required element of type xsd:int */
	int inputNumber;	/* required element of type xsd:int */
	int parameterIndex;	/* required element of type xsd:int */
	double value;	/* required element of type xsd:double */
};
#endif

#ifndef SOAP_TYPE_ns__SetMultipleParametersResponse
#define SOAP_TYPE_ns__SetMultipleParametersResponse (60)
/* ns:SetMultipleParametersResponse */
struct ns__SetMultipleParametersResponse
{
public:
	ns__SetParameterResultList result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:SetParameterResultList */
};
#endif

#ifndef SOAP_TYPE_ns__SetMultipleParameters
#define SOAP_TYPE_ns__SetMultipleParameters (61)
/* ns:SetMultipleParameters */
struct ns__SetMultipleParameters
{
public:
	ns__ParameterList parameters;	/* required element of type ns:ParameterList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllCurrentParametersResponse
#define SOAP_TYPE_ns__GetAllCurrentParametersResponse (64)
/* ns:GetAllCurrentParametersResponse */
struct ns__GetAllCurrentParametersResponse
{
public:
	ns__ParameterList parameters;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:ParameterList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllCurrentParameters
#define SOAP_TYPE_ns__GetAllCurrentParameters (65)
/* ns:GetAllCurrentParameters */
struct ns__GetAllCurrentParameters
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__GetAllPreviousParametersResponse
#define SOAP_TYPE_ns__GetAllPreviousParametersResponse (67)
/* ns:GetAllPreviousParametersResponse */
struct ns__GetAllPreviousParametersResponse
{
public:
	ns__ParameterList parameters;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:ParameterList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllPreviousParameters
#define SOAP_TYPE_ns__GetAllPreviousParameters (68)
/* ns:GetAllPreviousParameters */
struct ns__GetAllPreviousParameters
{
public:
	int currentMeasurementNumber;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__Attribute
#define SOAP_TYPE_ns__Attribute (69)
/* ns:Attribute */
struct ns__Attribute
{
public:
	unsigned int boardAddress;	/* required element of type xsd:unsignedInt */
	unsigned int inputNumber;	/* required element of type xsd:unsignedInt */
	char *name;	/* optional element of type xsd:string */
	char *value;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns__AttributeList
#define SOAP_TYPE_ns__AttributeList (70)
/* Sequence of ns:AttributeList schema type: */
class SOAP_CMAC ns__AttributeList
{
public:
	struct ns__Attribute *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns__AttributeList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__AttributeList() : __ptr(NULL), __size(0) { }
	virtual ~ns__AttributeList() { }
};
#endif

#ifndef SOAP_TYPE_ns__SetAttributes
#define SOAP_TYPE_ns__SetAttributes (73)
/* ns:SetAttributes */
struct ns__SetAttributes
{
public:
	ns__AttributeList values;	/* required element of type ns:AttributeList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllCurrentAttributesResponse
#define SOAP_TYPE_ns__GetAllCurrentAttributesResponse (76)
/* ns:GetAllCurrentAttributesResponse */
struct ns__GetAllCurrentAttributesResponse
{
public:
	ns__AttributeList result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:AttributeList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllCurrentAttributes
#define SOAP_TYPE_ns__GetAllCurrentAttributes (77)
/* ns:GetAllCurrentAttributes */
struct ns__GetAllCurrentAttributes
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__GetAllPreviousAttributesResponse
#define SOAP_TYPE_ns__GetAllPreviousAttributesResponse (79)
/* ns:GetAllPreviousAttributesResponse */
struct ns__GetAllPreviousAttributesResponse
{
public:
	ns__AttributeList result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:AttributeList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllPreviousAttributes
#define SOAP_TYPE_ns__GetAllPreviousAttributes (80)
/* ns:GetAllPreviousAttributes */
struct ns__GetAllPreviousAttributes
{
public:
	int currentMeasurementNumber;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__I2CTriggerSettings
#define SOAP_TYPE_ns__I2CTriggerSettings (81)
/* ns:I2CTriggerSettings */
struct ns__I2CTriggerSettings
{
public:
	int mode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	int chDataInputNumber;	/* required element of type xsd:int */
	int chDataInputSignal;	/* required element of type xsd:int */
	double chDataLevelL;	/* required element of type xsd:double */
	double chDataLevelH;	/* required element of type xsd:double */
	int chClockInputNumber;	/* required element of type xsd:int */
	int chClockInputSignal;	/* required element of type xsd:int */
	double chClockLevelL;	/* required element of type xsd:double */
	double chClockLevelH;	/* required element of type xsd:double */
	int ack;	/* required element of type xsd:int */
	int adrRWBit;	/* required element of type xsd:int */
	int adrType;	/* required element of type xsd:int */
	bool adrInRange;	/* required element of type xsd:boolean */
	int adrLow;	/* required element of type xsd:int */
	int adrHigh;	/* required element of type xsd:int */
	int adrMask;	/* required element of type xsd:int */
	int dataStartByte;	/* required element of type xsd:int */
	int dataLength;	/* required element of type xsd:int */
	bool dataInRange;	/* required element of type xsd:boolean */
	char dataLow[16];	/* required element of type Array16Ofbyte */
	char dataHigh[16];	/* required element of type Array16Ofbyte */
	char dataMask[16];	/* required element of type Array16Ofbyte */
};
#endif

#ifndef SOAP_TYPE_ns__CANTriggerSettings
#define SOAP_TYPE_ns__CANTriggerSettings (83)
/* ns:CANTriggerSettings */
struct ns__CANTriggerSettings
{
public:
	int mode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	int chDataInputNumber;	/* required element of type xsd:int */
	int chDataInputSignal;	/* required element of type xsd:int */
	double chDataLevelL;	/* required element of type xsd:double */
	double chDataLevelH;	/* required element of type xsd:double */
	int bitRate;	/* required element of type xsd:int */
	double bitSamplePoint;	/* required element of type xsd:double */
	int idFormat;	/* required element of type xsd:int */
	bool idInRange;	/* required element of type xsd:boolean */
	int idLow;	/* required element of type xsd:int */
	int idHigh;	/* required element of type xsd:int */
	int idMask;	/* required element of type xsd:int */
	int dataLength;	/* required element of type xsd:int */
	bool dataInRange;	/* required element of type xsd:boolean */
	char dataLow[8];	/* required element of type Array8Ofbyte */
	char dataHigh[8];	/* required element of type Array8Ofbyte */
	char dataMask[8];	/* required element of type Array8Ofbyte */
};
#endif

#ifndef SOAP_TYPE_ns__GetSerTrgProtocolResponse
#define SOAP_TYPE_ns__GetSerTrgProtocolResponse (86)
/* ns:GetSerTrgProtocolResponse */
struct ns__GetSerTrgProtocolResponse
{
public:
	int prot;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__GetSerTrgProtocol
#define SOAP_TYPE_ns__GetSerTrgProtocol (87)
/* ns:GetSerTrgProtocol */
struct ns__GetSerTrgProtocol
{
public:
	int boardAddress;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__ResetSerTrg
#define SOAP_TYPE_ns__ResetSerTrg (89)
/* ns:ResetSerTrg */
struct ns__ResetSerTrg
{
public:
	int boardAddress;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__SetI2CTrigger
#define SOAP_TYPE_ns__SetI2CTrigger (91)
/* ns:SetI2CTrigger */
struct ns__SetI2CTrigger
{
public:
	int boardAddress;	/* required element of type xsd:int */
	struct ns__I2CTriggerSettings settings;	/* required element of type ns:I2CTriggerSettings */
};
#endif

#ifndef SOAP_TYPE_ns__GetI2CTrigger
#define SOAP_TYPE_ns__GetI2CTrigger (94)
/* ns:GetI2CTrigger */
struct ns__GetI2CTrigger
{
public:
	int boardAddress;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__SetCANTrigger
#define SOAP_TYPE_ns__SetCANTrigger (96)
/* ns:SetCANTrigger */
struct ns__SetCANTrigger
{
public:
	int boardAddress;	/* required element of type xsd:int */
	struct ns__CANTriggerSettings settings;	/* required element of type ns:CANTriggerSettings */
};
#endif

#ifndef SOAP_TYPE_ns__GetCANTrigger
#define SOAP_TYPE_ns__GetCANTrigger (99)
/* ns:GetCANTrigger */
struct ns__GetCANTrigger
{
public:
	int boardAddress;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__AssociationChannel
#define SOAP_TYPE_ns__AssociationChannel (100)
/* ns:AssociationChannel */
struct ns__AssociationChannel
{
public:
	unsigned int boardAddress;	/* required element of type xsd:unsignedInt */
	unsigned int inputNumber;	/* required element of type xsd:unsignedInt */
};
#endif

#ifndef SOAP_TYPE_ns__AssociationChannelList
#define SOAP_TYPE_ns__AssociationChannelList (101)
/* Sequence of ns:AssociationChannelList schema type: */
struct ns__AssociationChannelList
{
public:
	struct ns__AssociationChannel *__ptr;
	int __size;
};
#endif

#ifndef SOAP_TYPE_ns__AssociationRow
#define SOAP_TYPE_ns__AssociationRow (103)
/* ns:AssociationRow */
struct ns__AssociationRow
{
public:
	unsigned int boardAddress;	/* required element of type xsd:unsignedInt */
	unsigned int inputNumber;	/* required element of type xsd:unsignedInt */
	struct ns__AssociationChannelList associatedChannels;	/* required element of type ns:AssociationChannelList */
};
#endif

#ifndef SOAP_TYPE_ns__AssociationRowList
#define SOAP_TYPE_ns__AssociationRowList (104)
/* Sequence of ns:AssociationRowList schema type: */
struct ns__AssociationRowList
{
public:
	struct ns__AssociationRow *__ptr;
	int __size;
};
#endif

#ifndef SOAP_TYPE_ns__GetAllCurrentAssociationsResponse
#define SOAP_TYPE_ns__GetAllCurrentAssociationsResponse (108)
/* ns:GetAllCurrentAssociationsResponse */
struct ns__GetAllCurrentAssociationsResponse
{
public:
	struct ns__AssociationRowList result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:AssociationRowList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllCurrentAssociations
#define SOAP_TYPE_ns__GetAllCurrentAssociations (109)
/* ns:GetAllCurrentAssociations */
struct ns__GetAllCurrentAssociations
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__GetAllPreviousAssociationsResponse
#define SOAP_TYPE_ns__GetAllPreviousAssociationsResponse (111)
/* ns:GetAllPreviousAssociationsResponse */
struct ns__GetAllPreviousAssociationsResponse
{
public:
	struct ns__AssociationRowList result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:AssociationRowList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllPreviousAssociations
#define SOAP_TYPE_ns__GetAllPreviousAssociations (112)
/* ns:GetAllPreviousAssociations */
struct ns__GetAllPreviousAssociations
{
public:
	int currentMeasurementNumber;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__SetAssociations
#define SOAP_TYPE_ns__SetAssociations (114)
/* ns:SetAssociations */
struct ns__SetAssociations
{
public:
	struct ns__AssociationRowList associations;	/* required element of type ns:AssociationRowList */
};
#endif

#ifndef SOAP_TYPE_ns__GPSLog
#define SOAP_TYPE_ns__GPSLog (115)
/* ns:GPSLog */
struct ns__GPSLog
{
public:
	char GPSFrame[128];	/* required element of type Array128Ofbyte */
};
#endif

#ifndef SOAP_TYPE_ns__GPSLogList
#define SOAP_TYPE_ns__GPSLogList (117)
/* Sequence of ns:GPSLogList schema type: */
struct ns__GPSLogList
{
public:
	struct ns__GPSLog *__ptr;
	int __size;
};
#endif

#ifndef SOAP_TYPE_ns__GetGPSLogListResponse
#define SOAP_TYPE_ns__GetGPSLogListResponse (121)
/* ns:GetGPSLogListResponse */
struct ns__GetGPSLogListResponse
{
public:
	struct ns__GPSLogList result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:GPSLogList */
};
#endif

#ifndef SOAP_TYPE_ns__GetGPSLogList
#define SOAP_TYPE_ns__GetGPSLogList (122)
/* ns:GetGPSLogList */
struct ns__GetGPSLogList
{
public:
	int from;	/* required element of type xsd:int */
	int to;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__DeviceData
#define SOAP_TYPE_ns__DeviceData (123)
/* Base64 schema type: */
class SOAP_CMAC ns__DeviceData
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_ns__DeviceData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__DeviceData() : __ptr(NULL), __size(0) { }
	virtual ~ns__DeviceData() { }
};
#endif

#ifndef SOAP_TYPE_ns__WriteDev
#define SOAP_TYPE_ns__WriteDev (127)
/* ns:WriteDev */
struct ns__WriteDev
{
public:
	int boardAddress;	/* required element of type xsd:int */
	int type;	/* required element of type xsd:int */
	ns__DeviceData data;	/* required element of type ns:DeviceData */
	unsigned int aux1;	/* required element of type xsd:unsignedInt */
	unsigned int aux2;	/* required element of type xsd:unsignedInt */
};
#endif

#ifndef SOAP_TYPE_ns__ReadDevResponse
#define SOAP_TYPE_ns__ReadDevResponse (130)
/* ns:ReadDevResponse */
struct ns__ReadDevResponse
{
public:
	ns__DeviceData result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:DeviceData */
};
#endif

#ifndef SOAP_TYPE_ns__ReadDev
#define SOAP_TYPE_ns__ReadDev (131)
/* ns:ReadDev */
struct ns__ReadDev
{
public:
	int boardAddress;	/* required element of type xsd:int */
	int type;	/* required element of type xsd:int */
	unsigned int count;	/* required element of type xsd:unsignedInt */
	unsigned int aux1;	/* required element of type xsd:unsignedInt */
	unsigned int aux2;	/* required element of type xsd:unsignedInt */
};
#endif

#ifndef SOAP_TYPE_ns__ReadWriteTwiResponse
#define SOAP_TYPE_ns__ReadWriteTwiResponse (133)
/* ns:ReadWriteTwiResponse */
struct ns__ReadWriteTwiResponse
{
public:
	ns__DeviceData result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:DeviceData */
};
#endif

#ifndef SOAP_TYPE_ns__ReadWriteTwi
#define SOAP_TYPE_ns__ReadWriteTwi (134)
/* ns:ReadWriteTwi */
struct ns__ReadWriteTwi
{
public:
	int boardAddress;	/* required element of type xsd:int */
	unsigned int amplifier;	/* required element of type xsd:unsignedInt */
	ns__DeviceData data;	/* required element of type ns:DeviceData */
};
#endif

#ifndef SOAP_TYPE_ns__PrepareStartResponse
#define SOAP_TYPE_ns__PrepareStartResponse (137)
/* ns:PrepareStartResponse */
struct ns__PrepareStartResponse
{
public:
	double *delayTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:double */
};
#endif

#ifndef SOAP_TYPE_ns__PrepareStart
#define SOAP_TYPE_ns__PrepareStart (138)
/* ns:PrepareStart */
struct ns__PrepareStart
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__SetStartInfo
#define SOAP_TYPE_ns__SetStartInfo (140)
/* ns:SetStartInfo */
struct ns__SetStartInfo
{
public:
	struct ns__DateTime startTime;	/* required element of type ns:DateTime */
	int measurementNr;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__ExecuteCommand
#define SOAP_TYPE_ns__ExecuteCommand (142)
/* ns:ExecuteCommand */
struct ns__ExecuteCommand
{
public:
	int command;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__StartCalibration
#define SOAP_TYPE_ns__StartCalibration (144)
/* ns:StartCalibration */
struct ns__StartCalibration
{
public:
	int type;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__InputStatus
#define SOAP_TYPE_ns__InputStatus (145)
/* ns:InputStatus */
struct ns__InputStatus
{
public:
	int OverloadLive;	/* required element of type xsd:int */
	int OverloadMeas;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__BoardStatus
#define SOAP_TYPE_ns__BoardStatus (146)
/* ns:BoardStatus */
struct ns__BoardStatus
{
public:
	int recordingState;	/* required element of type xsd:int */
	int triggerState;	/* required element of type xsd:int */
	int blockCounter;	/* required element of type xsd:int */
	LONG64 dataCounter;	/* required element of type xsd:long */
	int dataLostCounter;	/* required element of type xsd:int */
	int blockLostCounter;	/* required element of type xsd:int */
	struct ns__InputStatus inputs[8];	/* required element of type Array8Ofns__InputStatus */
};
#endif

#ifndef SOAP_TYPE_ns__GPSStatus
#define SOAP_TYPE_ns__GPSStatus (148)
/* ns:GPSStatus */
struct ns__GPSStatus
{
public:
	bool locked;	/* required element of type xsd:boolean */
	int NrOfSatVisible;	/* required element of type xsd:int */
	char gpsTime[128];	/* required element of type Array128Ofbyte */
	char lastFrame[128];	/* required element of type Array128Ofbyte */
	int nrOfloggedPositions;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__TempStatus
#define SOAP_TYPE_ns__TempStatus (149)
/* ns:TempStatus */
struct ns__TempStatus
{
public:
	int CPUTemp;	/* required element of type xsd:int */
	int BoardTemp[16];	/* required element of type Array16Ofint */
	int Res1Temp;	/* required element of type xsd:int */
	int Res2Temp;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__DeviceStatus
#define SOAP_TYPE_ns__DeviceStatus (150)
/* ns:DeviceStatus */
struct ns__DeviceStatus
{
public:
	int deviceError;	/* required element of type xsd:int */
	struct ns__BoardStatus boards[16];	/* required element of type Array16Ofns__BoardStatus */
	int settingsChangesCounter;	/* required element of type xsd:int */
	struct ns__DateTime startTime;	/* required element of type ns:DateTime */
	int measurementNumber;	/* required element of type xsd:int */
	bool startInProgress;	/* required element of type xsd:boolean */
	int autosequenceState;	/* required element of type xsd:int */
	int extStartState;	/* required element of type xsd:int */
	struct ns__GPSStatus gpsStatus;	/* required element of type ns:GPSStatus */
	struct ns__TempStatus tempStatus;	/* required element of type ns:TempStatus */
};
#endif

#ifndef SOAP_TYPE_ns__Status
#define SOAP_TYPE_ns__Status (152)
/* ns:Status */
struct ns__Status
{
public:
	unsigned int eventCounter;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedInt */
	struct ns__DeviceStatus status;	/* required element of type ns:DeviceStatus */
	struct ns__ClusterConfiguration clusters;	/* required element of type ns:ClusterConfiguration */
};
#endif

#ifndef SOAP_TYPE_ns__GetStatus
#define SOAP_TYPE_ns__GetStatus (155)
/* ns:GetStatus */
struct ns__GetStatus
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__WaitForStatusChange
#define SOAP_TYPE_ns__WaitForStatusChange (157)
/* ns:WaitForStatusChange */
struct ns__WaitForStatusChange
{
public:
	unsigned int eventCounter;	/* required element of type xsd:unsignedInt */
};
#endif

#ifndef SOAP_TYPE_ns__LeaveWaitStatus
#define SOAP_TYPE_ns__LeaveWaitStatus (159)
/* ns:LeaveWaitStatus */
struct ns__LeaveWaitStatus
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__Metadata
#define SOAP_TYPE_ns__Metadata (160)
/* ns:Metadata */
struct ns__Metadata
{
public:
	ULONG64 triggerTime;	/* required element of type xsd:unsignedLong */
	ULONG64 triggerSample;	/* required element of type xsd:unsignedLong */
	ULONG64 blockLength;	/* required element of type xsd:unsignedLong */
	ULONG64 stopTriggerSample;	/* required element of type xsd:unsignedLong */
	int boardAddress;	/* required element of type xsd:int */
	int inputNumber;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__MetadataList
#define SOAP_TYPE_ns__MetadataList (161)
/* Sequence of ns:MetadataList schema type: */
class SOAP_CMAC ns__MetadataList
{
public:
	struct ns__Metadata *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE_ns__MetadataList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__MetadataList() : __ptr(NULL), __size(0) { }
	virtual ~ns__MetadataList() { }
};
#endif

#ifndef SOAP_TYPE_ns__GetMetadataResponse
#define SOAP_TYPE_ns__GetMetadataResponse (165)
/* ns:GetMetadataResponse */
struct ns__GetMetadataResponse
{
public:
	ns__MetadataList metadata;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:MetadataList */
};
#endif

#ifndef SOAP_TYPE_ns__GetMetadata
#define SOAP_TYPE_ns__GetMetadata (166)
/* ns:GetMetadata */
struct ns__GetMetadata
{
public:
	int currentMeasurementNumber;	/* required element of type xsd:int */
	int boardAddress;	/* required element of type xsd:int */
	int blockFrom;	/* required element of type xsd:int */
	int blockTo;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__YMetadata
#define SOAP_TYPE_ns__YMetadata (167)
/* ns:YMetadata */
struct ns__YMetadata
{
public:
	int boardAddress;	/* required element of type xsd:int */
	int inputNumber;	/* required element of type xsd:int */
	bool isActive;	/* required element of type xsd:boolean */
	int resolutionInBits;	/* required element of type xsd:int */
	unsigned int analogMask;	/* required element of type xsd:unsignedInt */
	unsigned int markerMask;	/* required element of type xsd:unsignedInt */
	int numberOfMarkerBits;	/* required element of type xsd:int */
	int bytesPerSample;	/* required element of type xsd:int */
	double binToVoltFactor;	/* required element of type xsd:double */
	double binToVoltConst;	/* required element of type xsd:double */
	double voltToPhysicalFactor;	/* required element of type xsd:double */
	double voltToPhysicalConstant;	/* required element of type xsd:double */
};
#endif

#ifndef SOAP_TYPE_ns__YMetadataList
#define SOAP_TYPE_ns__YMetadataList (168)
/* Sequence of ns:YMetadataList schema type: */
class SOAP_CMAC ns__YMetadataList
{
public:
	struct ns__YMetadata *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE_ns__YMetadataList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__YMetadataList() : __ptr(NULL), __size(0) { }
	virtual ~ns__YMetadataList() { }
};
#endif

#ifndef SOAP_TYPE_ns__GetAllYMetadataResponse
#define SOAP_TYPE_ns__GetAllYMetadataResponse (172)
/* ns:GetAllYMetadataResponse */
struct ns__GetAllYMetadataResponse
{
public:
	ns__YMetadataList metadata;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:YMetadataList */
};
#endif

#ifndef SOAP_TYPE_ns__GetAllYMetadata
#define SOAP_TYPE_ns__GetAllYMetadata (173)
/* ns:GetAllYMetadata */
struct ns__GetAllYMetadata
{
public:
	int currentMeasurementNumber;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns__DataSpecification
#define SOAP_TYPE_ns__DataSpecification (174)
/* ns:DataSpecification */
class SOAP_CMAC ns__DataSpecification
{
public:
	unsigned int boardAddress;	/* required element of type xsd:unsignedInt */
	unsigned int inputNumber;	/* required element of type xsd:unsignedInt */
	unsigned int blockNumber;	/* required element of type xsd:unsignedInt */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE_ns__DataSpecification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__DataSpecification() : boardAddress(0), inputNumber(0), blockNumber(0) { }
	virtual ~ns__DataSpecification() { }
};
#endif

#ifndef SOAP_TYPE_ns__RangeDataSpecification
#define SOAP_TYPE_ns__RangeDataSpecification (175)
/* ns:RangeDataSpecification */
class SOAP_CMAC ns__RangeDataSpecification : public ns__DataSpecification
{
public:
	int readoutType;	/* required element of type xsd:int */
	ULONG64 dataStart;	/* required element of type xsd:unsignedLong */
	ULONG64 dataLength;	/* required element of type xsd:unsignedLong */
	unsigned int resultLength;	/* required element of type xsd:unsignedInt */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE_ns__RangeDataSpecification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__RangeDataSpecification() : readoutType(0), dataStart(0), dataLength(0), resultLength(0) { }
	virtual ~ns__RangeDataSpecification() { }
};
#endif

#ifndef SOAP_TYPE_ns__IndexList
#define SOAP_TYPE_ns__IndexList (176)
/* Sequence of ns:IndexList schema type: */
class SOAP_CMAC ns__IndexList
{
public:
	ULONG64 *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE_ns__IndexList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__IndexList() : __ptr(NULL), __size(0) { }
	virtual ~ns__IndexList() { }
};
#endif

#ifndef SOAP_TYPE_ns__EnvelopeDataSpecification
#define SOAP_TYPE_ns__EnvelopeDataSpecification (178)
/* ns:EnvelopeDataSpecification */
class SOAP_CMAC ns__EnvelopeDataSpecification : public ns__DataSpecification
{
public:
	ns__IndexList indices;	/* required element of type ns:IndexList */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE_ns__EnvelopeDataSpecification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__EnvelopeDataSpecification()  { }
	virtual ~ns__EnvelopeDataSpecification() { }
};
#endif

#ifndef SOAP_TYPE_ns__DataSpecificationArray
#define SOAP_TYPE_ns__DataSpecificationArray (179)
/* Sequence of ns:DataSpecificationArray schema type: */
class SOAP_CMAC ns__DataSpecificationArray
{
public:
	ns__DataSpecification **__ptr;
	int __size;
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE_ns__DataSpecificationArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__DataSpecificationArray() : __ptr(NULL), __size(0) { }
	virtual ~ns__DataSpecificationArray() { }
};
#endif

#ifndef SOAP_TYPE_ns__Data
#define SOAP_TYPE_ns__Data (182)
/* Base64 schema type: */
class SOAP_CMAC ns__Data
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	ns__Data();	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE_ns__Data */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~ns__Data() { }
};
#endif

#ifndef SOAP_TYPE_ns__GetDataResponse
#define SOAP_TYPE_ns__GetDataResponse (188)
/* ns:GetDataResponse */
struct ns__GetDataResponse
{
public:
	ns__Data data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:Data */
};
#endif

#ifndef SOAP_TYPE_ns__GetData
#define SOAP_TYPE_ns__GetData (189)
/* ns:GetData */
struct ns__GetData
{
public:
	int currentMeasurementNumber;	/* required element of type xsd:int */
	ns__DataSpecificationArray requests;	/* required element of type ns:DataSpecificationArray */
};
#endif

#ifndef SOAP_TYPE_ns__DataBlockHeader
#define SOAP_TYPE_ns__DataBlockHeader (190)
/* ns:DataBlockHeader */
struct ns__DataBlockHeader
{
public:
	int error;	/* required element of type xsd:int */
	unsigned int numberOfSamples;	/* required element of type xsd:unsignedInt */
	int sampleFormat;	/* required element of type xsd:int */
	unsigned int totalBytes;	/* required element of type xsd:unsignedInt */
};
#endif

#ifndef SOAP_TYPE_ns__SendServerCustomCommandResponse
#define SOAP_TYPE_ns__SendServerCustomCommandResponse (193)
/* ns:SendServerCustomCommandResponse */
struct ns__SendServerCustomCommandResponse
{
public:
	char **result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns__SendServerCustomCommand
#define SOAP_TYPE_ns__SendServerCustomCommand (194)
/* ns:SendServerCustomCommand */
struct ns__SendServerCustomCommand
{
public:
	char *command;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns__AutoSequence
#define SOAP_TYPE_ns__AutoSequence (195)
/* Sequence of ns:AutoSequence schema type: */
class SOAP_CMAC ns__AutoSequence
{
public:
	char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_ns__AutoSequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__AutoSequence() : __ptr(NULL), __size(0) { }
	virtual ~ns__AutoSequence() { }
};
#endif

#ifndef SOAP_TYPE_ns__LoadAutosequenceResponse
#define SOAP_TYPE_ns__LoadAutosequenceResponse (197)
/* ns:LoadAutosequenceResponse */
struct ns__LoadAutosequenceResponse
{
public:
	char **result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns__LoadAutosequence
#define SOAP_TYPE_ns__LoadAutosequence (198)
/* ns:LoadAutosequence */
struct ns__LoadAutosequence
{
public:
	ns__AutoSequence Sequence;	/* required element of type ns:AutoSequence */
};
#endif

#ifndef SOAP_TYPE_ns__StartAutoSequenceResponse
#define SOAP_TYPE_ns__StartAutoSequenceResponse (200)
/* ns:StartAutoSequenceResponse */
struct ns__StartAutoSequenceResponse
{
public:
	char **result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns__StartAutoSequence
#define SOAP_TYPE_ns__StartAutoSequence (201)
/* ns:StartAutoSequence */
struct ns__StartAutoSequence
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__StopAutoSequenceResponse
#define SOAP_TYPE_ns__StopAutoSequenceResponse (203)
/* ns:StopAutoSequenceResponse */
struct ns__StopAutoSequenceResponse
{
public:
	char **result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns__StopAutoSequence
#define SOAP_TYPE_ns__StopAutoSequence (204)
/* ns:StopAutoSequence */
struct ns__StopAutoSequence
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__GetAutoSequenceResponse
#define SOAP_TYPE_ns__GetAutoSequenceResponse (207)
/* ns:GetAutoSequenceResponse */
struct ns__GetAutoSequenceResponse
{
public:
	ns__AutoSequence result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:AutoSequence */
};
#endif

#ifndef SOAP_TYPE_ns__GetAutoSequence
#define SOAP_TYPE_ns__GetAutoSequence (208)
/* ns:GetAutoSequence */
struct ns__GetAutoSequence
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__SetDeviceSettings
#define SOAP_TYPE_ns__SetDeviceSettings (210)
/* ns:SetDeviceSettings */
struct ns__SetDeviceSettings
{
public:
	ns__DeviceInfo Settings;	/* required element of type ns:DeviceInfo */
};
#endif

#ifndef SOAP_TYPE_ns__DiskSpace
#define SOAP_TYPE_ns__DiskSpace (211)
/* ns:DiskSpace */
class SOAP_CMAC ns__DiskSpace
{
public:
	ULONG64 freeDiskSpace;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedLong */
	ULONG64 DiskSize;	/* required element of type xsd:unsignedLong */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_ns__DiskSpace */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns__DiskSpace() : freeDiskSpace(0), DiskSize(0) { }
	virtual ~ns__DiskSpace() { }
};
#endif

#ifndef SOAP_TYPE_ns__GetFreeDiskSpace
#define SOAP_TYPE_ns__GetFreeDiskSpace (214)
/* ns:GetFreeDiskSpace */
struct ns__GetFreeDiskSpace
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns__GetMACAddressResponse
#define SOAP_TYPE_ns__GetMACAddressResponse (217)
/* ns:GetMACAddressResponse */
struct ns__GetMACAddressResponse
{
public:
	ULONG64 MACAddress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedLong */
};
#endif

#ifndef SOAP_TYPE_ns__GetMACAddress
#define SOAP_TYPE_ns__GetMACAddress (218)
/* ns:GetMACAddress */
struct ns__GetMACAddress
{
public:
	char *IPAddress;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (219)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (220)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (222)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (224)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (225)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operations                                                         *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 ns__GetInterfaceVersion(struct soap*, int &version);

SOAP_FMAC5 int SOAP_FMAC6 ns__ResetConfiguration(struct soap*, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__AcquireDeviceLock(struct soap*, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__ReleaseDeviceLock(struct soap*, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetClusterConfiguration(struct soap*, struct ns__ClusterConfiguration &clusters);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetClusterConfiguration(struct soap*, struct ns__ClusterConfiguration clusters, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetHardwareInfo(struct soap*, struct ns__HardwareInfo &hardwareInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetOneParameter(struct soap*, int boardAddress, int inputNumber, int parameterIndex, double value, struct ns__SetOneParameterResult &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetMultipleParameters(struct soap*, ns__ParameterList parameters, ns__SetParameterResultList &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllCurrentParameters(struct soap*, ns__ParameterList &parameters);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllPreviousParameters(struct soap*, int currentMeasurementNumber, ns__ParameterList &parameters);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetAttributes(struct soap*, ns__AttributeList values, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllCurrentAttributes(struct soap*, ns__AttributeList &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllPreviousAttributes(struct soap*, int currentMeasurementNumber, ns__AttributeList &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetSerTrgProtocol(struct soap*, int boardAddress, int &prot);

SOAP_FMAC5 int SOAP_FMAC6 ns__ResetSerTrg(struct soap*, int boardAddress, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetI2CTrigger(struct soap*, int boardAddress, struct ns__I2CTriggerSettings settings, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetI2CTrigger(struct soap*, int boardAddress, struct ns__I2CTriggerSettings &settings);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetCANTrigger(struct soap*, int boardAddress, struct ns__CANTriggerSettings settings, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetCANTrigger(struct soap*, int boardAddress, struct ns__CANTriggerSettings &settings);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllCurrentAssociations(struct soap*, struct ns__AssociationRowList &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllPreviousAssociations(struct soap*, int currentMeasurementNumber, struct ns__AssociationRowList &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetAssociations(struct soap*, struct ns__AssociationRowList associations, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetGPSLogList(struct soap*, int from, int to, struct ns__GPSLogList &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__WriteDev(struct soap*, int boardAddress, int type, ns__DeviceData data, unsigned int aux1, unsigned int aux2, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__ReadDev(struct soap*, int boardAddress, int type, unsigned int count, unsigned int aux1, unsigned int aux2, ns__DeviceData &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__ReadWriteTwi(struct soap*, int boardAddress, unsigned int amplifier, ns__DeviceData data, ns__DeviceData &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__PrepareStart(struct soap*, double *delayTime);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetStartInfo(struct soap*, struct ns__DateTime startTime, int measurementNr, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__ExecuteCommand(struct soap*, int command, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__StartCalibration(struct soap*, int type, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetStatus(struct soap*, struct ns__Status &status);

SOAP_FMAC5 int SOAP_FMAC6 ns__WaitForStatusChange(struct soap*, unsigned int eventCounter, struct ns__Status &status);

SOAP_FMAC5 int SOAP_FMAC6 ns__LeaveWaitStatus(struct soap*, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetMetadata(struct soap*, int currentMeasurementNumber, int boardAddress, int blockFrom, int blockTo, ns__MetadataList &metadata);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllYMetadata(struct soap*, int currentMeasurementNumber, ns__YMetadataList &metadata);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetData(struct soap*, int currentMeasurementNumber, ns__DataSpecificationArray requests, ns__Data &data);

SOAP_FMAC5 int SOAP_FMAC6 ns__SendServerCustomCommand(struct soap*, char *command, char **result);

SOAP_FMAC5 int SOAP_FMAC6 ns__LoadAutosequence(struct soap*, ns__AutoSequence Sequence, char **result);

SOAP_FMAC5 int SOAP_FMAC6 ns__StartAutoSequence(struct soap*, char **result);

SOAP_FMAC5 int SOAP_FMAC6 ns__StopAutoSequence(struct soap*, char **result);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAutoSequence(struct soap*, ns__AutoSequence &result);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetDeviceSettings(struct soap*, ns__DeviceInfo Settings, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetFreeDiskSpace(struct soap*, ns__DiskSpace &DiskSpace);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetMACAddress(struct soap*, char *IPAddress, ULONG64 &MACAddress);

/******************************************************************************\
 *                                                                            *
 * Stubs                                                                      *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetInterfaceVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, int &version);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ResetConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__AcquireDeviceLock(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ReleaseDeviceLock(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetClusterConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__ClusterConfiguration &clusters);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetClusterConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__ClusterConfiguration clusters, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetHardwareInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__HardwareInfo &hardwareInfo);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetOneParameter(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, int inputNumber, int parameterIndex, double value, struct ns__SetOneParameterResult &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetMultipleParameters(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__ParameterList parameters, ns__SetParameterResultList &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllCurrentParameters(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__ParameterList &parameters);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllPreviousParameters(struct soap *soap, const char *soap_endpoint, const char *soap_action, int currentMeasurementNumber, ns__ParameterList &parameters);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetAttributes(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__AttributeList values, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllCurrentAttributes(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__AttributeList &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllPreviousAttributes(struct soap *soap, const char *soap_endpoint, const char *soap_action, int currentMeasurementNumber, ns__AttributeList &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetSerTrgProtocol(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, int &prot);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ResetSerTrg(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetI2CTrigger(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, struct ns__I2CTriggerSettings settings, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetI2CTrigger(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, struct ns__I2CTriggerSettings &settings);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetCANTrigger(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, struct ns__CANTriggerSettings settings, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetCANTrigger(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, struct ns__CANTriggerSettings &settings);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllCurrentAssociations(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__AssociationRowList &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllPreviousAssociations(struct soap *soap, const char *soap_endpoint, const char *soap_action, int currentMeasurementNumber, struct ns__AssociationRowList &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetAssociations(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__AssociationRowList associations, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetGPSLogList(struct soap *soap, const char *soap_endpoint, const char *soap_action, int from, int to, struct ns__GPSLogList &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__WriteDev(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, int type, ns__DeviceData data, unsigned int aux1, unsigned int aux2, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ReadDev(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, int type, unsigned int count, unsigned int aux1, unsigned int aux2, ns__DeviceData &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ReadWriteTwi(struct soap *soap, const char *soap_endpoint, const char *soap_action, int boardAddress, unsigned int amplifier, ns__DeviceData data, ns__DeviceData &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__PrepareStart(struct soap *soap, const char *soap_endpoint, const char *soap_action, double *delayTime);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetStartInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__DateTime startTime, int measurementNr, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ExecuteCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, int command, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__StartCalibration(struct soap *soap, const char *soap_endpoint, const char *soap_action, int type, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__Status &status);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__WaitForStatusChange(struct soap *soap, const char *soap_endpoint, const char *soap_action, unsigned int eventCounter, struct ns__Status &status);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__LeaveWaitStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetMetadata(struct soap *soap, const char *soap_endpoint, const char *soap_action, int currentMeasurementNumber, int boardAddress, int blockFrom, int blockTo, ns__MetadataList &metadata);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAllYMetadata(struct soap *soap, const char *soap_endpoint, const char *soap_action, int currentMeasurementNumber, ns__YMetadataList &metadata);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetData(struct soap *soap, const char *soap_endpoint, const char *soap_action, int currentMeasurementNumber, ns__DataSpecificationArray requests, ns__Data &data);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SendServerCustomCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *command, char **result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__LoadAutosequence(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__AutoSequence Sequence, char **result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__StartAutoSequence(struct soap *soap, const char *soap_endpoint, const char *soap_action, char **result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__StopAutoSequence(struct soap *soap, const char *soap_endpoint, const char *soap_action, char **result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetAutoSequence(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__AutoSequence &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SetDeviceSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__DeviceInfo Settings, struct ns__DummyResponse *dummyOut);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetFreeDiskSpace(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns__DiskSpace &DiskSpace);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetMACAddress(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *IPAddress, ULONG64 &MACAddress);

/******************************************************************************\
 *                                                                            *
 * Skeletons                                                                  *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetInterfaceVersion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ResetConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AcquireDeviceLock(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ReleaseDeviceLock(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetClusterConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetClusterConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetHardwareInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetOneParameter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetMultipleParameters(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllCurrentParameters(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllPreviousParameters(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetAttributes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllCurrentAttributes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllPreviousAttributes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetSerTrgProtocol(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ResetSerTrg(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetI2CTrigger(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetI2CTrigger(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetCANTrigger(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetCANTrigger(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllCurrentAssociations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllPreviousAssociations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetAssociations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetGPSLogList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__WriteDev(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ReadDev(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ReadWriteTwi(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__PrepareStart(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetStartInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ExecuteCommand(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__StartCalibration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__WaitForStatusChange(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__LeaveWaitStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetMetadata(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllYMetadata(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SendServerCustomCommand(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__LoadAutosequence(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__StartAutoSequence(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__StopAutoSequence(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAutoSequence(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetDeviceSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetFreeDiskSpace(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetMACAddress(struct soap*);

#endif

/* End of soapStub.h */
